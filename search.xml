<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Core Animation学习笔记（一）- CALayer]]></title>
    <url>%2F2018%2F12%2F02%2FCore%20Animation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文是我阅读书籍《iOS CORE ANIMATION ADVANCED TECHNIQUES》的读书笔记，感谢原书作者及译者的分享！推荐大家有时间可以读读原书，写的很精彩。中文版 一、Core Animation定义什么是Core Animation，相信很多同学对于它既熟悉又陌生，从名字上来看它应该是一个做动画的框架，其实动画只是它的一部分，它曾经叫做Layer Kit。 引用书中的定义： Core Animation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的Layer，并存储在Layer Tree中。于是这个树形成了UIKit以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。 看完还是一脸懵逼？没关系，在这一系列文章中，我将抽丝剥茧，带领大家揭开Core Animation的神秘面纱。 二、UIView与CALayer我们平时开发中，接触最多的就是UIView，UIView可以处理触摸事件，可以支持基于Core Graphics绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。 每个UIView都包含一个CALayer实例，也就是所谓的backing layer。CALayer与UIView最大的区别是它不处理用户的交互，它的职责是负责屏幕上的显示和动画。UIView负责处理用户交互，并管理CALayer。 UIView其实就是对CALayer的高级封装，为什么苹果不直接用一个简单层级来处理所有事情？原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和UIView，但是Mac OS有AppKit和NSView的原因。他们功能上很相似，但是在实现上有着显著的区别。 CALayer独有功能有一些UIView没有暴露出来的CALayer的功能： 阴影，圆角，带颜色的边框 3D变换 非矩形范围 透明遮罩 多级非线性动画 三、backing imagebacking image是CALayer的重要部分，通过它可以实现各种复杂的UI。有两种设置backing image的方法: 设置CALayer的contents属性 直接用Core Graphics绘制 contentsCALayer有一个属性叫做contents，这个属性的类型被定义为id，但是，如果你给contents赋的不是CGImage，那么你得到的图层将是空白的。 contents这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。 我们先来看一个Demo，在CALayer中加载了一张图片： 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor lightGrayColor]; UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)]; view.backgroundColor = [UIColor whiteColor]; view.center = self.view.center; [self.view addSubview:view]; CALayer *layer = [CALayer layer]; [view.layer addSublayer:layer]; layer.frame = CGRectMake(0, 0, 100, 100); // [UIImage imageNamed:@"test"]会根据不同机型取不同倍图 UIImage *image = [UIImage imageNamed:@"test"]; // UIImage转CGImageRef时scale属性丢失 CGImageRef imageRef = image.CGImage; layer.contents = (__bridge id)imageRef; // 设置图片缩放 // 如果contentsGravity设置为自动缩放，可以不用设置这个属性 layer.contentsScale = image.scale; // 设置图片居中不缩放 layer.contentsGravity = kCAGravityCenter;&#125; contentsGravityUIImageView中通过设置contentMode来设置图片拉伸方式，在CALayer中有一个对应属性contentsGravity，它是一个NSString类型，默认值是kCAGravityResize。它的可选的值有： kCAGravityCenter kCAGravityTop kCAGravityBottom kCAGravityLeft kCAGravityRight kCAGravityTopLeft kCAGravityTopRight kCAGravityBottomLeft kCAGravityBottomRight kCAGravityResize kCAGravityResizeAspect kCAGravityResizeAspectFill UIImage转CGImage拉伸丢失问题和UIImage不同，CGImage没有拉伸的概念。使用UIImage类去读取图片的时候，它会读取了屏幕（1x、2x、3x）对应尺寸的图片。但是用CGImage来设置layer.contents时，拉伸这个因素在转换的时候就丢失了，不过我们可以通过手动设置contentsScale来修复这个问题。 contentsScale如果contentsScale设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片。UIView中对应contentScaleFactor属性。 contentsCentercontentsCenter是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。类似于UIImage里的resizableImageWithCapInsets 方法，只是它可以运用到任何backing image，甚至包括Core Graphics绘制的图形。 Custom Drawing第二种方案是直接用Core Graphics绘制backing image，具体实现方式是通过继承UIView并实现drawRect来自定义绘制。 CALayerDelegate要理解drawRect的工作原理，首先我们来看看CALayerDelegate。CALayer有一个可选的delegate，通过实现CALayerDelegate，就可以自定义CALayer的backing image。CALayerDelegate中有两个值得关注的方法： 1234567// 由-display方法的默认实现调用，你应该实现整个显示过程（通常通过设置'contents'属性）// 如果实现了该方法，就不会调用drawLayer:inContext:了- (void)displayLayer:(CALayer *)layer;// 由-drawInContext方法的默认实现调用// 如果没有实现displayLayer:，就会调用该方法- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx; 给个简单的Demo： 1234567891011121314151617181920212223- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor lightGrayColor]; UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)]; view.backgroundColor = [UIColor whiteColor]; view.center = self.view.center; [self.view addSubview:view]; CALayer *layer = [CALayer layer]; [view.layer addSublayer:layer]; layer.frame = CGRectMake(0, 0, 100, 100); // 设置代理 layer.delegate = self; // display方法必须手动调用，不然不会执行绘制 [layer display]; &#125;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx &#123; // 画一个圆环 CGContextSetLineWidth(ctx, 10); CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor); CGContextStrokeEllipseInRect(ctx, layer.bounds);&#125; 需要注意的是，[layer display]需要手动调用，CALayer不会自动重绘它的内容，而是把重绘决定权交给了开发者。 drawRect理解了CALayerDelegate再来看drawRect就简单很多了，UIView把CALayerDelegate设置为自己，并实现了displayLayer:，我们不再需要关心这些细节，只需要重写drawRect，在方法内绘制backing image即可。 drawRect调用时机 当UIView在屏幕上出现的时候，drawRect方法就会被自动调用。然后内容就会被缓存起来直到它需要被更新，通常是因为手动调用了setNeedsDisplay，或影响到表现效果的属性值被更改时，如bounds属性。 需要注意的是，调用setNeedsDisplay后，不会马上触发drawRect，而是要等到接收到RunLoop的kCFRunLoopBeforeWaiting通知后触发drawRect，如下图所示。 如非必须，勿重写drawRect drawRect方法没有默认的实现，因为对UIView来说，backing image并不是必须的。如果UIView检测到drawRect方法被调用了，它就会为视图分配一个backing image，这个backing image的像素尺寸等于视图大小 * contentsScale；反之则不会创建backing image，因此如果没有自定义绘制的任务就不要在重写一个空的drawRect。 在做实验的时候发现了一个有趣现象，在同一个RunLoop循环里，先调用setNeedsDisplay，再设置view.layer的contents，系统就不会调用drawRect方法了(难道是因为设置contents会把needsDisplay设置为NO？？)。 小结如果我们只是写一个简单的登录界面，其实用UIView这种高级接口就够了。但是为了实现复杂UI与丝滑体验，使用Core Animation就是一个很好的选择（缺点是门槛高点，编码复杂度要高些）。本文要点总结如下： Core Animation是一个负责处理图层、屏幕绘制、动画等的复合引擎 UIView是对CALayer的高级封装，每个UIView包含一个CALayer实例。 在CALayer上绘制内容，需要设置它的backing image，有两种方式： 设置CALayer的contents属性 直接用Core Graphics绘制]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F02%2FCore%20Animation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、LayoutUIView有三个比较重要的布局属性：frame，bounds和center，CALayer对应地叫做frame，bounds和position。frame是图层在父图层上的坐标，bounds是内部坐标（{0, 0}通常是左上角）。center和position要难理解一些，简单来说他们定义了anchorPoint在父图层中的位置（后面会详细说明）。 frame其实是一个虚拟属性，是根据bounds，position和transform计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值。 这里有一个容易忽视的细节，我们通常开发的时候frame与bounds的宽高都相等。但是当对图层做变换的时候（旋转或者缩放）frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，这时候它们将不再相等。如下图所示。 二、anchorPoint、position、center三者不得不说的故事要彻底理解position究竟是什么鬼，首先我们得搞懂什么是anchorPoint。它可以理解为一个固定图层的图钉，它的主要作用是作为变换的支点，比如在旋转图层时，就会以anchorPoint为圆心旋转（一起来想象一下）。 anchorPoint用相对坐标表示，它表示相对于图层的位置，取值范围0-1。 左上角：(0,0) 右下角：(1,1) 中心：(0.5,0.5) 而position就表示anchorPoint在父图层的坐标，下面这张图非常的清晰明了。 由于anchorPoint是CALayer的属性，默认值是(0.5,0.5)，也就是中心。而UIView没有这个属性，因此UIView的center属性就表示view的中心点在父view的坐标（命名为center可以说是非常的直观）。 Coordinate Systems坐标系转换CALayer给不同坐标系之间的图层转换提供了一些工具类方法，这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形。 1234- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer;- (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer;- (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer; 翻转常规说来，在iOS上，一个图层的position位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过geometryFlipped属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个BOOL类型。在iOS上通过设置它为YES意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们的geometryFlipped属性也设为YES）。 Z轴和UIView严格的二维坐标系不同，CALayer存在于一个三维空间当中。除了我们已经讨论过的position和anchorPoint属性之外，CALayer还有另外两个属性，zPosition和anchorPointZ，二者都是在Z轴上描述图层位置的浮点类型。 Hit testingCALayer并不关心事件响应链，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：containsPoint:和hitTest:。containsPoint:接受一个在本图层坐标系下的CGPoint，如果这个点在layer的frame范围内就返回YES。hitTest:方法接受一个CGPoint类型参数，它返回这个点所在layer，也就是layer本身，或者叶子节点。 自动布局CALayer不支持自动布局，需要实现CALayerDelegate的函数： 1- (void)layoutSublayersOfLayer:(CALayer *)layer; 然后手动管理布局，非常的不友好，这是一个为什么不直接用CALayer，而是要用UIView的重要原因。 小结 理解frame，bounds，center，position，anchorPoint对于理解图层布局很重要。 CALayer没有处理事件响应链，需要手动处理。 CALayer不支持自动布局。 参考文章这将是你最后一次纠结position与anchorPoint！]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App Store上架漫谈]]></title>
    <url>%2F2018%2F11%2F15%2FApp%20Store%E4%B8%8A%E6%9E%B6%E6%BC%AB%E8%B0%88%2F</url>
    <content type="text"><![CDATA[前言最近忙着写Bug😂，好久没有写文章了。今天和大家分享下我最近上架第二个独立开发的APP“识之”的上架经验（其实就是为了做一波广告）。 重点来了！！！识之，人工智能AI识别，动物、植物、Logo、汽车车型、菜品、通用（识别各种东西）统统可以识别。只需用相机拍一张照片，或者从相册中选择要识别的图片，即可得到答案。使用完全免费使用，解决您的知识焦虑！下载链接：http://t.cn/EAs5ubq五星好评截图返现💕 好了，重点结束了，接下来聊点闲话😏。 聊聊审核“识之”是我上架的第二个独立开发APP，2天搞定审核成功上架（第一个APP是3天），有些心得和大家分享下。不得不说苹果审核团队现在的效率很高，一般一天就可以审核完成，我记得我刚开始做iOS那会，审核一次要一周，真的太漫长了。每次提交新版本之后，第二天早上起床第一件事情就是收邮件。经常会看到这样的标题的邮件，心态瞬间蹦了。 但是不要慌，这只是苹果怀疑你存在一些问题，并不代表真的有问题。先静下心来，读读这篇上架过审秘籍。 然后仔细阅读苹果的答复，仔细揣摩审核团队的用意。把审核团队当做小白用户，站在他们的角度来思考他们提出的问题，然后对照苹果审核条例仔细检查。如果确认自己不存在问题，就直接回复邮件说明，针对审核团队提出的问题详细解释（不需要重新提交二进制文件），一般隔天就能收到审核团队的答复。 这里有个技巧我屡试不爽，提交审核时，可以附上一个演示视频。因为APP的业务逻辑一般比较复杂，单靠文字描述难以表述清楚（想想产品经理当面交代的功能都经常被做偏，别说短短一封邮件了），而且长文本会让人看着很抓狂，审核团队一天密集的审核，看着长篇大论心情自然不好。这时候附上一个精心录制的演示视频，一眼就可以看懂你的APP是干嘛的。视频推荐上传到Youtube方便国外观看。 如果确认APP真的存在问题，那就乖乖的修改吧，修改之后重新提交审核（额。。。马甲包什么的不在本文的讨论范围）。 今年10月后上架的APP都需要提供隐私政策，这篇文章教你轻松应对。 实际案例这里和大家分享下“识之”的上架过程，”香蕉播放器“的上架过程看这篇文章。提交的第二天就收到拒信，涉及到的条款：3.1.4、4.2（这次终于没有刺激的2.1大礼包了）。下面是审核团队的回复： 1234567891011121314151617181920Guideline 3.1.4 - Business - Payments - Content CodesYour app enables additional features or functionality when used with augmented reality markers or QR codes. However, those features are not available in the app to users without the necessary markers.Next StepsTo resolve this issue, please provide a means to access these features from within the app, such as through achievements or in-app purchase. If they can be freely obtained, such as through a link to a website, please revise your app to include clear instructions for obtaining the necessary markers or codes.Please note that apps cannot require users to purchase unrelated products or engage in advertising or marketing activities to unlock app functionality.Guideline 4.2 - Design - Minimum FunctionalityWe noticed that your app includes an AR or QR scanner but does not include any additional content or functionality unless the user has access to the AR marker or QR code. While we understand that your app displays additional content when an AR marker or QR code is scanned, to users who do not have access to the AR markers or QR codes, your app only appears to display a camera view.Next StepsWe encourage you to provide your users with additional content in your app, including directions on how to use your app and information on how to obtain any necessary AR markers or QR codes.To ensure users have the best experience, apps should provide valuable utility or entertainment, draw people in by offering compelling capabilities or content, or enable people to do something they couldn&apos;t do before or in a way they couldn&apos;t do it before. 阅读理解时间开始了，第一遍看完我是一脸懵逼的，回复中提到了两个关键词AR markers和QR codes，可是我根本没有用到这些东西。于是我冷静下来，查了下审核指南。 结合审核指南就能理解审核团队的用意了，他们没有理解我的APP的功能，我的APP主要页面是一个相机，拍一张照片，然后识别图片中的物体是啥。审核团队的理解是APP需要配合特殊的实体物体或者二维码才能正常使用，否则APP就没有任何用途。这显然是误解我了，于是我录制了一个视频，详细的演示了APP的功能，配上文字说明： 123456Dear Apple Review Team: Thank you for your patience review, we have done a detailed check on the following questions. Our app does not depend on specific markers or QR codes,users can use our app recognize anything,such as cars,plants,animals,dishes,logos. We made this app to help users identify objects around them.For example, if the user sees a beautiful plant and wants to know what it is,he can open our app，then take a photo use camera,our app will tell him what is this in the photo. We recorded a detailed demo video to illustrate our features:https://youtu.be/1okyq-ZJGzU Finally, thank you again for your hard review. 第二天上架成功。]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊iOS开发中的JSBridge]]></title>
    <url>%2F2018%2F10%2F22%2F%E8%81%8A%E8%81%8AiOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84JSBridge%2F</url>
    <content type="text"><![CDATA[前言Hybrid App（混合模式移动应用）是指介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。谈到Hybrid App，JS与Native code的交互就是一个绕不开的话题，这时就需要“一座桥”来连接两端。JSBridge架起了一座连接JavaScript与Native Code的桥梁，让两端可以相互调用。 本文基于UIWebView，将会分别介绍3种方案。通过Iframe、Ajax、JSCore来实现JSBridge，涉及到的Demo地址，顺手给个Star呗😏。 实现方案Iframe废话不多说，直入主题，首先讲的这种方案比较常见。WebViewJavascriptBridge与Cordava都是采用的该方案（推荐看看我之前的文章Cordova源码解析）。核心思路就是在UIWebView拦截Iframe的src，双方提前约定好协议，例如https://__jsbridge__就是一次调用开始。可以学习Cordova的策略，将并发的多次调用打包合并为一次处理，可以优化性能。 实现1.JS暴露一个方法给Native，接收执行结果 123456function responseFromObjC(response) &#123; if (!callback) &#123; return; &#125; callback(response);&#125; 2.Native实现UIWebView的代理，在webView:shouldStartLoadWithRequest:navigationType:方法拦截请求，识别到特定URL，开始一次调用流程。 12345678910// 拦截JS调用原生核心方法- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; NSURL *url = request.URL; // 判断url是否是JSBridge调用 if ([url.host isEqualToString:@"__jsbridge__"]) &#123; // 处理JS调用Native return NO; &#125; return YES;&#125; 3.JS开启一个Iframe，加载一个特定的URL，开始一次调用 1234var iframe = document.createElement('iframe');iframe.style.display = 'none';iframe.src = 'https://__jsbridge__?action='+ action + '&amp;data=' + data;document.documentElement.appendChild(iframe); 4.Native方法执行完成后，调用JS方法responseFromObjC将结果回传给JS。 12345678910111213141516171819202122...// 获取调用参数，demo的调用方式是：'https://__jsbridge__?action=action&amp;data='// 参数直接放在query里面的，更好的方案是js暴露一个方法给原生，原生调用方法获取数据NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:YES];NSArray *queryItems = urlComponents.queryItems;NSMutableDictionary *params = [NSMutableDictionary dictionary];for (NSURLQueryItem *queryItem in queryItems) &#123; NSString *key = queryItem.name; NSString *value = queryItem.value; [params setObject:value forKey:key];&#125;NSString *action = params[@"action"];NSString *data = params[@"data"];if ([action isEqualToString:@"alertMessage"]) &#123; // 调用原生方法，获取数据 // js暴露方法`responseFromObjC`给原生，原生通过该方法回调 // 在实际项目中，为了实现实现js并发原生方法，最好带一个callBackID，来区分不同的调用 [webView stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:@"responseFromObjC('%@')", data]];&#125; else &#123; [webView stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:@"responseFromObjC('Unkown action'"]];&#125; PS:demo代码为了简化，直接将参数放在URL的query里，如果只传输一些简单数据是没有问题的，更好的方案是JS先将参数存放起来，通过URL传递一个key给Native，再暴露一个通过key取数据的方法，Native主动调用这个方法取。 Ajax第二种方案是JS使用XMLHttpRequest发起请求，在Native拦截达到调用的目的。通过自定义NSURLProtocol可以拦截到Ajax请求。Demo里有详细的代码和注释，建议结合Demo一起看。 实现1.新建类继承自NSURLProtocol，并注册。 1[NSURLProtocol registerClass:[CRURLProtocol class]]; 2.实现自定义NSURLProtocol，在startLoading方法拦截Ajax请求 1234567- (void)startLoading &#123; NSURL *url = [[self request] URL]; // 拦截“http://__jsbridge__”请求 if ([url.host isEqualToString:@"__jsbridge__"]) &#123; // 处理JS调用Native &#125;&#125; 3.JS发起Ajax请求，URL为提前约定的特殊值，例如：http://jsbridge。请求参数放在Request Body里。 1234567891011// 调用原生function callNative(action, data) &#123; var xhr = new window.XMLHttpRequest(), url = 'http://__jsbridge__'; xhr.open('POST', url, false); xhr.send(JSON.stringify(&#123; action: action, data: data &#125;)); return xhr.responseText;&#125; 4.Naive拦截到请求，获取参数，执行Native方法，最后通过Ajax的Response把结果返回给JS。 123456789101112131415161718192021222324252627...// 2. 从HTTPBody中取出调用参数NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:self.request.HTTPBody options:NSJSONReadingAllowFragments error:nil];NSString *action = dic[@"action"];NSString *data = dic[@"data"];NSData *responseData;// 3. 根据action转发到不同方法处理，param携带参数if ([action isEqualToString:@"alertMessage"]) &#123; responseData = [data dataUsingEncoding:NSUTF8StringEncoding];&#125; else &#123; responseData = [@"Unknown action" dataUsingEncoding:NSUTF8StringEncoding];&#125;// 4. 处理完成，将结果返回给js[self sendResponseWithResponseCode:200 data:responseData mimeType:@"text/html"];...- (void)sendResponseWithResponseCode:(NSInteger)statusCode data:(NSData*)data mimeType:(NSString*)mimeType &#123; NSHTTPURLResponse* response = [[NSHTTPURLResponse alloc] initWithURL:[[self request] URL] statusCode:statusCode HTTPVersion:@"HTTP/1.1" headerFields:@&#123;@"Content-Type" : mimeType&#125;]; [[self client] URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed]; if (data != nil) &#123; [[self client] URLProtocol:self didLoadData:data]; &#125; [[self client] URLProtocolDidFinishLoading:self];&#125; JSCore前两种方案虽然实现方法不一致，但是思路都是类似的，由于JS不能直接调用Native方法，通过曲线救国的方式，找到一个载体来传递信息。第三种方案就比较直接了，使用iOS7推出的黑科技JavaScriptCore，将Native方法直接暴露给JS，打通两端的数据通道。谈到JavaScriptCore不得不说的是bang590的JSPatch，还有ReactNative、Weex等都是利用JavaScriptCore来实现各种炫酷的功能。(强力推荐一本Lefe_x的书《一份走心的JS-Native交互电子书》，非常精彩)。不过这种方案有个缺陷，UIWebView没有暴露JSContext，虽然可以通过KVC拿到，但是毕竟不是一种完美的解决方案，不知道上架会不会有风险（求知道的同学指教一下）。 实现实现流程就不细说了，流程比较简单，Demo里面有。说说关键实现代码 1234567891011121314- (void)injectJSBridge &#123; // 获取JSContext JSContext *context = [_webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]; // 给JS注入方法callNative context[@"callNative"] = ^(JSValue *action, JSValue *data) &#123; NSString *actionStr = [action toString]; NSString *dataStr = [data toString]; if ([actionStr isEqualToString:@"alertMessage"]) &#123; return dataStr; &#125; else &#123; return @"Unkown action"; &#125; &#125;;&#125; JS调用非常简单，一句话搞定。 1callNative("alertMessage", "Hello world!") 性能对比为了验证三种方案的性能，设计了个简单的实验，分别执行了100、1000、10000次调用，测试手机iPhone X，系统iOS 12，时间对比如下图所示。先说结论，JSCore的性能是最优的，JSCore&gt;Ajax&gt;Iframe。在低并发的时候三种方案差距不大，执行次数10000次时Iframe效率就很低了，Ajax次之，JSCore性能很稳定。当然实际使用的时候不会出现调用10000次这种极限情况。Cordova对于并发有个优化策略，很值得参考，将并发的多次调用打包合并为一次处理。]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS定义长字符串的实用宏]]></title>
    <url>%2F2018%2F10%2F16%2FiOS%E5%AE%9A%E4%B9%89%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%94%A8%E5%AE%8F%2F</url>
    <content type="text"><![CDATA[今天在看WebViewJavascriptBridge源码的时候发现一个神奇的宏，在定义较长字符串时很实用。举个例子，将一段js代码存到一个变量，为了便于阅读需要加入换行，需要在每行结束加上\。 123456NSString *str = @"function() &#123; \ if (window.WebViewJavascriptBridge) &#123; \ return; \ &#125; \&#125;)(); \ "; 这时，可以用宏来优化。 1234567#define LONG_STRING_DEFINE(x) #xNSString *str = @LONG_STRING_DEFINE(function() &#123; if (window.WebViewJavascriptBridge) &#123; return; &#125;&#125;)(); ); 宏展开后代码如下 1NSString *str = @";(function() &#123; if (window.WebViewJavascriptBridge) &#123; return; &#125;)();"; 用Xcode看宏展开打开Assistant Editor，选择Preproces，就可以看到展开的宏。]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应对iOS隐私政策三步曲]]></title>
    <url>%2F2018%2F10%2F13%2F%E5%BA%94%E5%AF%B9%E8%8B%B9%E6%9E%9C%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%E4%BA%86%2F</url>
    <content type="text"><![CDATA[国庆假期回来准备提交新版本到App Store，遇到苹果新政策，实测下来影响不大，应对还算比较简单，总结一下分享给大家。 政策说明 从2018年10月3号起，所有新提交的App都必须提供隐私条例，官方连接。 对于隐私条例，苹果审核条例是这么说明的。 需要在两个地方提供隐私条例： 元数据 应用内有明显的入口 生成隐私条例关于隐私条例，网上有各种模板，弄一个改改就行了，这里推荐一个自动生成的网站。免费生成，还提供一个链接，挂在它们网站，就不用自己搞服务器了。例如我给App生成的隐私条例 集成隐私条例第一步：把刚刚生成的URL填在元数据里 第二步：在应用内加一个页面，开一个WebView加载刚刚生成的URL，例如我就放在了“关于-隐私条例” 第三步：提交审核时，在备注里面说明，隐私条例的入口在哪里。（这一步可能不要也行，不过为了稳妥我加上了，给苹果审核团队讲清楚总是好的） 第二天就上架成功了。]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记“香蕉播放器”上架的辛酸历程]]></title>
    <url>%2F2018%2F10%2F07%2F%E8%AE%B0%E2%80%9C%E9%A6%99%E8%95%89%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%9D%E4%B8%8A%E6%9E%B6%E7%9A%84%E8%BE%9B%E9%85%B8%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[写在前面先说点废话，从事iOS开发以来，一直有一个目标，拥有一个自己的APP上架App Store，并且登上苹果推荐榜单，这可能是大多数iOSer的梦想。在脑子里产生了各种想法，但是发现自己能想到的别人都做了，并且做的很好，加上工作生活上的很多事情（主要是懒😝），一拖就是3年。后来因为自己的真实需求，App Store找不到能满足需求的产品，就做了一个播放器自己用，在中秋假期狠下心来，买了开发者账号（688，心痛！！就当为了梦想充值吧。），把这个播放器上架了。 购买开发者账号关于怎么买个人开发者账号，网上的教程一抓一大把，整个购买流程也没啥好注意的，根据提示一步一步走就OK了。但是到了最后付款环节把我卡了一周（办了两张信用卡。。。），必须要visa+银联双标的信用卡，注意一定要双标，只有visa或者只有银联都不行。付了款一天左右苹果就会发来邮件，提供身份证正反面照片就可以了。 上架App Store上架流程就轻车熟路了，打包上传、填写各种APP说明、上传图标、宣传图、提交审核。激动的我一晚上没睡好觉，第二天早上打开邮箱，等待我的居然是2.1大礼包（Guideline 2.1 - Information Needed）。 一看我就懵逼了，上架这么多次第一次遇到这么严厉的回复，感觉分分钟要被封号。经过多方咨询，发现这是苹果今年新推出的大礼包，很多人都遇到过，一般是机器审核回复的，遇到这种情况别慌（除非你是马甲包、或者抄袭的之类的APP），仔细检查条例，然后逐条答复（最好用英文）。最后我还录制了一个视频，来演示我的APP的主要功能，上传到youtube，附在了备注。分享下我的答复模板： 12345678910111213141516171819202122232425262728293031323334353637383940414243尊敬的苹果审核团队： 感谢您的耐心审核，针对下面问题，我们做了详细的检查 关于 Guideline 2.11.1.6 - “香蕉播放器”没有包含任何的虚假与误导信息，全部都是真实有效的2.3.0 - “香蕉播放器”没有在通过审核后修改任何概念和功能2.3.1 - “香蕉播放器”没有包含任何隐藏功能，没有包含赌博、彩票网站3.1.1 - “香蕉播放器”内没有任何内购、支付功能，所有功能都是免费提供给用户3.2.1 - “香蕉播放器”内部包含任何贷款等金融服务4.3.0 - “香蕉播放器”功能都是独立开发，不存在抄袭或者大量相似5.2.1 - “香蕉播放器”没有法人实体和版权风险5.2.3 - “香蕉播放器”没有提供文件共享服务，或者其它存在版权问题的音视频5.3.4 - “香蕉播放器”仅在中国区上架，没有违规内容关于 Guideline 2.3.7我已经按照说明，修改了元数据，请审核团队再次审核。最后再次感谢您辛苦的审核。Dear Apple Review Team: Thank you for your patience review, we have done a detailed check on the following questions. About Guideline 2.11.1.6 - &quot;Banana Player&quot; does not contain any false and misleading information, all of which are true and effective2.3.0 - &quot;Banana Player&quot; does not modify any concepts and features after passing the review2.3.1 - &quot;Banana Player&quot; does not contain any hidden features, does not contain gambling, lottery sites3.1.1 - There is no in-app purchase and payment function in the “Banana Player”, all functions are provided to the user free of charge.3.2.1 - &quot;Banana Player&quot; contains any financial services such as loans4.3.0 - The &quot;Banana Player&quot; feature is developed independently, without plagiarism or a lot of similarity5.2.1 - &quot;Banana Player&quot; has no legal entity and copyright risk5.2.3 - &quot;Banana Player&quot; does not provide file sharing services, or other audio and video with copyright issues5.3.4 - &quot;Banana Player&quot; is only available in China, no illegal contentAbout Guideline 2.3.7I have modified the metadata according to the instructions, please review the team again.Finally, thank you again for your hard review. 第二天审核通过，成功上架！ 打个广告 下载🔗：https://dwz.cn/HvVix2hH “香蕉播放器”是我独立开发的第一款APP，免费无广告。主要功能在手机上播放从网盘、光盘、网站下载的音频资料、课程、音乐。无需数据线，用Wi-Fi就可以拷贝文件到手机，自动记录播放进度。如果有需求可以支持一波，有什么问题欢迎联系我。]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一个行结束符引发的JS报错]]></title>
    <url>%2F2018%2F09%2F05%2F%E8%AE%B0%E4%B8%80%E4%B8%AA%E8%A1%8C%E7%BB%93%E6%9D%9F%E7%AC%A6%E5%BC%95%E5%8F%91%E7%9A%84JS%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[问题描述最近遇到一个神奇的Bug，通过UIWebView的stringByEvaluatingJavaScriptFromString:方法执行一段JavaScript代码时，JavaScript报错: SyntaxError: Unexpected EOF 经过仔细的排查，发现待执行的JavaScript代码里面包含U+2028字符。还找到了Stack Overflow相关讨论。JavaScript解析器会把行分隔符U+2028和段落分隔符U+2029解析成一行的结束，代码里要是包含这两个字符相当于换行，例如： alert(“\u2028”) 就会被解析为 alert(““) 于是就产生了语法错误。 解决方案我用的方法比较简单、粗暴，在执行JavaScript代码前，直接过滤掉这两个字符。代码如下： 1234// javaScriptString = [javaScriptString stringByReplacingOccurrencesOfString:@"\u2028" withString:@""]; javaScriptString = [javaScriptString stringByReplacingOccurrencesOfString:@"\u2029" withString:@""]; NSString* ret = [(UIWebView*)_engineWebView stringByEvaluatingJavaScriptFromString:javaScriptString];]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从一个AFNetworking循环引用说起]]></title>
    <url>%2F2018%2F08%2F28%2F%E4%BB%8E%E4%B8%80%E4%B8%AAAFNetworking%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[本文分析使用代码是AFNetworking 3.2.1 最近使用Instruments中的Leaks分析项目内存泄露，发现了一个AFNetworking的循环引用。如下图所示： 通过调用栈发现产生泄露的代码在这里： 12345678910// AFURLSessionManager.m- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123; // ... 初始化代码，省略 // 导致循环引用的方法 self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; // ... 其它初始化代码，省略 return self;&#125; 大致原因就是AFURLSessionManager引用NSURLSession，同时设置NSURLSession的delegate为自己，NSURLSession会强引用delegate，于是产生了循环引用。 关于NSURLSession的delegate官方说明：This delegate object is responsible for handling authentication challenges, for making caching decisions, and for handling other session-related events. The session object keeps a strong reference to this delegate until your app exits or explicitly invalidates the session. If you do not invalidate the session, your app leaks memory until it exits. 解决方案在AFNetworking官方issues找到了相关的问题Possible memory leak in AFURLSessionManager。作者的回答如下： 解决方案有两种： 这是最常见也是作者推荐的方法，只创建一个AFURLSessionManager，整个APP共享，虽然还是有循环引用，但是就没有内存泄露的问题了。 如果要使用多个AFURLSessionManager，在使用完成后手动调用invalidateSessionCancelingTasks:来断开循环引用。（这种方案不推荐，具体原因看下一小节） AFURLSessionManager复用关于AFURLSessionManager是否使用单例这个问题，官方demo使用的是单例，在苹果官方文档找到这么一段话 With the NSURLSession API, your app creates one or more sessions, each of which coordinates a group of related data transfer tasks. For example, if you’re creating a web browser, your app might create one session per tab or window, or one session for interactive use and another for background downloads. Within each session, your app adds a series of tasks, each of which represents a request for a specific URL (following HTTP redirects, if necessary). 我的理解是这样的，根据使用场景的不同，这个问题有不同的答案，在大多数场景下APP都是在和同一服务器打交道，一个session就够了，如果有连接多个服务器、或者后台下载等功能需求，可以给每个服务器、后台下载任务创建单独的session（但是也不能每个请求都单独创建session）。 在查找资料的时候，我发现有博客提到单例seesion可以减少TCP三次握手，动手验证下： 多个网络请求复用一个AFURLSessionManager，连续发两个网络请求，用Wireshark抓包可以看到，第二次网络请求复用了第一次的TCP连接，没有做三次握手。 下图是每次网络请求都新建一个AFURLSessionManager的抓包，可以看到每个网络请求都进行了TCP三次握手。 实验结果的确如网上所说，复用AFURLSessionManager可以减少三次握手，提升效率。]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS模拟器安装debug包]]></title>
    <url>%2F2018%2F08%2F21%2FiOS%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AE%89%E8%A3%85debug%E5%8C%85%2F</url>
    <content type="text"><![CDATA[由于项目是Hybrid的平台，有第三方人员需要在上面开发H5应用，但是release包不能调试H5，只有debug报可以调试，但是项目源码不能交给第三方，在google搜索了下，发现一篇霜神的文章，讲的是debug包可以拷贝到其它机器运行，于是实践了一波。 环境准备 Xcode Command Line Tools ios-sim ios-sim安装命令：npm install ios-sim -g 拷贝本地的debug包 run一次需要拷贝的项目，安装到模拟器上 执行下面命令行，需要注意的是目标路径/xxx.zip就是拷贝出来的debug应用包，需要替换为自己的路径，例如/Users/crmo/Desktop/debug/debug.zip 1ditto -ck --sequesterRsrc --keepParent `ls -1 -d -t ~/Library/Developer/Xcode/DerivedData/*/Build/Products/*-iphonesimulator/*.app | head -n 1` 目标路径/xxx.zip 拷贝debug包到其它模拟器1. 获取模拟器列表 ios-sim showdevicetypes 可以看到类似于下面的输出，就是本机可用的模拟器，选择一个需要运行的模拟器。 123456789101112131415161718192021~ ios-sim showdevicetypesApple-Watch-38mm, watchOS 4.3Apple-Watch-42mm, watchOS 4.3Apple-Watch-Series-2-38mm, watchOS 4.3Apple-Watch-Series-2-42mm, watchOS 4.3iPhone-7-Plus, 10.3iPhone-7-Plus, 11.4Apple-Watch-Series-3-38mm, watchOS 4.3Apple-Watch-Series-3-42mm, watchOS 4.3iPhone-5s, 11.4iPhone-6, 11.4iPhone-6-Plus, 11.4iPhone-6s, 11.4iPhone-6s-Plus, 11.4iPhone-7, 11.4iPhone-SE, 11.4iPad-Air, 11.4iPad-Air-2, 11.4iPhone-8, 11.4iPhone-8-Plus, 11.4iPhone-X, 11.4 2. 在模拟器上启动debug包 ios-sim launch 应用包路径/xxx.app –devicetypeid 模拟器 需要说明的是，debug.zip解压后就可以得到对应应用的.app文件，例如我的debug包放在/Users/crmo/Desktop/debug/debug.app，模拟器选择iPhone-8，最终的命令是 ios-sim launch /Users/crmo/Desktop/debug/debug.app –devicetypeid iPhone-8 simctl was not found错误解决在实践时测试机的Command Line Tools没有配置好，出现报错： 1234simctl was not found.Check that you have Xcode 8.x installed: xcodebuild --versionCheck that you have Xcode 8.x selected: xcode-select --print-path 解决办法： 1.首先确保正确安装了Command Line Tools， 卸载Command Line Tools:rm -rf /Library/Developer/CommandLineTools安装Command Line Tools:xcode-select –install 2.在xcode配置一下Command Line Tools，如下图所示 参考博客： unable to find utility “simctl”的解决方案 给 iOS 模拟器 “安装”app 文件]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dispatch_sync死锁问题]]></title>
    <url>%2F2018%2F08%2F03%2Fdispatch_sync%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题分析使用dispatch_sync的时候要小心谨慎，稍不注意就会导致死锁问题，先看两个典型的案例： 案例一 12345678- (void)deadlock1 &#123; dispatch_queue_t queue = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^&#123; dispatch_sync(queue, ^&#123; NSLog(@&quot;&quot;); &#125;); &#125;);&#125; 案例二 1234567891011- (void)deadlock2 &#123; dispatch_queue_t queue1 = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL); dispatch_queue_t queue2 = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(queue1, ^&#123; dispatch_sync(queue2, ^&#123; dispatch_sync(queue1, ^&#123; NSLog(@&quot;&quot;); &#125;); &#125;); &#125;);&#125; 上面两个案例死锁的原因都是同一个串行队列的任务相互等待。 当然实际工程中遇到的死锁问题会更加复杂，难以分析。 典型误区在阅读相关书籍、博客都提到了一个方法dispatch_get_current_queue()，通过这个方法可以获取到当前队列，于是有人就用它来解决死锁问题。 123456789101112- (void)safeSync:(void(^)())block &#123; if (!block) &#123; return; &#125; if (dispatch_get_current_queue() == queue) &#123; block(); &#125; else &#123; dispatch_sync(queue, ^&#123; block(); &#125;); &#125;&#125; 第一眼看起来天衣无缝，对于案例一的确可以完美解决，但是对于案例二这种对队列的情况就判断不了。难怪苹果在iOS6就注释了这个方法。 推荐阅读： Thread-Safe Class Design]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIWebView获取详细浏览记录]]></title>
    <url>%2F2018%2F08%2F01%2FUIWebView%E8%8E%B7%E5%8F%96history%2F</url>
    <content type="text"><![CDATA[本文所用方法会使用到苹果私有API，上架APP Store请谨慎使用。 需求获取UIWebView的前进后退的浏览记录，举个例子，比如从A-&gt;B-&gt;C-&gt;B，此时B上一页是A，下一页是C，需要获取A、C的URL信息。 WKWebView暴露了这个属性，WKBackForwardList *backForwardList。可以很容易的取到，无奈项目还是使用的UIWebView，于是有了后面的探索。 首先在UIWebView提供的API里找，相关的API只有canGoBack和canGoForward，命名很直观，是否可以后退和前进，这条路走不通。想到是否可以通过JS的Window.history获取到，查了下API，唯一一个有点像的length属性，智能取到浏览记录中的所有URL的数量，不区分前后，比如在上面提到的例子中，在B页面取到的length是3，而且不能取出具体的URL。 无奈只有上源码了，我下载的是“WebKit-7604.1.38.0.7”和“WebCore-7604.1.38.0.7”。 Window.History.length实现本质在WebCore里面找到了JS方法Window.History.length实现的本质，上代码： 12345678910// WebCore History.cppunsigned History::length() const&#123; if (!m_frame) return 0; auto* page = m_frame-&gt;page(); if (!page) return 0; return page-&gt;backForward().count();&#125; 123456// WebCore BackForwardController.cppint BackForwardController::count() const&#123; // count = 当前页之前的页面总数 + 当前页之后的页面总数 + 1 return m_client-&gt;backListCount() + 1 + m_client-&gt;forwardListCount();&#125; 在WebCore里面backListCount()、forwardListCount()定义是虚函数，具体实现在WebKit可以找到。 12345678910// WebKit BackForwardList.mmint BackForwardList::backListCount()&#123; return m_current == NoCurrentItemIndex ? 0 : m_current;&#125;int BackForwardList::forwardListCount()&#123; return m_current == NoCurrentItemIndex ? 0 : (int)m_entries.size() - (m_current + 1);&#125; 还有一个方法我们需要关注一下，后面会用到。 1234567891011// WebKit BackForwardList.mm// 获取之前最多几条历史记录void BackForwardList::backListWithLimit(int limit, Vector&lt;Ref&lt;HistoryItem&gt;&gt;&amp; list)&#123; list.clear(); if (m_current != NoCurrentItemIndex) &#123; unsigned first = std::max(static_cast&lt;int&gt;(m_current) - limit, 0); for (; first &lt; m_current; ++first) list.append(m_entries[first].get()); &#125;&#125; 获取History在WebView的中，我们可以找到WebBackForwardList的定义。 12345/*! @property backForwardList @abstract The backforward list for this WebView.*/ @property (nonatomic, readonly, strong) WebBackForwardList *backForwardList; WebBackForwardList是对BackForwardList的一层封装，阅读一下它的.h文件，不难找到获取浏览记录的方法。 1234567/*! @method backListWithLimit: @abstract Returns a portion of the list before the current entry. @param limit A cap on the size of the array returned. @result An array of items before the current entry, or nil if there are none. The entries are in the order that they were originally visited.*/- (NSArray *)backListWithLimit:(int)limit; 上面的方法可以获取到一个WebHistoryItem数组，WebHistoryItem保存了浏览记录的详细信息。 获取WebBackForwardListUIWebView没有暴露获取WebView或者WebBackForwardList的方法，但是我们可以用KVO曲线救国，于是我们需要找到WebView的私有变量名。用runtime可以做到，为了简化这个过程，我写了一个工具类来辅助搜索，具体可以看这篇文章-runtime实现私有变量搜索。简单来说就是用runtime获取类成员变量列表，然后用BFS来搜索我们要找的类。 12345678910// 以UIWebView为根节点，BFS搜索WebView[BFSSearchClass searchClass:@"WebView" inClass:@"UIWebView"];// 搜索结果如下// Class Name：类名，Ivar Name：变量名，Super Class：父类Class Name:【WebView】,Ivar Name:【_webView】Class Name:【UIWebDocumentView】,Ivar Name:【Super Class】Class Name:【UIWebBrowserView】,Ivar Name:【browserView】Class Name:【UIWebViewInternal】,Ivar Name:【_internal】Root Class:UIWebView 有了上面的结论，我们就可以用KVC来获取到浏览记录了。 12345678910111213- (void)printWebViewHistory:(UIWebView *)aWebView &#123; id webviewInternal = [aWebView valueForKey:@"_internal"]; id browserView = [webviewInternal valueForKey:@"browserView"]; id webView = [browserView valueForKey:@"_webView"]; id backForwardList = [webView performSelector:@selector(backForwardList)]; // WebHistoryItem存储的具体某条浏览记录信息 NSArray *historyItems = [backForwardList performSelector:@selector(backListWithLimit:) withObject:@10]; for (id item in historyItems) &#123; // 获取浏览记录的url NSString *url = [item performSelector:@selector(URLString)]; NSLog(@"%@", url); &#125;&#125;]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime实现私有变量搜索]]></title>
    <url>%2F2018%2F07%2F31%2Fruntime%E5%AE%9E%E7%8E%B0%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[本文Demo(https://github.com/crmo/BFSSearchClass)地址 需求在开发功能时，为了满足产品变态的需求，难免有系统类提供的API不够用的时候，这时候私有变量就可以发挥它光和热了。怎么通过一个类，一层一层的找到特定类型的私有成员变量？受益于Objective-C的动态语言特性，就算苹果UIKit不开源，但是在runtime面前，类的结构还是暴露无遗。我的思路是逐层手动打印成员变量信息，如果是UI控件可以用Reveal来加快进度，配合KVC机制，获取私有变量就如同探囊取物一般。在多次遇到这个问题后，我决定实现一个工具类来简化这个过程，毕竟能自动化的就尽量不要手动。 思路 搜索范围：成员变量、属性 关键步骤如下： runtime中的方法class_copyIvarList()，可以取出类的所有成员变量结构体Ivar。 从Ivar中可以取出成员变量类型Type Encodings 用Type Encodings获取到类名 遍历类的所有Ivar，获取到类的所有成员变量的类信息 但是问题没这么简单，比如ClassA是ClassB的成员变量，ClassB是ClassC的成员变量，想通过ClassC找到ClassA，需要向下找两层才能找到，还要考虑父类的情况。整个搜索过程就是一颗以待搜索类为根的树，可以用BFS来搜索，步骤如下（如图，数字是搜索顺序）： 从根节点开始搜索 首先遍历当前节点的父类，加入搜索队列 再取出当前节点的所有成员变量，加入搜索队列 如何从Ivar中获取ClassIvar中不能直接取出对应类名，只能取出Type Encodings，间接可以得到类名。从官方文档截了张图，可以清晰的看到Code的定义。 基本数据类型、id类型、集合类型、结构体等类型就不需要搜索了，可以过滤掉。我们只搜索两种类型 类，例如@&quot;UIWebViewInternal&quot; 代理，例如@&quot;&lt;UIViewControllerTransitioningDelegate&gt;&quot; 优化及存在问题 可以用一个NSMutableSet存储已经搜索过的类，每次搜索前判断一下是否已经搜索过 记录搜索次数，可以限制搜索次数。 对于定义为id类型、集合类的成员变量没有做处理，可以继续深入遍历]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS横竖屏总结]]></title>
    <url>%2F2018%2F07%2F23%2FiOS%E6%A8%AA%E7%AB%96%E5%B1%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[使用Auto Layout来进行布局就不用自己去监听横竖屏事件了，只需要绘制多套布局即可。但是项目有很多页面是自己手动计算的，于是只有想办法再旋转屏幕时重新布局。 相关枚举屏幕方向有3个相关枚举，界面方向UIInterfaceOrientation，设备方向UIDeviceOrientation，支持旋转方向UIInterfaceOrientationMask。 注意UIInterfaceOrientation与UIDeviceOrientation左右方向是相反的 1234567891011121314151617typedef NS_ENUM(NSInteger, UIInterfaceOrientation) &#123; UIInterfaceOrientationUnknown = UIDeviceOrientationUnknown, UIInterfaceOrientationPortrait = UIDeviceOrientationPortrait, UIInterfaceOrientationPortraitUpsideDown = UIDeviceOrientationPortraitUpsideDown, UIInterfaceOrientationLandscapeLeft = UIDeviceOrientationLandscapeRight, UIInterfaceOrientationLandscapeRight = UIDeviceOrientationLandscapeLeft&#125;;typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) &#123; UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait), UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft), UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight), UIInterfaceOrientationMaskPortraitUpsideDown = (1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown), UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight), UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown), UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),&#125;; 横竖屏控制控制界面横竖屏切换有3个重要的点，最终结果以这三个地方的值取交集。 1.info.plist全局控制 可以在General-&gt;Deplyment Info界面上勾选 info.plist文件中配置也是一样的，两边会同步变更 2.AppDelegate中根据不同Window控制 1234// AppDelegate- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123; return UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskPortrait;&#125; 3.在ViewController中控制当前页面 12345678// UIViewController- (BOOL)shouldAutorotate &#123; return YES;&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123; return UIInterfaceOrientationMaskLandscapeLeft;&#125; 需要注意的是，交集不能为空，否则会导致crash *** Terminating app due to uncaught exception ‘UIApplicationInvalidInterfaceOrientation’, reason: ‘Supported orientations has no common orientation with the application, and [ViewControllershouldAutorotate] is returning YES’ 旋转事件监听旋转事件传递过程1234567op0=&gt;operation: __CFRunLoopDoSources0op1=&gt;operation: UIDeviceop2=&gt;operation: UIWindowop3=&gt;operation: UIViewControllerop4=&gt;operation: UIViewop1-&gt;op2-&gt;op3-&gt;op4 屏幕旋转相关事件viewWillTransitionToSize:withTransitionCoordinator: ViewController被父容器变更size时调用（例如window旋转时调用root view controller的该方法） 如果重载该方法，需要调用super传递事件给子ViewController 这个方法是最关键的，可以在该方法中对界面进行重新布局 12345678910111213- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator&#123; // coordinator用来处理转换动画 [coordinator animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context) &#123; // 开始旋转 &#125; completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context) &#123; // 旋转结束 &#125;]; // 记得调用super [super viewWillTransitionToSize:size withTransitionCoordinator:coordinator];&#125; UIApplicationWillChangeStatusBarOrientationNotification 状态栏将要旋转，这个时候取view的frame还是旋转之前的 NSNotification中用key UIApplicationStatusBarOrientationUserInfoKey可以取到将要旋转到的方向。 UIApplicationDidChangeStatusBarOrientationNotification 状态栏已经旋转，这个时候取view的frame是旋转之后的 NSNotification中用key UIApplicationStatusBarOrientationUserInfoKey可以取到旋转之前的方向。 UIDeviceOrientationDidChangeNotification 设备方向变更，在收到通知时取view的frame是旋转之后的。 在手机上将旋转屏幕锁定之后，设备方向变更之后收不到该通知 在代码里面限制设备旋转方向，设备方向变更后依然能收到该通知 调用顺序如下 12345678910st=&gt;start: 旋转屏幕e=&gt;end: 结束op1=&gt;operation: viewWillTransitionToSize:withTransitionCoordinator:op2=&gt;operation: UIApplicationWillChangeStatusBarOrientationNotificationop3=&gt;operation: UIApplicationDidChangeStatusBarOrientationNotificationop4=&gt;operation: viewWillLayoutSubviewsop5=&gt;operation: viewDidLayoutSubviewsop6=&gt;operation: UIDeviceOrientationDidChangeNotificationst-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;e 自定义Window的旋转事件如果想要在自定义Window的子View收到屏幕旋转通知，要设置UIWindow的rootViewController，然后把所有子view都加到rootViewController，系统会处理横竖屏事件。这里我还遇到一个坑记一个实现UIWindow子类的小坑。 推荐阅读https://satanwoo.github.io/2016/09/17/uiwindow-iOS/iOS屏幕旋转知识点以及实现iOS 屏幕旋转的那些事（一）浅谈iOS的多Window处理]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一个实现UIWindow子类的小坑]]></title>
    <url>%2F2018%2F07%2F19%2F%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0UIWindow%E5%AD%90%E7%B1%BB%E7%9A%84%E5%B0%8F%E5%9D%91%2F</url>
    <content type="text"><![CDATA[问题描述项目中为了实现一个全局遮罩界面，使用了一个UIWindow的子类MyWindow，MyWindow为了实现回调定义了代理MyWindowDelegate。代码大致如下： 123456789101112131415161718192021@protocol MyWindowDelegate &lt;NSObject&gt;@end@interface MyWindow : UIWindow@property (nonatomic, assign)id&lt;MyWindowDelegate&gt; delegate;@end@implementation MyWindow- (instancetype)init&#123; self = [super init]; if (self) &#123; self.windowLevel = UIWindowLevelNormal; self.backgroundColor = [UIColor whiteColor]; UIViewController *vc = [[ViewController2 alloc] init]; self.rootViewController = vc; self.hidden = NO; &#125; return self;&#125;@end 然后在实现界面横屏时，发现整个UIWindow不响应横竖屏事件。刚开始以为横竖屏设置被关闭了，查了各种资料，发现这种写法是没有问题的。设置UIWindow的rootViewController，然后把所有子view都加到rootViewController，系统会处理横竖屏问题。 问题分析用Runtime把UIWindow的私有变量打出来，就发现问题了。 123456789#import &lt;objc/runtime.h&gt;- (void)printUIWindowIvars &#123; Ivar *ivars = class_copyIvarList([UIWindow class], &amp;count); for (int i = 0; i &lt; count; i++) &#123; Ivar ivar = ivars[i]; NSLog(@"%s", ivar_getName(ivar)); &#125;&#125; 我们看看输出，发现有个私有变量_delegate。 MyWindow的属性delegate覆盖了父类UIWindow的变量，导致横竖屏切换事件失效。在代理命名的时候一定要注意啊，delegate看来不是一个好的实践，应该加前缀区分避免覆盖父类的实现，特别是这种私有的变量。]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个autoreleasepool的使用场景]]></title>
    <url>%2F2018%2F07%2F18%2F%E4%B8%80%E4%B8%AAautoreleasepool%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[今天在学习大佬博客的时候看到一个问题，下面代码会有什么问题？ 123456// largeNumber是一个很大的数for (int i = 0; i &lt; largeNumber; i++) &#123; NSString *str = [NSString stringWithFormat:@"hello -%04d", i]; str = [str stringByAppendingString:@" - world"]; NSLog(@"%@", str);&#125; 刚开始没看出什么问题，就是普通的循环，每次循环创建一个局部变量NSString。于是写了个Demo验证了下，在观察内存的时候发现了端倪，在循环过程中，内存不断飙升。 顿时明白了，原来问题的关键就是这个largeNumber，当循环此时很大时，就会创建大量的局部变量，而且得不到释放，于是内存就爆了。这时候就该@autoreleasepool上场了，优化后代码： 1234567for (int i = 0; i &lt; largeNumber; i++) &#123; @autoreleasepool &#123; NSString *str = [NSString stringWithFormat:@"hello -%04d", i]; str = [str stringByAppendingString:@" - world"]; NSLog(@"%@", str); &#125;&#125; 查看运行内存，可以看到非常平稳。]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITabbar自定义Badge]]></title>
    <url>%2F2018%2F07%2F10%2FUITabbar%E8%87%AA%E5%AE%9A%E4%B9%89Badge%2F</url>
    <content type="text"><![CDATA[tabBarItem的Badge默认样式是带数字的，但是产品要求只要一个小红点，不需要数字，这就需要我们自定义Badge了。 用Reveal分析UITabBar，发现每个按钮是一个UITabBarButton，层级如下： -UITabBarButton–UITabBarSwappableImageView // 图标–UITabBarButtonLabel // 文字 如何从UITabBar中找到对应index的UITabBarButton呢？我们断点调试下，可以看到可以直接从UITabBar中用KVC取出。 实现方案如下： 用KVC找到UITabBarSwappableImageView，关键函数__iconViewWithIndex 新建Badge，加到UITabBarSwappableImageView上 新建Badge的时候设置Tag，通过Tag来移除Badge 上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static NSInteger const kBadgeViewTagBase = 10000;@implementation UITabBar (badge)// 显示Badge- (void)showBadgeOnItemIndex:(int)index &#123; if (index &gt;= self.items.count) &#123; return; &#125; // 如果之前添加过，直接设置hidden为NO UIView *icon = [self __iconViewWithIndex:index]; for (UIView *subView in icon.subviews) &#123; if (subView.tag == kBadgeViewTagBase) &#123; subView.hidden = NO; return; &#125; &#125; UIView *badgeView = [[UIView alloc] init]; badgeView.tag = kBadgeViewTagBase; badgeView.layer.cornerRadius = 5; badgeView.backgroundColor = [UIColor redColor]; badgeView.frame = CGRectMake(icon.frame.size.width - 5, 0, 9, 9); [icon addSubview:badgeView];&#125;// 隐藏Badge- (void)hideBadgeOnItemIndex:(int)index &#123; UIView *icon = [self __iconViewWithIndex:index]; for (UIView *subView in icon.subviews) &#123; if (subView.tag == kBadgeViewTagBase) &#123; subView.hidden = YES; &#125; &#125;&#125;// 获取图标所在View- (UIView *)__iconViewWithIndex:(int)index &#123; UITabBarItem *item = self.items[index]; UIView *tabBarButton = [item valueForKey:@"_view"]; UIView *icon = [tabBarButton valueForKey:@"_info"]; return icon;&#125;@end]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算文字长度]]></title>
    <url>%2F2018%2F07%2F09%2F%E8%AE%A1%E7%AE%97%E6%96%87%E5%AD%97%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[官方文档 方法定义1234- (NSRect)boundingRectWithSize:(NSSize)size options:(NSStringDrawingOptions)options attributes:(NSDictionary&lt;NSAttributedStringKey, id&gt; *)attributes context:(NSStringDrawingContext *)context; 参数定义size绘制的限制size，计算出来的值不会超过这个大小。 options一些配置项。定义如下： 1234567typedef NS_OPTIONS(NSInteger, NSStringDrawingOptions) &#123; NSStringDrawingUsesLineFragmentOrigin = 1 &lt;&lt; 0, // The specified origin is the line fragment origin, not the base line origin NSStringDrawingUsesFontLeading = 1 &lt;&lt; 1, // Uses the font leading for calculating line heights NSStringDrawingUsesDeviceMetrics = 1 &lt;&lt; 3, // Uses image glyph bounds instead of typographic bounds NSStringDrawingTruncatesLastVisibleLine NS_ENUM_AVAILABLE(10_5, 6_0) = 1 &lt;&lt; 5, // Truncates and adds the ellipsis character to the last visible line if the text doesn't fit into the bounds specified. Ignored if NSStringDrawingUsesLineFragmentOrigin is not also set.&#125; NS_ENUM_AVAILABLE(10_0, 6_0); 实际测试使用NSStringDrawingUsesLineFragmentOrigin|NSStringDrawingUsesFontLeading可以满足需求，NSStringDrawingUsesLineFragmentOrigin是必须的，NSStringDrawingUsesFontLeading加不加在测试的时候没发现区别，但是在stackoverflow相关讨论里加上了，留个坑，后面知道为什么了来补充吧。 attributes字体 context上下文 注意事项 如果是多行文字，options要加上NSStringDrawingUsesLineFragmentOrigin 返回的值是小数，需要调用ceil向上取整 得到的宽度可能比实际宽 代码示例1234567891011121314151617181920+ (CGSize)getTextLabelSize:(NSString *)message &#123; if ([message length] &gt; 0) &#123; // 文本框的最大宽度 float maxWidth = 200; CGRect textRect = [message boundingRectWithSize:CGSizeMake(maxWidth, CGFLOAT_MAX) options:(NSStringDrawingUsesLineFragmentOrigin | NSStringDrawingUsesFontLeading) attributes:@&#123; NSFontAttributeName : [UIFont systemFontOfSize:16] &#125; context:nil]; textRect.size.height = ceilf(textRect.size.height); textRect.size.width = ceilf(textRect.size.width); return CGSizeMake(textRect.size.width, textRect.size.height); &#125; else &#123; return CGSizeZero; &#125;&#125;]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITextField控制输入长度]]></title>
    <url>%2F2018%2F07%2F06%2FUITextField%E6%8E%A7%E5%88%B6%E8%BE%93%E5%85%A5%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[有些时候会有控制输入框文字长度的需求，记录一个简单的思路。 12345678910111213141516171819- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &#123; if (string.length == 0) &#123; return YES; &#125; NSInteger limit = 15; // 文本的最大长度 NSString *newStr = [textField.text stringByAppendingString:string]; // 修改之后的新字符串 NSInteger newStrLength = newStr.length; newStrLength -= [textField textInRange:[textField markedTextRange]].length; // 去掉高亮内容，输入中文拼音的情况 if (newStrLength &gt; limit) &#123; // 处理composed character, 比如emoji NSString *tempStr = [newStr substringWithRange:[newStr rangeOfComposedCharacterSequencesForRange:NSMakeRange(0, limit)]]; textField.text = tempStr; return NO; &#125; return YES;&#125; 有两个坑注意下： emoji是composed character，它是由多个字符组合，长度不是1。最开始用的substringToIndex会导致最后一个emoji乱码。 计算长度的时候要去掉中文输入的时候高亮部分]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[property or synthsize]]></title>
    <url>%2F2018%2F07%2F05%2Fproperty%20or%20synthsize%2F</url>
    <content type="text"><![CDATA[@property (nonatomic, retain) NSObject *var; 生成var的set、get方法的方法声明 生成var的set、get方法的实现（早期版本编译器不生成） 生成成员变量_var（早期版本编译器不生成） @synthsize var = _var 生成var的set、get方法的实现 生成var对应的成员变量_var mrc年代的get、set方法的写法 1234567891011- (void)setVar:(NSObject *)var &#123; if (_var != var) &#123; // 如果多次set同一个对象，如果不判断会导致对象被释放 // 释放之前的var [_var release]; _var = [var retain]; &#125;&#125;- (NSObject *)var &#123; return _var;&#125;]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tagged Pointer小记]]></title>
    <url>%2F2018%2F07%2F04%2FTagged%20Pointer%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文使用的测试环境是arm64架构真机 为了探究Tagged Pointer本质，可以查看runtime源码，主要看文件objc-internal.h。 宏定义可以看到以下宏定义，只有在64位系统才支持Tagged Pointer。 123#if __LP64__#define OBJC_HAVE_TAGGED_POINTERS 1#endif 64-bit的mac，tag存储在LSB（Least Significant Bit 最低位）。其它情况比如64位的真机和模拟器，tag存储在MSB（Most Significant Bit 最高位）。 12345678910111213141516171819202122232425262728293031#if TARGET_OS_OSX &amp;&amp; __x86_64__ // 64-bit Mac - tag bit is LSB# define OBJC_MSB_TAGGED_POINTERS 0#else // Everything else - tag bit is MSB# define OBJC_MSB_TAGGED_POINTERS 1#endif#if OBJC_MSB_TAGGED_POINTERS# define _OBJC_TAG_MASK (1UL&lt;&lt;63)# define _OBJC_TAG_INDEX_SHIFT 60# define _OBJC_TAG_SLOT_SHIFT 60# define _OBJC_TAG_PAYLOAD_LSHIFT 4# define _OBJC_TAG_PAYLOAD_RSHIFT 4# define _OBJC_TAG_EXT_MASK (0xfUL&lt;&lt;60)# define _OBJC_TAG_EXT_INDEX_SHIFT 52# define _OBJC_TAG_EXT_SLOT_SHIFT 52# define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 12# define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12#else# define _OBJC_TAG_MASK 1UL# define _OBJC_TAG_INDEX_SHIFT 1# define _OBJC_TAG_SLOT_SHIFT 0# define _OBJC_TAG_PAYLOAD_LSHIFT 0# define _OBJC_TAG_PAYLOAD_RSHIFT 4# define _OBJC_TAG_EXT_MASK 0xfUL# define _OBJC_TAG_EXT_INDEX_SHIFT 4# define _OBJC_TAG_EXT_SLOT_SHIFT 4# define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 0# define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12#endif 接下来是一个枚举定义，定义了默认的使用Tagged Pointer的类。例如NSString、NSNumber、NSIndexPath、NSDate（OBJC_TAG_NSAtom、OBJC_TAG_1、OBJC_TAG_NSManagedObjectID不知道是啥意思，还请知道的同学告诉我）。 12345678910111213141516171819enum objc_tag_index_t : uint16_tenum&#123; OBJC_TAG_NSAtom = 0, OBJC_TAG_1 = 1, OBJC_TAG_NSString = 2, OBJC_TAG_NSNumber = 3, OBJC_TAG_NSIndexPath = 4, OBJC_TAG_NSManagedObjectID = 5, OBJC_TAG_NSDate = 6, OBJC_TAG_RESERVED_7 = 7, OBJC_TAG_First60BitPayload = 0, OBJC_TAG_Last60BitPayload = 6, OBJC_TAG_First52BitPayload = 8, OBJC_TAG_Last52BitPayload = 263, OBJC_TAG_RESERVED_264 = 264&#125;; 方法定义判断是不是Tagged Pointer 12345static inline bool_objc_isTaggedPointer(const void * _Nullable ptr) &#123; return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;&#125; 生成一个Tagged Pointer，最高的4位是tagged，剩下的是数据 123456789101112131415static inline void * _Nonnull_objc_makeTaggedPointer(objc_tag_index_t tag, uintptr_t value)&#123; if (tag &lt;= OBJC_TAG_Last60BitPayload) &#123; return (void *) (_OBJC_TAG_MASK | ((uintptr_t)tag &lt;&lt; _OBJC_TAG_INDEX_SHIFT) | ((value &lt;&lt; _OBJC_TAG_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_LSHIFT)); &#125; else &#123; return (void *) (_OBJC_TAG_EXT_MASK | ((uintptr_t)(tag - OBJC_TAG_First52BitPayload) &lt;&lt; _OBJC_TAG_EXT_INDEX_SHIFT) | ((value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT)); &#125;&#125; 从Tagged Pointer中取出值 1234567891011static inline uintptr_t_objc_getTaggedPointerValue(const void * _Nullable ptr) &#123; // assert(_objc_isTaggedPointer(ptr)); uintptr_t basicTag = ((uintptr_t)ptr &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK; if (basicTag == _OBJC_TAG_INDEX_MASK) &#123; return ((uintptr_t)ptr &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT; &#125; else &#123; return ((uintptr_t)ptr &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT; &#125;&#125; NSNumber应用举例可以使用下面代码来验证NSNumber如何使用Tagged Pointer 1234567891011121314NSNumber *charNumber = [NSNumber numberWithChar:'1'];NSNumber *shortNumber = [NSNumber numberWithShort:1];NSNumber *intNumber = [NSNumber numberWithInt:1];NSNumber *floatNumber = [NSNumber numberWithFloat:1.0];NSNumber *longNumber = [NSNumber numberWithLong:1];NSNumber *doubleNumber = [NSNumber numberWithDouble:1.0];// 输出变量的指针地址：// charNumber 0xb000000000000310// shortNumber 0xb000000000000011// intNumber 0xb000000000000012// floatNumber 0xb000000000000014// longNumber 0xb000000000000013// doubleNumber 0xb000000000000015 不难发现规律，都是以b(1011)开头 最高位是1，说明这个指针是一个Tagged Pointer 第61-63位是11（十进制是3），也就是OBJC_TAG_NSNumber（查上面的枚举） 第1-4位是NSNumber的类型：比如，char是0、short是1、int是2、float是4 剩下的56位就是真正的值了 NSString应用举例123456NSString *str1 = [NSString stringWithFormat:@"a"];NSString *str2 = [NSString stringWithFormat:@"ab"];// 输出变量的指针地址：// str1: 0xa000000000000611// str2: 0xa000000000062612 与NSNumber类似 最高位是1，说明这个指针是一个Tagged Pointer 第61-63位是11（十进制是2），也就是OBJC_TAG_NSString 第1-4位是字符串长度 剩下的56位就是真正的值了 更多细节推荐这篇文章采用Tagged Pointer的字符串 参考文章 iOS Tagged Pointer wiki 深入理解Tagged Pointer]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URLWithString return nil]]></title>
    <url>%2F2018%2F07%2F03%2FURLWithString%20return%20nil%2F</url>
    <content type="text"><![CDATA[问题描述在使用URLWithString生成NSURL时，如果出现中文，会导致返回的NSURL为nil。代码如下： 1NSURL *aUrl = [NSURL URLWithString:@&quot;http://中文域名&quot;]; stackoverflow相关讨论 查询了URLWithString的官方文档，其中有一段话解决了我的疑惑。 This method expects URLString to contain only characters that are allowed in a properly formed URL. All other characters must be properly percent escaped. Any percent-escaped characters are interpreted using UTF-8 encoding. 意思就是该方法的输入参数URLString只能包含URL的合法字符，包含非法字符的URL需要进行百分号编码(percent escaped) 百分号编码（percent escaped）wiki相关词条 有两种情况必须使用百分号编码 参数中出现保留字符 URL所允许的字符分作保留与未保留，保留字符是那些具有特殊含义的字符 URL中出现非ASCII字符 对于非ASCII字符, 需要转换为UTF-8字节序，再进行百分号编码 解决方案使用方法stringByAddingPercentEscapesUsingEncoding对URL字符串百分号编码。 12NSString *encodeUrl = [url stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; NSURL *aUrl = [NSURL URLWithString:encodeUrl];]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS消息转发小记]]></title>
    <url>%2F2018%2F05%2F31%2FiOS%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[消息转发流程图 如果类接收到无法处理的消息，会触发消息转发机制，一共有三个步骤，接受者在每一步中均有机会处理消息。步骤越往后，处理消息的代价就越大，所以最好再第一步就处理完。 第一道防线在类里面实现两个方法来处理未知消息。执行动态方法解析之前，先会判断是否曾经有动态解析。 resolveInstanceMethod：处理实例方法 resolveClassMethod：处理类方法 我们来看个Demo，先看调用方代码 123TestA *testA = [[TestA alloc] init];[testA instanceMethod];[TestA classMethod]; 再来看看TestA的定义。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// TestA.h@interface TestA : NSObject- (void)instanceMethod;+ (void)classMethod;@end// TestA.m@implementation TestA- (void)newInstanceMethod &#123; NSLog(@"newInstanceMethod");&#125;+ (void)newClassMethod &#123; NSLog(@"newClassMethod");&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(instanceMethod)) &#123; // 动态添加方法newInstanceMethod Method method = class_getInstanceMethod([self class], @selector(newInstanceMethod)); IMP imp = method_getImplementation(method); class_addMethod([self class], sel, imp, method_getTypeEncoding(method)); // 成功处理，消息转发机制结束，调用newInstanceMethod return YES; &#125; // 不能处理，进入第二步 return [super resolveInstanceMethod:sel];&#125;+ (BOOL)resolveClassMethod:(SEL)sel &#123; if (sel == @selector(classMethod)) &#123; // 动态添加方法newClassMethod Method method = class_getInstanceMethod(object_getClass(self), @selector(newClassMethod)); IMP imp = method_getImplementation(method); class_addMethod(object_getClass(self), sel, imp, method_getTypeEncoding(method)); // 成功处理，消息转发机制结束，调用newClassMethod return YES; &#125; // 不能处理，进入第二步 return [super resolveClassMethod:sel];&#125;@end TestA中头文件定义了两个方法，但是没有实现，如果不用消息转发机制处理异常，会导致crash，log想必大家应该很熟悉 *** Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[TestA funcA]: unrecognized selector sent to instance 0x6040000125c0’ 实例方法存储在类对象，类方法存储在元类对象，在调用class_addMethod时，第一个参数需要注意。 第二道防线第二道防线依赖一个函数forwardingTargetForSelector。 1234567891011121314151617// 类方法//+ (id)forwardingTargetForSelector:(SEL)aSelector &#123;// //&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(instanceMethod)) &#123; // 消息转发给TestB实例 return [TestB new]; &#125; // 消息转发失败，进入下一步 return nil;&#125;// TestB.m- (void)instanceMethod &#123; NSLog(@"instanceMethod");&#125; 第三道防线第三道防线有两步 调用methodSignatureForSelector，获取新的方法签名（返回值类型，参数类型） 调用forwardInvocation，转发消息， 123456789101112131415// 方法签名（返回值类型，参数类型）// 类方法减号改为加号- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; NSMethodSignature *signature = [TestB instanceMethodSignatureForSelector:aSelector]; return signature;&#125;// NSInvocation封装了方法调用，包括：方法调用者、方法名、方法参数// anInvocation.target 消息接受者// anInvocation.selector 函数名// [anInvocation getArgument:NULL atIndex:0]; 获取参数// 类方法减号改为加号- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; [anInvocation invokeWithTarget:[TestB new]];&#125;]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探寻Objective-C引用计数本质]]></title>
    <url>%2F2018%2F05%2F26%2F%E6%8E%A2%E5%AF%BBObjective-C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[本文涉及到的CPU架构为arm64，其它架构大同小异。源码来自苹果开源-runtime。 Objective-C中采用引用计数机制来管理内存，在MRC时代，需要我们手动retain和release，在苹果引入ARC后大部分时间我们不用再关心引用计数问题。但是为了深入Objective-C本质，引用计数究竟是怎么实现的还是值得我们去探寻的。 ISAOC中的对象的实质其实是结构体，其中大部分对象都有isa，指向类对象（有一种神奇的存在叫做Tagged Pointer），源码中关于对象结构体objc_object定义如下： 123456789// objc-private.hstruct objc_object &#123;private: isa_t isa;public: id retain(); void release(); id autorelease(); ... //省略了其它方法，感兴趣可以直接看源码 Tagged Pointer除了有一种特殊的对象Tagged Pointer，这种类型的对象值就存在指针当中，存取性能高。可以用来存储少量数据的对象，例如NSNumber、NSDate、NSString。(更多Tagged Pointer知识，具体看这篇Tagged Pointer小记)。也就没有引用计数、内存释放的问题。 NONPOINTER ISAarm64架构isa占64位，苹果为了优化性能，存储类对象地址只用了33位，剩下的位用来存储一些其它信息，比如本文讨论的引用计数。 NONPOINTER ISA存储的字段定义如下： 1234567891011121314151617# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL struct &#123; uintptr_t nonpointer : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19;# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) &#125;; extra_rc那引用计数存在哪里呢？秘密就在extra_rc中。 extra_rc只是存储了额外的引用计数，实际的引用计数计算公式：引用计数=extra_rc+1。 extra_rc占了19位，可以存储的最大引用计数：$2^{19}-1+1=524288$，超过它就需要进位到SideTables。SideTables是一个Hash表，根据对象地址可以找到对应的SideTable，SideTable内包含一个RefcountMap，根据对象地址取出其引用计数，类型是size_t。它是一个unsigned long，最低两位是标志位，剩下的62位用来存储引用计数。我们可以计算出引用计数的理论最大值：$2^{62+19}=2.417851639229258e24$。 其实isa能存储的524288在日常开发已经完全够用了，为什么还要搞个Side Table？我猜测是因为历史问题，以前cpu是32位的，isa中能存储的引用计数就只有$2^{7}=128$。因此在arm64下，引用计数通常是存储在isa中的。 retain有了前面的铺垫，我们知道引用计数怎么存储的了，那引用计数又是怎么改变的呢？通过剖析retain源码我们就可以得出结论了。objc_object的方法全部定义在objc-object.h文件中，全是内联函数，应该是为了性能的考虑。 我们来看看retain的函数定义 1234567891011inline id objc_object::retain()&#123; assert(!isTaggedPointer()); if (fastpath(!ISA()-&gt;hasCustomRR())) &#123; return rootRetain(); &#125; return ((id(*)(objc_object *, SEL))objc_msgSend)(this, SEL_retain);&#125; 这层比较简单，做了三件事情： 判断指针是不是Tagged Pointer 判断是否有自定义retain，如果有调用自定义的。 最后调用rootRetain 我们来看看关键函数rootRetain的实现（为了便于阅读，代码有所删减） 1234567891011121314151617181920212223242526272829303132333435ALWAYS_INLINE id objc_object::rootRetain(bool tryRetain, bool handleOverflow)&#123; isa_t oldisa; isa_t newisa; // 加锁，用汇编指令ldxr来保证原子性 oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; if (newisa.nonpointer = 0) &#123; // newisa.nonpointer = 0说明所有位数都是地址值 // 释放锁，使用汇编指令clrex ClearExclusive(&amp;isa.bits); // 由于所有位数都是地址值，直接使用sidetable来存储引用计数 return sidetable_retain(); &#125; // 存储extra_rc++后的结果 uintptr_t carry; // extra_rc++ newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry); if (carry == 0) &#123; // extra_rc++后溢出，进位到side table newisa.extra_rc = RC_HALF; newisa.has_sidetable_rc = true; sidetable_addExtraRC_nolock(RC_HALF); &#125; // 将newisa写入isa StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits) return (id)this;&#125; 有一个细节可以了解下，如何用汇编来实现原子性操作。 1234567891011static ALWAYS_INLINEuintptr_t LoadExclusive(uintptr_t *src)&#123; uintptr_t result; // 在多核CPU下，对一个地址的访问可能引起冲突，ldxr解决了冲突，保证原子性。 asm("ldxr %x0, [%x1]" : "=r" (result) : "r" (src), "m" (*src)); return result;&#125; releaserelease代码逻辑基本上就是retain反过来走一遍，有点不同的是在引用计数减到0时，会调用对象的dealloc方法。 1234567891011121314151617181920212223242526272829303132333435363738394041ALWAYS_INLINE boolobjc_object::rootRelease(bool performDealloc, bool handleUnderflow)&#123; isa_t oldisa; isa_t newisa; retry: oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; if (newisa.nonpointer == 0) &#123; ClearExclusive(&amp;isa.bits); if (sideTableLocked) sidetable_unlock(); return sidetable_release(performDealloc); &#125; uintptr_t carry; // extra_rc-- newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry); if (carry == 0) &#123; // 需要从SideTable借位，或者引用计数为0 goto underflow; &#125; // 存储引用计数到isa StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits) return false; underflow: // 从SideTable借位 // 或引用计数为0，调用delloc // 此处省略N多代码 // 总结一下:修改Side Table与extra_rc， // 引用计数减为0时，调用dealloc if (performDealloc) &#123; ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc); &#125; return true;&#125; 小结 引用计数存在哪？ Tagged Pointer不需要引用计数 NONPOINTER ISA(isa的第一位为1)的引用计数优先存在isa中，大于524288了进位到Side Tables 非NONPOINTER ISA引用计数存在Side Tables retain/release的实质 找到引用计数存储区域，然后+1/-1 如果是NONPOINTER ISA，还要处理进位/借位的情况 release在引用计数减为0时，调用dealloc 参考 黑箱中的 retain 和 release 深入理解Tagged Pointer]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova源码解析（二）- 自定义UserAgent]]></title>
    <url>%2F2018%2F05%2F15%2FCordova%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-%20%E8%87%AA%E5%AE%9A%E4%B9%89UserAgent%2F</url>
    <content type="text"><![CDATA[本文分析的源码是基于Cordova 4.2.1版本，Cordova官网。 Cordova源码解析（二）- 自定义UserAgentUIWebView没有提供设置UserAgent的接口，但是有一个办法可以间接的设置。 12NSDictionary* dict = [[NSDictionary alloc] initWithObjectsAndKeys:value, @&quot;UserAgent&quot;, nil];[[NSUserDefaults standardUserDefaults] registerDefaults:dict]; 通过设置NSUserDefaults中UserAgent的值来修改，但是这种设置方法有一个限制，需要在UIWebView的loadRequest之前调用才能生效(加载PDF比较特殊)。这是Cordova源码中关于这个问题的描述 Setting the UserAgent must occur before a UIWebView is instantiated.It is read per instantiation, so it does not affect previously created views.Except! When a PDF is loaded, all currently active UIWebViews reload theirUser-Agent from the NSUserDefaults some time after the DidFinishLoad of the PDF bah! CDVUserAgentUtil在多WebView的情况下，如果每个WebView都有不同的UserAgent，就会产生数据竞争的问题，大家都要修改NSUserDefaults中UserAgent的值，于是需要对资源加锁来保证每个WebView都设置预期的UserAgent。在Cordova中，专门有一个类CDVUserAgentUtil来实现这个功能。 CDVUserAgentUtil.h文件中定义了四个方法 12345678// 获取UIWebView默认的UserAgent+ (NSString*)originalUserAgent;// 获取锁+ (void)acquireLock:(void (^)(NSInteger lockToken))block;// 释放锁+ (void)releaseLock:(NSInteger*)lockToken;// 设置UIWebView的UserAgent+ (void)setUserAgent:(NSString*)value lockToken:(NSInteger)lockToken; 加锁每次加锁成功会返回一个NSInteger类型的token，在释放锁的时候需要把token传入。token会不断递增，保证每次加锁返回的token都不回重复。加锁的实现代码如下： 123456789101112131415// CDVUserAgentUtil.m+ (void)acquireLock:(void (^)(NSInteger lockToken))block&#123; if (gCurrentLockToken == 0) &#123; gCurrentLockToken = ++gNextLockToken; VerboseLog(@"Gave lock %d", gCurrentLockToken); block(gCurrentLockToken); &#125; else &#123; if (gPendingSetUserAgentBlocks == nil) &#123; gPendingSetUserAgentBlocks = [[NSMutableArray alloc] initWithCapacity:4]; &#125; VerboseLog(@"Waiting for lock"); [gPendingSetUserAgentBlocks addObject:block]; &#125;&#125; 调用acquireLock:，首先会判断gCurrentLockToken是否等于0 如果是0说明没有模块正在修改UserAgent，能够成功获取到锁，gCurrentLockToken递增，标致当前有模块正在修改UserAgent，并回调block，返回gCurrentLockToken 如果不为0说明当前有模块正在修改UserAgent，将block回调存在一个队列gPendingSetUserAgentBlocks中 释放锁释放锁需要传入token，释放锁代码如下： 12345678910111213141516171819+ (void)releaseLock:(NSInteger*)lockToken&#123; if (*lockToken == 0) &#123; return; &#125; NSAssert(gCurrentLockToken == *lockToken, @"Got token %ld, expected %ld", (long)*lockToken, (long)gCurrentLockToken); VerboseLog(@"Released lock %d", *lockToken); if ([gPendingSetUserAgentBlocks count] &gt; 0) &#123; void (^block)() = [gPendingSetUserAgentBlocks objectAtIndex:0]; [gPendingSetUserAgentBlocks removeObjectAtIndex:0]; gCurrentLockToken = ++gNextLockToken; NSLog(@"Gave lock %ld", (long)gCurrentLockToken); block(gCurrentLockToken); &#125; else &#123; gCurrentLockToken = 0; &#125; *lockToken = 0;&#125; 如果要释放的lockToken为0，说明还没加过锁，就调用释放了，直接返回 从队列gPendingSetUserAgentBlocks中取出最早加入的block，从队列中移除 gCurrentLockToken递增生成新token，回调block 如果队列gPendingSetUserAgentBlocks释放完成，说明释放锁的调用次数&gt;加锁的次数，不做操作，然后把gCurrentLockToken置为0 设置UserAgent在Cordova实际运用中，操作锁的时机：加锁时机：CDVViewController加载完毕，在viewDidLoad里调用释放锁时机： UIWebView的webViewDidFinishLoad:回调 UIWebView的webView:didFailLoadWithError:回调 CDVViewController的dealloc CDVViewController的viewDidUnload 加锁代码，省略了不相关代码 12345678910// CDVViewController.m- (void)viewDidLoad&#123; [CDVUserAgentUtil acquireLock:^(NSInteger lockToken) &#123; _userAgentLockToken = lockToken; [CDVUserAgentUtil setUserAgent:self.userAgent lockToken:lockToken]; NSURLRequest* appReq = [NSURLRequest requestWithURL:appURL cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:20.0]; [self.webViewEngine loadRequest:appReq]; &#125;];&#125; 释放锁代码，这里只看正常逻辑，在网页加载完成回调webViewDidFinishLoad:中释放逻辑。不考虑异常情况，省略了不相关代码。 123456789// CDVUIWebViewNavigationDelegate.m- (void)webViewDidFinishLoad:(UIWebView*)theWebView&#123; NSLog(@"Finished load of: %@", theWebView.request.URL); CDVViewController* vc = (CDVViewController*)self.enginePlugin.viewController; // It's safe to release the lock even if this is just a sub-frame that's finished loading. [CDVUserAgentUtil releaseLock:vc.userAgentLockToken];&#125; 在webViewDidFinishLoad:回调时，UserAgent已经设置成功，所以可以释放锁，让其它WebView操作UserDefault了。]]></content>
      <tags>
        <tag>源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova源码解析]]></title>
    <url>%2F2018%2F05%2F09%2FCordova%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[本文设计到的源码是基于Cordova 4.2.1版本，Cordova官网。 CDVViewControllerCDVViewController是Cordova最主要的类，它把所有模块整合在一起，直接初始化一个它的实例就可以使用。例如下面的代码： 123CDVViewController *vc = [[CDVViewController alloc] init];vc.startPage = @"www.baidu.com";[self presentViewController:vc animated:YES completion:nil]; CDVViewController主要实现的功能： 注册、初始化插件 读取、应用配置文件 初始化并配置WebView，设置其代理 管理js与原生的方法调用 管理应用与网页的生命周期。。。 它主要的属性有： CDVWebViewEngineProtocol：webview相关的回调 CDVCommandDelegate：js与原生插件交互方法，插件初始化 CDVCommandQueue：命令执行队列 CDVCommandDelegate和CDVCommandQueue会在js调用原生插件与插件初始化提到，这里先不细说。CDVWebViewEngineProtocol定义了WebView引擎的抽象类，具体实现由插件提供，例如CDVUIWebViewEngine实现UIWebView的引擎。 CDVWebViewEngineProtocol协议定义CDVWebViewEngineProtocol协议其实是对于WebView的一层封装，屏蔽了不同WebView接口的差异，现在iOS有UIWebView与WKWebView。 1234567891011@protocol CDVWebViewEngineProtocol &lt;NSObject&gt;@property (nonatomic, strong, readonly) UIView* engineWebView;- (id)loadRequest:(NSURLRequest*)request;- (id)loadHTMLString:(NSString*)string baseURL:(NSURL*)baseURL;- (void)evaluateJavaScript:(NSString*)javaScriptString completionHandler:(void (^)(id, NSError*))completionHandler;- (NSURL*)URL;- (BOOL)canLoadRequest:(NSURLRequest*)request;- (instancetype)initWithFrame:(CGRect)frame;- (void)updateWithInfo:(NSDictionary*)info;@end engineWebView属性对外直接暴露了内部封装的WebView，其它方法都是对WebView方法的一层简单封装。 UIWebView引擎CDVUIWebViewEngine我们以UIWebView的实现CDVUIWebViewEngine为例说明，它是以插件的形式实现的，主要作用是初始化UIWebView的配置，对UIWebView的方法和代理进行了一层封装。它实现了协议CDVWebViewEngineProtocol，主要有以下几个属性。 123456// CDVUIWebViewEngine// UIWebview@property (nonatomic, strong, readwrite) UIView* engineWebView;// UIWebView的代理@property (nonatomic, strong, readwrite) id &lt;UIWebViewDelegate&gt; uiWebViewDelegate;@property (nonatomic, strong, readwrite) CDVUIWebViewNavigationDelegate* navWebViewDelegate; 初始化从initWithFrame:方法开始，它创建了一个UIWebView，并赋值给了engineWebView，然后在插件初始化方法pluginInitialize中初始化UIWebView的代理和配置。 123456789101112131415161718192021- (void)pluginInitialize&#123; UIWebView* uiWebView = (UIWebView*)_engineWebView; // 判断当前controller是否实现了UIWebViewDelegate // 如果实现了就把当前controller设置为CDVUIWebViewDelegate的代理实现 if ([self.viewController conformsToProtocol:@protocol(UIWebViewDelegate)]) &#123; self.uiWebViewDelegate = [[CDVUIWebViewDelegate alloc] initWithDelegate:(id &lt;UIWebViewDelegate&gt;)self.viewController]; uiWebView.delegate = self.uiWebViewDelegate; &#125; // 如果没有实现，创建一个CDVUIWebViewNavigationDelegate，作为CDVUIWebViewDelegate的代理实现 else &#123; self.navWebViewDelegate = [[CDVUIWebViewNavigationDelegate alloc] initWithEnginePlugin:self]; self.uiWebViewDelegate = [[CDVUIWebViewDelegate alloc] initWithDelegate:self.navWebViewDelegate]; uiWebView.delegate = self.uiWebViewDelegate; &#125; // 初始化配置信息 // self.commandDelegate.settings是CDVViewController的配置信息，定义在config.xml [self updateSettings:self.commandDelegate.settings];&#125; js调用原生插件解析插件调用流程： js发起请求gap:// 实现WebView的代理webView:shouldStartLoadWithRequest:navigationType:，拦截scheme为gap的请求 执行js方法cordova.require(&#39;cordova/exec&#39;).nativeFetchMessages()获取需要执行的原生插件的信息（插件名，插件方法，回调ID，参数） 将需要执行的原生插件信息放入命令队列等待执行 执行原生插件，并把结果回调给js 插件调用堆栈如图所示： js请求拦截CDVUIWebViewDelegate实现了UIWebView的webView:shouldStartLoadWithRequest:navigationType:代理，在页面加载前做一些处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364- (BOOL)webView:(UIWebView*)webView shouldStartLoadWithRequest:(NSURLRequest*)request navigationType:(UIWebViewNavigationType)navigationType&#123; BOOL shouldLoad = YES; // 1. 判断如果有代理，先调用代理方法 // 这里的_delegate是CDVUIWebViewNavigationDelegate if ([_delegate respondsToSelector:@selector(webView:shouldStartLoadWithRequest:navigationType:)]) &#123; shouldLoad = [_delegate webView:webView shouldStartLoadWithRequest:request navigationType:navigationType]; &#125; if (shouldLoad) &#123; // 是否是调试工具refresh BOOL isDevToolsRefresh = (request == webView.request); // 是否是顶层页面 BOOL isTopLevelNavigation = isDevToolsRefresh || [request.URL isEqual:[request mainDocumentURL]]; if (isTopLevelNavigation) &#123; if ([self request:request isEqualToRequestAfterStrippingFragments:webView.request]) &#123; NSString* prevURL = [self evalForCurrentURL:webView]; if ([prevURL isEqualToString:[request.URL absoluteString]]) &#123; VerboseLog(@"Page reload detected."); &#125; else &#123; VerboseLog(@"Detected hash change shouldLoad"); return shouldLoad; &#125; &#125; switch (_state) &#123; case STATE_WAITING_FOR_LOAD_FINISH: // 重定向情况，判断loadCount是否是1 if (_loadCount != 1) &#123; NSLog(@"CDVWebViewDelegate: Detected redirect when loadCount=%ld", (long)_loadCount); &#125; break; case STATE_IDLE: case STATE_IOS5_POLLING_FOR_LOAD_START: case STATE_CANCELLED: // 页面导航开始 _loadCount = 0; _state = STATE_WAITING_FOR_LOAD_START; break; default: &#123; // 其它情况，回调webView:didFailLoadWithError: NSString* description = [NSString stringWithFormat:@"CDVWebViewDelegate: Navigation started when state=%ld", (long)_state]; NSLog(@"%@", description); _loadCount = 0; _state = STATE_WAITING_FOR_LOAD_START; if ([_delegate respondsToSelector:@selector(webView:didFailLoadWithError:)]) &#123; NSDictionary* errorDictionary = @&#123;NSLocalizedDescriptionKey : description&#125;; NSError* error = [[NSError alloc] initWithDomain:@"CDVUIWebViewDelegate" code:1 userInfo:errorDictionary]; [_delegate webView:webView didFailLoadWithError:error]; &#125; &#125; &#125; &#125; else &#123; // 屏蔽一些无效网站的访问 shouldLoad = shouldLoad &amp;&amp; [self shouldLoadRequest:request]; &#125; &#125; return shouldLoad;&#125; 拦截js调用原生插件请求的关键代码在CDVUIWebViewNavigationDelegate，它实现了CDVUIWebViewDelegate的代理，在CDVUIWebViewDelegate会把请求转发给它。 12345678910111213141516171819202122232425262728293031323334353637383940414243- (BOOL)webView:(UIWebView*)theWebView shouldStartLoadWithRequest:(NSURLRequest*)request navigationType:(UIWebViewNavigationType)navigationType&#123; NSURL* url = [request URL]; CDVViewController* vc = (CDVViewController*)self.enginePlugin.viewController; // H5调用原生插件，后面分析 if ([[url scheme] isEqualToString:@"gap"]) &#123; [vc.commandQueue fetchCommandsFromJs]; [vc.commandQueue executePending]; return NO; &#125; // 给插件预留了一个处理URL的方法，调用插件的方法`shouldOverrideLoadWithRequest:navigationType:`，获取返回值 // 应用：系统默认插件CDVIntentAndNavigationFilter中，实现了Intent与Navigation的白名单机制。 BOOL anyPluginsResponded = NO; BOOL shouldAllowRequest = NO; for (NSString* pluginName in vc.pluginObjects) &#123; CDVPlugin* plugin = [vc.pluginObjects objectForKey:pluginName]; SEL selector = NSSelectorFromString(@"shouldOverrideLoadWithRequest:navigationType:"); if ([plugin respondsToSelector:selector]) &#123; anyPluginsResponded = YES; shouldAllowRequest = (((BOOL (*)(id, SEL, id, int))objc_msgSend)(plugin, selector, request, navigationType)); if (!shouldAllowRequest) &#123; break; &#125; &#125; &#125; if (anyPluginsResponded) &#123; return shouldAllowRequest; &#125; // 处理其它类型的url,file:类型直接返回YES BOOL shouldAllowNavigation = [self defaultResourcePolicyForURL:url]; if (shouldAllowNavigation) &#123; return YES; &#125; else &#123; [[NSNotificationCenter defaultCenter] postNotification:[NSNotification notificationWithName:CDVPluginHandleOpenURLNotification object:url]]; &#125; return NO;&#125; H5调用原生插件Cordova调用原生插件的方式是通过拦截gap://的URL，然后执行js代码cordova.require(&#39;cordova/exec&#39;).nativeFetchMessages()获取参数，来实现调用。 我们来看关键代码： 1234567891011// CDVUIWebViewNavigationDelegate.m- (BOOL)webView:(UIWebView*)theWebView shouldStartLoadWithRequest:(NSURLRequest*)request navigationType:(UIWebViewNavigationType)navigationType&#123; CDVViewController* vc = (CDVViewController*)self.enginePlugin.viewController; if ([[url scheme] isEqualToString:@"gap"]) &#123; [vc.commandQueue fetchCommandsFromJs]; [vc.commandQueue executePending]; return NO; &#125;&#125; 12345678910111213141516- (void)fetchCommandsFromJs&#123; __weak CDVCommandQueue* weakSelf = self; NSString* js = @"cordova.require('cordova/exec').nativeFetchMessages()"; [_viewController.webViewEngine evaluateJavaScript:js completionHandler:^(id obj, NSError* error) &#123; if ((error == nil) &amp;&amp; [obj isKindOfClass:[NSString class]]) &#123; NSString* queuedCommandsJSON = (NSString*)obj; // 调用的插件信息加入到queue中 [weakSelf enqueueCommandBatch:queuedCommandsJSON]; // 调用执行方法 [self executePending]; &#125; &#125;];&#125; 调用js方法cordova.require(&#39;cordova/exec&#39;).nativeFetchMessages()，获取调用的插件信息。 12// 插件信息示例[["DevicePlugin1678563772","DevicePlugin","getDeviceInfo",[]]] 命令队列CDVCommandQueuejs的每次调用信息会封装被封装为一个命令CDVInvokedUrlCommand，CDVInvokedUrlCommand继承自NSObject，主要存储了下面的信息： 123456789// CDVInvokedUrlCommand// 参数@property (nonatomic, readonly) NSArray* arguments;// 回调ID@property (nonatomic, readonly) NSString* callbackId;// 类名@property (nonatomic, readonly) NSString* className;// 方法名@property (nonatomic, readonly) NSString* methodName; CDVCommandQueue管理着所有的命令，实现了一个命令的队列。在js调用原生插件时，会调用CDVCommandQueue的enqueueCommandBatch:方法，将插件调用信息加到commandBatchHolder数组中，最后commandBatchHolder数组添加到CDVCommandQueue的queue。 123456789101112131415161718- (void)enqueueCommandBatch:(NSString*)batchJSON&#123; if ([batchJSON length] &gt; 0) &#123; NSMutableArray* commandBatchHolder = [[NSMutableArray alloc] init]; [_queue addObject:commandBatchHolder]; if ([batchJSON length] &lt; JSON_SIZE_FOR_MAIN_THREAD) &#123; [commandBatchHolder addObject:[batchJSON cdv_JSONObject]]; &#125; else &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^() &#123; NSMutableArray* result = [batchJSON cdv_JSONObject]; @synchronized(commandBatchHolder) &#123; [commandBatchHolder addObject:result]; &#125; [self performSelectorOnMainThread:@selector(executePending) withObject:nil waitUntilDone:NO]; &#125;); &#125; &#125;&#125; 插件的执行由CDVCommandQueue管理，每个CDVViewController有自己的队列，有两个重要的成员变量。 1234/* 二维数组，存储着所有插件调用的json */NSMutableArray* _queue;/* 记录开始调用的时间 */NSTimeInterval _startExecutionTime; executePending负责执行命令队列中待执行的插件，具体实现就是遍历执行二维数组queue。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)executePending&#123; // 如果已经开始执行了，返回 if (_startExecutionTime &gt; 0) &#123; return; &#125; @try &#123; // 记录开始执行的时间 _startExecutionTime = [NSDate timeIntervalSinceReferenceDate]; // 遍历_queue while ([_queue count] &gt; 0) &#123; NSMutableArray* commandBatchHolder = _queue[0]; NSMutableArray* commandBatch = nil; @synchronized(commandBatchHolder) &#123; if ([commandBatchHolder count] == 0) &#123; break; &#125; commandBatch = commandBatchHolder[0]; &#125; // 遍历commandBatch while ([commandBatch count] &gt; 0) &#123; @autoreleasepool &#123; // 取出commandBatch的第一条数据，并移除 NSArray* jsonEntry = [commandBatch cdv_dequeue]; if ([commandBatch count] == 0) &#123; [_queue removeObjectAtIndex:0]; &#125; // 用插件调用json信息，创建CDVInvokedUrlCommand CDVInvokedUrlCommand* command = [CDVInvokedUrlCommand commandFromJson:jsonEntry]; // 调用插件 [self execute:command]); &#125; // 对于性能的一个优化，后面会详细说 if (([_queue count] &gt; 0) &amp;&amp; ([NSDate timeIntervalSinceReferenceDate] - _startExecutionTime &gt; MAX_EXECUTION_TIME)) &#123; [self performSelector:@selector(executePending) withObject:nil afterDelay:0]; return; &#125; &#125; &#125; &#125; @finally &#123; _startExecutionTime = 0; &#125;&#125; 用Runloop优化性能Cordova对于插件的执行进行了优化，保证页面的流程度，运用了RunLoop，巧妙的将代码分割为多块分次执行，避免由于插件执行导致主线程阻塞，影响页面绘制，导致掉帧。具体代码如下： 1234567891011// CDVCommandQueue.m// MAX_EXECUTION_TIME ≈ 1s / 60 / 2// 计算出绘制一帧时间的一半static const double MAX_EXECUTION_TIME = .008;// 判断本次执行时间，如果大于MAX_EXECUTION_TIME，调用performSelector:withObject:afterDelay，结束本次调用if (([_queue count] &gt; 0) &amp;&amp; ([NSDate timeIntervalSinceReferenceDate] - _startExecutionTime &gt; MAX_EXECUTION_TIME)) &#123; [self performSelector:@selector(executePending) withObject:nil afterDelay:0]; return;&#125; 优化策略分析： 将队列中的插件分割为很多小块来执行 开始执行executePending方法时，记录开始时间，每次执行完一个插件方法后，判断本次执行时间是否超过MAX_EXECUTION_TIME，如果没有超过，继续执行，如果超过了MAX_EXECUTION_TIME，调用performSelector:withObject:afterDelay，结束本次调用 如果要保证UI流畅，需要满足条件CPU时间 + GPU时间 &lt;= 1s/60， 为了给GPU留下足够的时间渲染，要尽量让CPU占用时间小于1s/60/2 Runloop执行的流程如下图所示，系统在收到kCFRunLoopBeforeWaiting（线程即将休眠）通知时，会触发一次界面的渲染，也就是在完成source0的处理后 source0在这里就是插件的执行代码，在kCFRunLoopBeforeWaiting通知之前，如果source0执行时间过长就会导致界面没有得到及时的刷新。 函数performSelector:withObject:afterDelay，会将方法注册到Timer，结束source0调用，开始渲染界面。界面渲染完成后，Runloop开始sleep，然后被timer唤醒又开始继续处理source0。 插件方法执行方法最终的执行在方法execute:中，从command中取出要执行的插件类、方法、参数，然后执行方法。 123456789101112131415161718192021222324- (BOOL)execute:(CDVInvokedUrlCommand*)command&#123; // 获取插件实例 CDVPlugin* obj = [_viewController.commandDelegate getCommandInstance:command.className]; BOOL retVal = YES; double started = [[NSDate date] timeIntervalSince1970] * 1000.0; NSString* methodName = [NSString stringWithFormat:@"%@:", command.methodName]; SEL normalSelector = NSSelectorFromString(methodName); if ([obj respondsToSelector:normalSelector]) &#123; ((void (*)(id, SEL, id))objc_msgSend)(obj, normalSelector, command); &#125; else &#123; // There's no method to call, so throw an error. NSLog(@"ERROR: Method '%@' not defined in Plugin '%@'", methodName, command.className); retVal = NO; &#125; double elapsed = [[NSDate date] timeIntervalSince1970] * 1000.0 - started; // 监控插件方法执行时间，打印出大于10ms的方法 if (elapsed &gt; 10) &#123; NSLog(@"THREAD WARNING: ['%@'] took '%f' ms. Plugin should use a background thread.", command.className, elapsed); &#125; return retVal;&#125; 原生回调js原生方法执行完成后，会把结果返回给js，调用方法sendPluginResult:callbackId:，用CDVPluginResult来传递回调参数，用callbackId来区分是哪次调用（callbackId由js产生）。 12345678910111213141516171819// CDVCommandDelegateImpl.m- (void)sendPluginResult:(CDVPluginResult*)result callbackId:(NSString*)callbackId&#123; // 判断callbackId长度是否小于100 // 用正则表达式"[^A-Za-z0-9._-]"来验证callbackId if (![self isValidCallbackId:callbackId]) &#123; return; &#125; // 状态码 int status = [result.status intValue]; // 是否持续回调 BOOL keepCallback = [result.keepCallback boolValue]; // 会带哦参数 NSString* argumentsAsJSON = [result argumentsAsJSON]; // 执行js方法，回调 NSString* js = [NSString stringWithFormat:@"cordova.require('cordova/exec').nativeCallback('%@',%d,%@,%d, %d)", callbackId, status, argumentsAsJSON, keepCallback, debug]; [self evalJsHelper:js];&#125; CDVPlugin注册与初始化我们先看看配置文件中插件的定义： 1234567&lt;!-- 定义插件名为HandleOpenUrl的插件 --&gt;&lt;feature name="HandleOpenUrl"&gt; &lt;!-- 对应的iOS类名是CDVHandleOpenURL --&gt; &lt;param name="ios-package" value="CDVHandleOpenURL" /&gt; &lt;!-- 需要默认加载的插件 --&gt; &lt;param name="onload" value="true" /&gt;&lt;/feature&gt; 加载默认插件在CDVViewController的viewDidLoad时，从Cordova的配置文件config.xml中，读取出需要默认加载的插件，遍历初始化。 CDVViewController中初始化默认插件代码。 1234567891011121314151617- (void)viewDidLoad &#123; // Load settings [self loadSettings]; if ([self.startupPluginNames count] &gt; 0) &#123; [CDVTimer start:@"TotalPluginStartup"]; for (NSString* pluginName in self.startupPluginNames) &#123; [CDVTimer start:pluginName]; // 初始化插件 [self getCommandInstance:pluginName]; [CDVTimer stop:pluginName]; &#125; [CDVTimer stop:@"TotalPluginStartup"]; &#125;&#125; 插件初始化插件初始化的过程： 加载配置文件config.xml 根据插件名获取对应类名 根据类名从缓存中查找，如果命中直接返回 没有缓存重新创建一个实例，并写入缓存 插件初始化的入口是getCommandInstance，传入参数是插件名称，返回一个插件的实例对象。 12345678910111213141516171819202122232425- (id)getCommandInstance:(NSString*)pluginName&#123; // 在pluginsMap中用插件名称获取类名（插件名不区分大小写） NSString* className = [self.pluginsMap objectForKey:[pluginName lowercaseString]]; // 没有配置插件，初始化失败 if (className == nil) &#123; return nil; &#125; // 从缓存中获取，如果命中直接返回缓存 id obj = [self.pluginObjects objectForKey:className]; if (!obj) &#123; // 没有缓存，创建一个新的实例 obj = [[NSClassFromString(className)alloc] initWithWebViewEngine:_webViewEngine]; if (obj != nil) &#123; // 实例创建成功，注册插件 [self registerPlugin:obj withClassName:className]; &#125; else &#123; NSLog(@"CDVPlugin class %@ (pluginName: %@) does not exist.", className, pluginName); &#125; &#125; return obj;&#125; 注册插件的关键方法registerPlugin:withClassName: 1234567891011121314- (void)registerPlugin:(CDVPlugin*)plugin withClassName:(NSString*)className&#123; if ([plugin respondsToSelector:@selector(setViewController:)]) &#123; [plugin setViewController:self]; &#125; if ([plugin respondsToSelector:@selector(setCommandDelegate:)]) &#123; [plugin setCommandDelegate:_commandDelegate]; &#125; // 写入缓存 [self.pluginObjects setObject:plugin forKey:className]; [plugin pluginInitialize];&#125; Cordova还提供了插件名注册插件的方式，使用函数registerPlugin:withPluginName:，实现方式差不多，就不赘述了。 注册插件步骤 设置插件的viewController和delegate 将插件以className为key放入pluginObjects中，pluginObjects是一个插件的缓存 调用插件的pluginInitialize 插件销毁插件销毁的时机是创建插件的CDVViewController释放的时候，因为插件实例被创建后被缓存map引用，对应的销毁代码。 12345678910111213141516// CDVViewController.m- (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self]; [CDVUserAgentUtil releaseLock:&amp;_userAgentLockToken]; [_commandQueue dispose]; [[self.pluginObjects allValues] makeObjectsPerformSelector:@selector(dispose)];&#125;// CDVPlugin.m- (void)dispose&#123; viewController = nil; commandDelegate = nil;&#125; 小结 在config.xml文件中配置插件，声明插件与类的映射关系，以及加载策略 插件的初始化时懒加载，除了onload配置为YES的插件会默认加载，其它插件都是使用时加载 插件使用了两个Map来缓存，pluginObjects建立了类名与插件实例对象的映射，pluginsMap建立了插件名与类名的映射。 在一个CDVViewController中，同一个插件同时只会存在一个实例]]></content>
      <tags>
        <tag>源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析AutoreleasePool源码]]></title>
    <url>%2F2018%2F04%2F14%2F%E6%B5%85%E6%9E%90AutoreleasePool%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[最近在拜读Draveness大佬的一篇文章自动释放池的前世今生 —- 深入解析 autoreleasepool，看到文中给读者留了一个问题： 我到现在也不是很清楚为什么要根据当前页的不同状态 kill 掉不同 child 的页面。 关于AutoreleasePool是什么，强力推荐阅读原文，写的很好。这里就不说了，直接讨论问题。 首先是整个pop方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static inline void pop(void *token) &#123; AutoreleasePoolPage *page; id *stop; if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123; // Popping the top-level placeholder pool. if (hotPage()) &#123; // Pool was used. Pop its contents normally. // Pool pages remain allocated for re-use as usual. pop(coldPage()-&gt;begin()); &#125; else &#123; // Pool was never used. Clear the placeholder. setHotPage(nil); &#125; return; &#125; page = pageForPointer(token); stop = (id *)token; if (*stop != POOL_BOUNDARY) &#123; if (stop == page-&gt;begin() &amp;&amp; !page-&gt;parent) &#123; // Start of coldest page may correctly not be POOL_BOUNDARY: // 1. top-level pool is popped, leaving the cold page in place // 2. an object is autoreleased with no pool &#125; else &#123; // Error. For bincompat purposes this is not // fatal in executables built with old SDKs. return badPop(token); &#125; &#125; if (PrintPoolHiwat) printHiwat(); page-&gt;releaseUntil(stop); // memory: delete empty children if (DebugPoolAllocation &amp;&amp; page-&gt;empty()) &#123; // special case: delete everything during page-per-pool debugging AutoreleasePoolPage *parent = page-&gt;parent; page-&gt;kill(); setHotPage(parent); &#125; else if (DebugMissingPools &amp;&amp; page-&gt;empty() &amp;&amp; !page-&gt;parent) &#123; // special case: delete everything for pop(top) // when debugging missing autorelease pools page-&gt;kill(); setHotPage(nil); &#125; else if (page-&gt;child) &#123; // hysteresis: keep one empty child if page is more than half fully if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; 我们先看看释放的函数releaseUntil，它在释放的时候其实会一直顺着parent往前释放，直到参数stop，也就是说可能一次性释放好几个page。 123456789101112131415161718192021// 代码有所删减void releaseUntil(id *stop)&#123; while (this-&gt;next != stop) &#123; AutoreleasePoolPage *page = hotPage(); while (page-&gt;empty()) &#123; page = page-&gt;parent; setHotPage(page); &#125; id obj = *--page-&gt;next; memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next)); if (obj != POOL_BOUNDARY) &#123; objc_release(obj); &#125; &#125; setHotPage(this);&#125; 然后我们来看看这段有疑问的代码 123456789101112131415161718192021// memory: delete empty childrenif (DebugPoolAllocation &amp;&amp; page-&gt;empty()) &#123; // 分支1 // special case: delete everything during page-per-pool debugging AutoreleasePoolPage *parent = page-&gt;parent; page-&gt;kill(); setHotPage(parent);&#125; else if (DebugMissingPools &amp;&amp; page-&gt;empty() &amp;&amp; !page-&gt;parent) &#123; // 分支2 // special case: delete everything for pop(top) // when debugging missing autorelease pools page-&gt;kill(); setHotPage(nil);&#125; else if (page-&gt;child) &#123; // 分支3 // hysteresis: keep one empty child if page is more than half fully if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125;&#125; 这块代码的作用是删除空的子节点，释放内存。pop之后三种情况： 当前page为空，直接kill掉当前page，然后把parent设置为hotpage； 当前page为空，而且没有parent，kill掉当前page，hotpage置为空； 当前page不为空，但是有child，如果当前page的空间占用不到一半，释放child，如果当前page的空间占用超过一半，且child还有child，直接释放这个孙子辈的page。（对于第三步注释中的解释是：keep one empty child if page is more than half fully） 我们再看看kill的实现，可以发现他是会顺着child一直往后释放，保证释放节点的child page都被释放了。 1234567891011121314151617void kill()&#123; AutoreleasePoolPage *page = this; while (page-&gt;child) page = page-&gt;child; AutoreleasePoolPage *deathptr; do &#123; deathptr = page; page = page-&gt;parent; if (page) &#123; page-&gt;unprotect(); page-&gt;child = nil; page-&gt;protect(); &#125; delete deathptr; &#125; while (deathptr != this);&#125; 到这里就可以得出结论了： pop之后，所有child page肯定都为空了，且当前page一定是hotPage 系统为了节约内存，判断，如果当前page空间使用少于一半，就释放掉所有的child page，如果当前page空间使用大于一半，就从孙子page开始释放，预留一个child page。]]></content>
      <tags>
        <tag>源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS用原生代码读写Webview的Local Storage]]></title>
    <url>%2F2018%2F04%2F03%2FiOS%E7%94%A8%E5%8E%9F%E7%94%9F%E4%BB%A3%E7%A0%81%E8%AF%BB%E5%86%99Webview%E7%9A%84Local%20Storage%2F</url>
    <content type="text"><![CDATA[背景公司项目使用的Cordova混合开发的，有一个模块以前用H5实现的，新版本用原生来实现，于是需要迁移数据。H5使用的Local Storage存的数据，原生要拿到数据有两种方案： 用WebView执行js方法来读取数据； 找到Local Storage存储路径，直接读取； 方案一实现起来比较简单，但是会存在一些问题，需要多开一个Webview来迁移数据，而且这个过程不好控制，不是最优解，本文讨论的是方案二。 直接读写Local Storage先说结论，Local Storage的其实是一个Sqlite数据库，我们要读写数据只要找到这个数据库，然后就可以实现手动读写了。 数据库存放路径 iOS 5.1及之前使用UIWebView：Library/Caches/iOS 5.1之后使用UIWebView：Library/WebKit/LocalStorage/WKWebView：Library/WebKit/WebsiteData/LocalStorage/ // UIWebView可以从UserDefault取出LocalStorage的路径[[NSUserDefaults standardUserDefaults] objectForKey:@”WebKitLocalStorageDatabasePathPreferenceKey”] 数据存储方式数据存在ItemTable表，只有key和value两个字段，key直接用NSString可以取出来，value取出来是一个NSData，需要用NSUTF16LittleEndianStringEncoding解码。 读写数据写了个简易的Demo，用的FMDB来操作数据库，这里就不介绍了。 12345678910111213// 取数据- (NSString *)valueWithKey:(NSString *)key &#123; if ([NSString isNull:key]) &#123; return nil; &#125; __block NSString *result; [self.dataQueue inDatabase:^(FMDatabase *db) &#123; NSData *data = [db dataForQuery:@&quot;select value from ItemTable where key = ?&quot;, key]; result = [[NSString alloc] initWithData:data encoding:NSUTF16LittleEndianStringEncoding]; &#125;]; return result;&#125; 123456789101112131415// 存数据- (BOOL)saveValue:(NSString *)value forKey:(NSString *)key &#123; if ([NSString isNull:value] || [NSString isNull:key]) &#123; return NO; &#125; __block BOOL result; [self.dataQueue inDatabase:^(FMDatabase *db) &#123; [db executeUpdate:@&quot;delete from ItemTable where key = ?&quot;, key]; NSData *data = [value dataUsingEncoding:NSUTF16LittleEndianStringEncoding]; result = [db executeUpdate:@&quot;insert into ItemTable (key, value) values (?, ?)&quot;, key, data]; &#125;]; return result;&#125; WebKit源码分析为了找到Local Storage存放的路径，在网上找了很多资料，发现这方面的资料很少，也没有怕出现各种坑或者系统版本兼容，于是决定研究下WebKit源码，从源码里面找答案。 Webkit、WebCore源码地址。可以看到WebKit有两个版本，WebKit-7604.1.38.0.7和WebKit2-7604.1.38.0.7，前者是UIWebView的，后者是WKWebView的。 解压WebKit-7604.1.38.0.7。用Xcode打开工程文件，工程名叫WebKitLegacy，这个命名太形象了，WebKit的遗产。苦于各种历史原因，公司项目还停留在UIWebView的阶段，心塞。在WebStorageManager.m类中可以看到关于Local Storage保存路径的定义，路径是Library/WebKit/LocalStorage/。 1234567891011static void initializeLocalStoragePath()&#123; NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; sLocalStoragePath = [defaults objectForKey:WebStorageDirectoryDefaultsKey]; if (!sLocalStoragePath || ![sLocalStoragePath isKindOfClass:[NSString class]]) &#123; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES); NSString *libraryDirectory = [paths objectAtIndex:0]; sLocalStoragePath = [libraryDirectory stringByAppendingPathComponent:@&quot;WebKit/LocalStorage&quot;]; &#125; sLocalStoragePath = [[sLocalStoragePath stringByStandardizingPath] retain];&#125; 解压WebKit2-7604.1.38.0.7，路径定义在WKProcessPool.mm类中，路径是Library/WebKit/WebsiteData/LocalStorage/。 123456789+ (NSURL *)_websiteDataURLForContainerWithURL:(NSURL *)containerURL bundleIdentifierIfNotInContainer:(NSString *)bundleIdentifier&#123; NSURL *url = [containerURL URLByAppendingPathComponent:@&quot;Library&quot; isDirectory:YES]; url = [url URLByAppendingPathComponent:@&quot;WebKit&quot; isDirectory:YES]; if (!WebKit::processHasContainer() &amp;&amp; bundleIdentifier) url = [url URLByAppendingPathComponent:bundleIdentifier isDirectory:YES]; return [url URLByAppendingPathComponent:@&quot;WebsiteData&quot; isDirectory:YES]; 至此关于UIWebView和WKWebView的存放路径我们已经能够确定了，那么文件名是怎么定义的呢，这要看WebCore的源码了，在SecurityOriginData.cpp中定义了文件名命名规则。 12345678910111213141516171819String SecurityOriginData::databaseIdentifier() const&#123; // Historically, we&apos;ve used the following (somewhat non-sensical) string // for the databaseIdentifier of local files. We used to compute this // string because of a bug in how we handled the scheme for file URLs. // Now that we&apos;ve fixed that bug, we still need to produce this string // to avoid breaking existing persistent state. if (equalIgnoringASCIICase(protocol, &quot;file&quot;)) return ASCIILiteral(&quot;file__0&quot;); StringBuilder stringBuilder; stringBuilder.append(protocol); stringBuilder.append(separatorCharacter); stringBuilder.append(encodeForFileName(host)); stringBuilder.append(separatorCharacter); stringBuilder.appendNumber(port.value_or(0)); return stringBuilder.toString();&#125; 从上面代码我们可以得出结论，如果是file协议的url，文件名定义为file__0，否则会根据它的url来生成一个文件名。 在跟代码的时候，发现UIWebView会把Local Storage的存储路径存在UserDefault里，存储的Key是WebKitLocalStorageDatabasePathPreferenceKey（定义在WebPreferenceKeysPrivate.h）。在文件WebPrefences.mm中可以找到相关代码 123456789101112131415161718192021222324252627282930- (NSString *)_localStorageDatabasePath&#123; return [[self _stringValueForKey:WebKitLocalStorageDatabasePathPreferenceKey] stringByStandardizingPath];&#125;- (NSString *)_stringValueForKey:(NSString *)key&#123; id s = [self _valueForKey:key]; return [s isKindOfClass:[NSString class]] ? (NSString *)s : nil;&#125;- (id)_valueForKey:(NSString *)key&#123; NSString *_key = KEY(key);#if PLATFORM(IOS) __block id o = nil; dispatch_sync(_private-&gt;readWriteQueue, ^&#123; o = [_private-&gt;values.get() objectForKey:_key]; &#125;);#else id o = [_private-&gt;values.get() objectForKey:_key];#endif if (o) return o; o = [[NSUserDefaults standardUserDefaults] objectForKey:_key]; if (!o &amp;&amp; key != _key) o = [[NSUserDefaults standardUserDefaults] objectForKey:key]; return o;&#125; Local Storage存在的问题在查询资料的过程中，发现了很多Local Storage的缺陷，有一篇关于Local Storage的论文可以参考。有以下几点： 不要用Local Storage来做持久化存储，在iOS中，出现存储空间紧张时，它会被系统清理掉； 不要用Local Storage来存大数据，它的读写效率很低下，因为它需要序列化/反序列化 它有5M的大小限制 总结起来就一句话，不要滥用Local Storage。有很多替代方案，比如https://github.com/TheCocoaProject/cordova-plugin-nativestorage 参考资料https://github.com/wootwoot1234/react-native-webkit-localstorage-reader/issues/4https://blog.csdn.net/shuimuniao/article/details/8027276https://stackoverflow.com/questions/26465409/restore-localstorage-data-from-old-cordova-app/49604587#49604587https://stackoverflow.com/questions/9067249/how-do-i-access-html5-local-storage-created-by-phonegap-on-ios/49604541#49604541https://issues.apache.org/jira/browse/CB-12509]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFNetworking下载文件时文件名长度的坑]]></title>
    <url>%2F2018%2F03%2F29%2FAFNetworking%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%97%B6%E6%96%87%E4%BB%B6%E5%90%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[背景最近遇到一个Bug，在用AFNetworking下载文件的时候莫名其妙的失败了，跟了一下发现一个小坑，记录一下防止以后再掉进去。 iOS和Linux的文件名的长度限制相同都是255个字符！！！ 问题根源是文件名超度超过了255个字符，AFNetworking下载文件是成功了（框架会把文件下载到一个临时文件，例如：CFNetworkDownload_xxx.tmp，这个文件名不会出现过长的问题），下载成功之后会copy到调用者指定路径，在这里指定的文件名超过了255个字符，导致创建文件失败，于是回调是成功了，但是在设置的路径找不到这个文件。 上代码！ 下载代码： 12345678910// 注意对文件名长度进行处理！！！NSString *destination = @&quot;下载地址（长度大于255）&quot;;NSURLSessionDownloadTask *aTask = [self.updownloadSessionManager downloadTaskWithRequest:mutableRequest progress:^(NSProgress * _Nonnull downloadProgress) &#123; &#125; destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123; return [NSURL fileURLWithPath:destination]; &#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) &#123; // 下载成功后会回调该block，但是路径`destination`找不到这个文件 &#125;]; [aTask resume]; 出错的地方AFURLSessionManager.m 123456789101112131415161718192021- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; self.downloadFileURL = nil; if (self.downloadTaskDidFinishDownloading) &#123; self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); if (self.downloadFileURL) &#123; NSError *fileManagerError = nil; // location是临时文件，是下载成功了 // self.downloadFileURL 是目标路径，文件名超过255 // 移动文件会报错 if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError]) &#123; // 出错会发通知，可以监听处理 [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo]; &#125; &#125; &#125;&#125; 我们来看看AFURLSessionDownloadTaskDidFailToMoveFileNotification的定义AFURLSessionManager.h 1234/** Posted when a session download task encountered an error when moving the temporary download file to a specified destination. */FOUNDATION_EXPORT NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification;]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS用CallKit实现来电识别]]></title>
    <url>%2F2018%2F03%2F03%2FiOS%E7%94%A8CallKit%E5%AE%9E%E7%8E%B0%E6%9D%A5%E7%94%B5%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言 最近需要实现一个新需求，用iOS 10出的CallKit实现将APP的通讯录的信息同步到系统中，可以不把人员信息加到通讯录中，实现来电号码识别。这个功能在xx安全卫士、xx管家中很早就实现了，但是网上相关的资料较少，而且官方的文档写的太简单了，很多坑还要自己去摸索。于是记录一下和各位分享，如有错误之处请各位指出！ PS: 先说个题外话吧，CallKit功能在iOS 10的时候还不太稳定，iOS 10刚出来的时候为了体验骚扰拦截功能，手贱装了两个不同的拦截APP，然后就悲剧了。盗一张网上的图： 然后各种重启、重装APP都没有用，写的Demo也跑不起来，唯一的办法只有重置系统。说多了都是泪！ 本文涉及的Demo。 一、Call Directory app extension实现来电识别、来电拦截功能需要使用CallKit当中的Call Directory app extension，首先，需要了解extension。关于extension网上有很多教程，这里就不细说了。推荐两篇文章，英文好的推荐看官方文档，还有一篇中文博客。 使用Call Directory Extension主要需要和3个类打交道，分别是CXCallDirectoryProvider、CXCallDirectoryExtensionContext、CXCallDirectoryManager。 CXCallDirectoryProvider 官方文档：The principal object for a Call Directory app extension for a host app. 正如官方文档所说，这是Call Directory app extension最重要的一个类。用系统模板新建Call Directory Extension之后会自动生成一个类，继承自CXCallDirectoryProvider。入口方法：123456789// 有两种情况改方法会被调用// 1.第一次打开设置-电话-来电阻止与身份识别开关时，系统自动调用// 2.调用CXCallDirectoryManager的reloadExtensionWithIdentifier方法会调用- (void)beginRequestWithExtensionContext:(CXCallDirectoryExtensionContext *)context &#123; context.delegate = self; // 添加号码识别信息与号码拦截列表 [self addIdentificationPhoneNumbersToContext:context]; [context completeRequestWithCompletionHandler:nil];&#125; CXCallDirectoryExtensionContext 官方文档：A programmatic interface for adding identification and blocking entries to a Call Directory app extension.CXCallDirectoryExtensionContext objects are not initialized directly, but are instead passed as arguments to the CXCallDirectoryProvider instance method beginRequestWithExtensionContext:. 大致意思就是说，这是一个为Call Directory app extension添加号码识别、号码拦截的入口。CXCallDirectoryExtensionContext不需要自己初始化，它会作为CXCallDirectoryProvider的beginRequestWithExtensionContext函数的参数传递给使用者。它的主要方法有两个： 12345// 设置号码识别信息- (void)addIdentificationEntryWithNextSequentialPhoneNumber:(CXCallDirectoryPhoneNumber)phoneNumber label:(NSString *)label;// 设置号码拦截列表- (void)addBlockingEntryWithNextSequentialPhoneNumber:(CXCallDirectoryPhoneNumber)phoneNumber; 在设置时候要注意： 号码不能重复，不然会报错CXErrorCodeCallDirectoryManagerErrorDuplicateEntries 号码必须按照升序写入，不然会报错CXErrorCodeCallDirectoryManagerErrorEntriesOutOfOrder 号码必须格式化后传入，手机号码必须加上国家码，例如18012341234就不行，需要加上86，构造成8618012341234；固话需要格式为：国家码+区号（去掉第一个0）+号码，例如010-61001234格式化之后为，861061001234。如果号码格式错误，会导致识别不出来。 上限数据是200万（在其它文章里看到的，然后自己测试了下，构造了200万条数据写入的时候会报错CXErrorCodeCallDirectoryManagerErrorMaximumEntriesExceeded，150万条数据是OK的，所以这个数据上限一定要注意。实测安装了XX安全卫士、XX管家实现骚扰电话拦截用了3个extension，可能数据量太大就是一个原因。） 在用户第一次打开设置时，会调用beginRequestWithExtensionContext，这时候不宜写太多数据，不然会卡在设置那里转圈，用户体验很差。可以先写部分数据，然后回到主APP了调用reloadExtensionWithIdentifier去刷新。 CXCallDirectoryManager 官方文档：The programmatic interface to an object that manages a Call Directory app extension. CXCallDirectoryManager主要作用是管理Call Directory app extension。有两个方法： 123456// 重新设置号码识别、电话拦截列表// 调用该方法后会重置之前设置的列表，然后调用beginRequestWithExtensionContext:- (void)reloadExtensionWithIdentifier:(NSString *)identifier completionHandler:(nullable void (^)(NSError *_Nullable error))completion;// 获取extension是否可用，需要在“设置-电话-来电阻止与身份识别"中开启权限- (void)getEnabledStatusForExtensionWithIdentifier:(NSString *)identifier completionHandler:(void (^)(CXCallDirectoryEnabledStatus enabledStatus, NSError *_Nullable error))completion; 二、实战 先上Demo地址。下面会一步步讲解。 创建extension新建一个Target（File-New-Target）。 会自动建立一个目录，默认有三个文件。在.m文件中有系统给出的示例代码 我们来看看系统的模板代码，首先是入口函数 1234567891011121314- (void)beginRequestWithExtensionContext:(CXCallDirectoryExtensionContext *)context &#123; context.delegate = self; if (context.isIncremental) &#123; [self addOrRemoveIncrementalBlockingPhoneNumbersToContext:context]; [self addOrRemoveIncrementalIdentificationPhoneNumbersToContext:context]; &#125; else &#123; [self addAllBlockingPhoneNumbersToContext:context]; [self addAllIdentificationPhoneNumbersToContext:context]; &#125; [context completeRequestWithCompletionHandler:nil];&#125; CallDirectoryHandler我在Xcode 9生成的代码，context.isIncremental是iOS 11才增加的，还有所有的remove的方法也是iOS 11才有的，为了适配iOS 10，还是不推荐使用。系统模板代码大致逻辑就是，先添加号码识别、号码拦截记录，添加完成后调用completeRequestWithCompletionHandler:完成整个过程。由于号码拦截比较简单，只是写入一个号码的数组，本文就以号码识别为例，号码识别方法系统模板这么写的：12345678910- (void)addAllIdentificationPhoneNumbersToContext:(CXCallDirectoryExtensionContext *)context &#123; CXCallDirectoryPhoneNumber allPhoneNumbers[] = &#123; 8618788888888, 8618885555555 &#125;; NSArray&lt;NSString *&gt; *labels = @[ @"送餐电话", @"诈骗电话" ]; NSUInteger count = (sizeof(allPhoneNumbers) / sizeof(CXCallDirectoryPhoneNumber)); for (NSUInteger i = 0; i &lt; count; i += 1) &#123; CXCallDirectoryPhoneNumber phoneNumber = allPhoneNumbers[i]; NSString *label = labels[i]; [context addIdentificationEntryWithNextSequentialPhoneNumber:phoneNumber label:label]; &#125;&#125; 这么多代码，核心就是一行[context addIdentificationEntryWithNextSequentialPhoneNumber:phoneNumber label:label];,注意phoneNumber是CXCallDirectoryPhoneNumber类型，其实就是long long类型。在这个函数里，需要把需要识别的号码和识别信息，一条一条的写入 检查授权开启extension功能需要在“设置-电话-来电阻止与身份识别”中开启，我们在写入数据时第一步是引导用户给我们的extension授权。123456789 CXCallDirectoryManager *manager = [CXCallDirectoryManager sharedInstance]; [manage getEnabledStatusForExtensionWithIdentifier:self.externsionIdentifier completionHandler:^(CXCallDirectoryEnabledStatus enabledStatus, NSError * _Nullable error) &#123; // 根据error，enabledStatus判断授权情况// error == nil &amp;&amp; enabledStatus == CXCallDirectoryEnabledStatusEnabled 说明可用// error 见 CXErrorCodeCallDirectoryManagerError// enabledStatus 见 CXCallDirectoryEnabledStatus &#125;]; 写入数据用户在设置开启后，调用reloadExtensionWithIdentifier即可触发CallDirectoryHandler更新数据逻辑。 1234CXCallDirectoryManager *manager = [CXCallDirectoryManager sharedInstance];[manager reloadExtensionWithIdentifier:self.externsionIdentifier completionHandler:^(NSError * _Nullable error) &#123; // error 见 CXErrorCodeCallDirectoryManagerError&#125;]; 验证接下来在真机下跑下（一定要在插了电话卡的iPhone上调试，模拟器不行！），写入成功后，打开电话，拨号18788888888，提示”送餐电话”。说明写入成功！ 三、extension和containing app数据共享上面的步骤中，号码信息是写死在代码中的，在实际应用中这些号码信息肯定不是写死的，一般需要从服务器获取。这就需要我们的APP与extension进行通信，需要用到APP Groups，怎么用网上有很多文章了，我就不多说了，推荐一篇。其实本质就是通过APP Groups，开辟一片空间，extension和containing app都可以访问，然后我们的APP就可以通过NSUserDefaults、文件、数据库等方式共享数据给extension了。前期我使用过NSUserDefaults，效率很低，大概在5万数据的时候就爆内存了，使用extension一定要注意内存，不然很容易被系统干掉，所以不推荐使用这种方式。Demo中采用的是读写文件的方式，大致思路（具体实现看Demo）： 在APP中把数据序列化之后写到一个文件中 在extension中读取这个文件，读取一行，调用一次addIdentificationEntryWithNextSequentialPhoneNumber，然后及时释放这种方式理论上是可以达到最大限制200w条的（实际测试150万没有问题）。 获取APP Groups文件路径1234NSFileManager *fileManager = [NSFileManager defaultManager]; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:self.groupIdentifier]; containerURL = [containerURL URLByAppendingPathComponent:@"CallDirectoryData"]; NSString* filePath = containerURL.path; 进度监控在xx安全卫士中，开启骚扰电话拦截功能有一个进度条，非常的直观。但是在extension中是没法更新UI的，有一种实现方式，可以用开源框架MMWormhole来实现APP与extension通信，然后把进度从extension传到APP中，在APP中更新进度条。理论上该方案是可行的，感兴趣的同学可以尝试下。 关于上架在加上CallKit第一次上架时，收到了苹果的拒信，说CallKit在中国区被禁止了。 后来观察了下xx安全卫士一直在正常更新，猜想苹果只是禁止了CallKit关于VOIP这部分功能。遇到苹果的拒信不要慌，录制一个来电识别的功能演示视频，放到Youtube，然后在备注里面解释一下，就可以通过审核了。 给一个审核备注模板： 关于CallKit，我们遵守中国的法律，没有使用VOIP，我们仅使用了Call Directory。我们应用内有一个公司内部通讯录，为了增加用户员工沟通效率，我们在电话页面自动识别内部通讯录的人员 ，并展示姓名与岗位。我们录制了一个演示视频：视频地址 参考链接https://developer.apple.com/documentation/callkithttps://developer.apple.com/videos/play/wwdc2016/230/https://colin1994.github.io/2016/06/17/Call-Directory-Extension-Study/https://yunissong.github.io/2017/03/29/CallKit/http://www.jianshu.com/p/7f88cbe7948chttps://www.raywenderlich.com/150015/callkit-tutorial-ios]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS的Cookie管理]]></title>
    <url>%2F2018%2F03%2F01%2FiOS%E7%9A%84Cookie%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[背景最近有一个需求，需要手动的去缓存cookie，然后启动APP的时候设置缓存过的cookie，项目网络框架用的是Afnetworking。 解决方案翻了下Afnetworking的issue，发现了作者对于cookie的解释 Afnetworking没有对Cookie做过处理 使用NSHTTPCookieStorage即可实现cookie的管理。上代码！ 存cookie 1234NSArray *cookies = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookiesForURL:[NSURL URLWithString:url]];NSData *data = [NSKeyedArchiver archivedDataWithRootObject:cookies];NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];[userDefaults setObject:data forKey:@&quot;cookie&quot;]; 设置cookie 12345678NSData *cookiesdata = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;m3cookie&quot;]; if([cookiesdata length]) &#123; NSArray *cookies = [NSKeyedUnarchiver unarchiveObjectWithData:cookiesdata]; NSHTTPCookie *cookie; for (cookie in cookies) &#123; [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie]; &#125; &#125; 清理cookie 12345NSHTTPCookie *cookie;NSHTTPCookieStorage *storage = [NSHTTPCookieStorage sharedHTTPCookieStorage];for (cookie in [storage cookies]) &#123; [storage deleteCookie:cookie];&#125; 参考文章： NSHTTPCookieStorage官方文档Persisting Cookies In An iOS Application?Clear cookies for response in AFNetworking 2]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[imageNamed与imageWithContentsOfFile小结]]></title>
    <url>%2F2018%2F03%2F01%2FimageNamed%E4%B8%8EimageWithContentsOfFile%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本文主要讲imageNamed与imageWithContentsOfFile的差异，需要注意的点，与实战中遇到的坑。 好久没写过博客了，什么工作太忙，加班太晚我就不说了，都怪自己太懒😂，时间都是挤出来的。看着各位大牛写的文章，简直过瘾，希望有一天自己也能写出这么高质量、干货密集的文章，先从简单的做起吧。 从差异说起从磁盘加载图片，UIImage主要提供了两种方式： +(UIImage )imageNamed:(NSString )name;+(UIImage )imageWithContentsOfFile:(NSString )path; 关于这两种方法的使用时机，苹果官方文档描述如下： Use the imageNamed:inBundle:compatibleWithTraitCollection: method (or the imageNamed: method) to create an image from an image asset or image file located in your app’s main bundle (or some other known bundle). Because these methods cache the image data automatically, they are especially recommended for images that you use frequently.Use the imageWithContentsOfFile: or initWithContentsOfFile: method to create an image object where the initial data is not in a bundle. These methods load the image data from disk each time, so you should not use them to load the same image repeatedly. 也就是说，imageNamed:第一次加载图片时会缓存图片到内存，适合使用频繁的图片，imageWithContentsOfFile:不会把图片缓存到内存，每次调用都要重新从磁盘加载一次。在实际使用中我们要根据业务来判断调用具体的方法，来最优化内存与性能。举个例子： 登陆背景图，只会在用户登陆的时候使用，而且图片较大，就建议用imageWithContentsOfFile:加载； 底导航图标，图标较小，使用频繁，就建议使用imageNamed:加载； imageNamed:方法还有个限制，它是在main bundle里找图片，如果图片放在Images.xcassets或者直接把图片方在工程里，参数直接传图片名可以找到。像我司的图片是放在单独建立的bundle里，如果要用imageNamed:加载的话文件名前面就要加上bundle名，像这样a.bundle/b.png。 屏幕适配问题iOS的图片文件需要提供3种尺寸的1x、2x、3x，根据不同的屏幕尺寸我们需要加载不同的图片，关于不同屏幕的图片加载，苹果已经帮我们封装好了，我们只需要将3中尺寸的图片放到工程中，然后调用imageNamed:或者imageWithContentsOfFile:，它会自动根据屏幕尺寸来加载不同的图片。关于imageNamed:，官方文档中有这么一段讨论： This method looks in the system caches for an image object with the specified name and returns the variant of that image that is best suited for the main screen. imageWithContentsOfFile:还没找到官方文档的说明（如果各位知道，欢迎各位大牛在评论中提出），不过我测试过是可以的。 使用imageWithContentsOfFile的一个坑在使用imageWithContentsOfFile:加载图片的时候遇到一个坑，先上代码： 1234567+ (UIImage *)imageWithName:(NSString *)name type:(NSString *)type inBundle:(NSString *)bundle &#123; NSString *imageBundlePath = [[NSBundle mainBundle] pathForResource:bundle ofType:@&quot;bundle&quot;]; NSBundle *imageBundle = [NSBundle bundleWithPath:imageBundlePath]; NSString *imagePath = [imageBundle pathForResource:name ofType:type]; UIImage *image = [UIImage imageWithContentsOfFile:imagePath]; return image;&#125; 很简单的一个函数，就是获取bundle全路径，然后再获取到bundle里图片的全路径，然后调用imageWithContentsOfFile:加载图片。在使用的时候也很正常，但是有一天发现某张图加载不出来了。检查资源文件，只有2x的图（又是一个偷懒的程序员。。。很不建议这么玩，虽然只有2x的图，在所有屏幕都能显示，但是会造成图片的压缩与放大，每个细节都很重要！！！），如果加上1x的图就可以加载出来了。经过调试发现问题就出在pathForResource:ofType上，这个函数是精确匹配调用者输入的文件名，不会自动识别文件名后面的@2x。修改后的代码： 12345678+ (UIImage *)imageWithName:(NSString *)name type:(NSString *)type inBundle:(NSString *)bundle &#123; NSString *imageBundlePath = [[NSBundle mainBundle] pathForResource:bundle ofType:@&quot;bundle&quot;]; NSBundle *imageBundle = [NSBundle bundleWithPath:imageBundlePath]; NSString *imageFullName = [name stringByAppendingPathExtension:type]; NSString *imagePath = [[imageBundle resourcePath] stringByAppendingPathComponent:imageFullName]; UIImage *image = [UIImage imageWithContentsOfFile:imagePath]; return image;&#125;]]></content>
      <tags>
        <tag>iOS知识小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式笔记]]></title>
    <url>%2F2016%2F11%2F20%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[正则表达式（regular expression）描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的字串做替换或者从某个串中取出符合某个条件的字串等。 正则表达式在线测试：http://www.regexpal.com/ 元字符常用元字符： 代码 说明 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \d 匹配数字 \s 匹配空格 \b 匹配单词的开始或结束 ^ 匹配字符串的开始，如果是处理多行，意义变成行开始处 $ 匹配字符串的结束，如果是处理多行，意义变成行结束处 限定符常用限定符： 代码 说明 * *前面的内容重复任意次 + +前面的内容重复一次或者多次 ? 重复零次或一次 {n} 重复n次 {n, } 重复次数大于等于n {n,m} 重复次数大于等于n小于等于m 字符类[auiou] 匹配任何一个英文元音字母[.?!] 匹配标点符号（. ? !） 反义 代码 说明 \W 匹配任意不是字母、数字、下划线、汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^abcd] 匹配除了abcd以外的任意字符 分组 代码 说明 (exp) 匹配exp，并捕获文本到自动命名组中 (?&lt;name&gt;exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?`name`exp) (?:exp) 匹配exp，不捕获匹配的文本，也不给次分组分配组号 (?=exp) 匹配exp前面的位置 (?&lt;=exp) 匹配exp后面的位置 (?!exp) 匹配后面跟的不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 (?#comment) 注释 贪婪与懒惰通常重复限定符的行为是匹配尽可能多的字符，在限定符后面加?使之成为惰性限定符，例如*?的含义为重复任意次数，但是尽可能少]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang编码规范]]></title>
    <url>%2F2016%2F11%2F20%2FGolang%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[gofmt 大部分的格式问题可以通过gofmt解决，gofmt自动格式化代码，保证所有的go代码与官方推荐的格式保持一致，于是所有格式有关问题，都以gofmt的结果为准。 行长 一行最长不超过80个字符，超过的使用换行展示，尽量保持格式优雅。 注释 在编码阶段应该同步写好变量、函数、包的注释，最后可以利用godoc导出文档。注释必须是完整的句子，句子的结尾应该用句号作为结尾（英文句号）。注释推荐用英文，可以在写代码过程中锻炼英文的阅读和书写能力。而且用英文不会出现各种编码的问题。每个包都应该有一个包注释，一个位于package子句之前的块注释或行注释。包如果有多个go文件，只需要出现在一个go文件中即可。 12// ping包实现了常用的ping相关的函数package ping 导出函数注释，第一条语句应该为一条概括语句，并且使用被声明的名字作为开头。 12// 求a和b的和，返回sum。func Myfunction(sum int) (a, b int) &#123; 命名 需要注释来补充的命名就不算是好命名。 使用可搜索的名称：单字母名称和数字常量很难从一大堆文字中搜索出来。单字母名称仅适用于短方法中的本地变量，名称长短应与其作用域相对应。若变量或常量可能在代码中多处使用，则应赋其以便于搜索的名称。 做有意义的区分：Product和ProductInfo和ProductData没有区别，NameString和Name没有区别，要区分名称，就要以读者能鉴别不同之处的方式来区分 。 函数命名规则：驼峰式命名，名字可以长但是得把功能，必要的参数描述清楚，函数名名应当是动词或动词短语，如postPayment、deletePage、save。并依Javabean标准加上get、set、is前缀。例如：xxx + With + 需要的参数名 + And + 需要的参数名 + ….. 结构体命名规则：结构体名应该是名词或名词短语，如Custome、WikiPage、Account、AddressParser，避免使用Manager、Processor、Data、Info、这样的类名，类名不应当是动词。 包名命名规则：包名应该为小写单词，不要使用下划线或者混合大小写。 接口命名规则：单个函数的接口名以”er”作为后缀，如Reader,Writer。接口的实现则去掉“er”。 123type Reader interface &#123; Read(p []byte) (n int, err error)&#125; 两个函数的接口名综合两个函数名1234type WriteFlusher interface &#123; Write([]byte) (int, error) Flush() error&#125; 三个以上函数的接口名，抽象这个接口的功能，类似于结构体名12345type Car interface &#123; Start([]byte) Stop() error Recover()&#125; 常量 常量均需使用全部大写字母组成，并使用下划线分词： 1const APP_VER = &quot;1.0&quot; 如果是枚举类型的常量，需要先创建相应类型： 123456type Scheme stringconst ( HTTP Scheme = &quot;http&quot; HTTPS Scheme = &quot;https&quot;) 如果模块的功能较为复杂、常量名称容易混淆的情况下，为了更好地区分枚举类型，可以使用完整的前缀： 1234567type PullRequestStatus intconst ( PULL_REQUEST_STATUS_CONFLICT PullRequestStatus = iota PULL_REQUEST_STATUS_CHECKING PULL_REQUEST_STATUS_MERGEABLE) 变量 变量命名基本上遵循相应的英文表达或简写,在相对简单的环境（对象数量少、针对性强）中，可以将一些名称由完整单词简写为单个字母，例如： user 可以简写为 u userID 可以简写 uid若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头： 1234var isExist boolvar hasConflict boolvar canManage boolvar allowGitHook bool 变量命名惯例 变量名称一般遵循驼峰法，但遇到特有名词时，需要遵循以下规则： 如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient 其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID 错误示例：UrlArray，应该写成urlArray或者URLArray 下面列举了一些常见的特有名词： 123456789101112131415161718192021222324252627282930313233343536// A GonicMapper that contains a list of common initialisms taken from golang/lintvar LintGonicMapper = GonicMapper&#123; &quot;API&quot;: true, &quot;ASCII&quot;: true, &quot;CPU&quot;: true, &quot;CSS&quot;: true, &quot;DNS&quot;: true, &quot;EOF&quot;: true, &quot;GUID&quot;: true, &quot;HTML&quot;: true, &quot;HTTP&quot;: true, &quot;HTTPS&quot;: true, &quot;ID&quot;: true, &quot;IP&quot;: true, &quot;JSON&quot;: true, &quot;LHS&quot;: true, &quot;QPS&quot;: true, &quot;RAM&quot;: true, &quot;RHS&quot;: true, &quot;RPC&quot;: true, &quot;SLA&quot;: true, &quot;SMTP&quot;: true, &quot;SSH&quot;: true, &quot;TLS&quot;: true, &quot;TTL&quot;: true, &quot;UI&quot;: true, &quot;UID&quot;: true, &quot;UUID&quot;: true, &quot;URI&quot;: true, &quot;URL&quot;: true, &quot;UTF8&quot;: true, &quot;VM&quot;: true, &quot;XML&quot;: true, &quot;XSRF&quot;: true, &quot;XSS&quot;: true,&#125; struct规范 struct申明和初始化格式采用多行： 定义如下： 1234type User struct&#123; Username string Email string&#125; 初始化如下： 1234u := User&#123; Username: &quot;test&quot;, Email: &quot;test@gmail.com&quot;,&#125; 控制结构 ifif接受初始化语句，约定如下方式建立局部变量 123if err := file.Chmod(0664); err != nil &#123; return err&#125; for采用短声明建立局部变量 1234sum := 0for i := 0; i &lt; 10; i++ &#123; sum += i&#125; return尽早return：一旦有错误发生，马上返回 12345678910f, err := os.Open(name)if err != nil &#123; return err&#125;d, err := f.Stat()if err != nil &#123; f.Close() return err&#125;codeUsing(f, d) 错误处理 error作为函数的值返回,必须对error进行处理 错误描述如果是英文必须为小写，不需要标点结尾 采用独立的错误流进行处理 不要采用下面的处理错误写法 12345if err != nil &#123; // error handling&#125; else &#123; // normal code&#125; 采用下面的写法 12345if err != nil &#123; // error handling return // or continue, etc.&#125;// normal code 使用函数的返回值时，则采用下面的方式 123456x, err := f()if err != nil &#123; // error handling return&#125;// use x panic 尽量不要使用panic，除非你知道你在做什么 import 对import的包进行分组管理，用换行符分割，而且标准库作为分组的第一组。如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包 123456789101112package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;kmg/a&quot; &quot;kmg/b&quot; &quot;code.google.com/a&quot; &quot;github.com/b&quot;) 在项目中不要使用相对路径引入包： 12345// 错误示例import “../net”// 正确的做法import “github.com/repo/proj/src/net” goimports会自动帮你格式化 参数传递 对于少量数据，不要传递指针 对于大量数据的struct可以考虑使用指针 传入参数是map，slice，chan不要传递指针，因为map，slice，chan是引用类型，不需要传递指针的指针 单元测试 单元测试文件名命名规范为 example_test.go测试用例的函数名称必须以 Test 开头，例如：TestExample]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
</search>
