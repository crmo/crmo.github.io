<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CR.MO`s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://crmo.github.io/"/>
  <updated>2018-02-28T11:46:57.269Z</updated>
  <id>http://crmo.github.io/</id>
  
  <author>
    <name>CR.MO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS的Cookie管理</title>
    <link href="http://crmo.github.io/2018/02/28/iOS%E7%9A%84Cookie%E7%AE%A1%E7%90%86/"/>
    <id>http://crmo.github.io/2018/02/28/iOS的Cookie管理/</id>
    <published>2018-02-28T11:41:58.020Z</published>
    <updated>2018-02-28T11:46:57.269Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/1.jpeg" alt=""></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近有一个需求，需要手动的去缓存cookie，然后启动APP的时候设置缓存过的cookie，项目网络框架用的是Afnetworking。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>翻了下Afnetworking的issue，发现了作者对于cookie的解释</p><blockquote><p>Afnetworking没有对Cookie做过处理</p></blockquote><p><img src="images/2.jpg" alt=""></p><p>使用<code>NSHTTPCookieStorage</code>即可实现cookie的管理。上代码！</p><p><strong>存cookie</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *cookies = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookiesForURL:[NSURL URLWithString:url]];</span><br><span class="line">NSData *data = [NSKeyedArchiver archivedDataWithRootObject:cookies];</span><br><span class="line">NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">[userDefaults setObject:data forKey:@&quot;cookie&quot;];</span><br></pre></td></tr></table></figure><p><strong>设置cookie</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSData *cookiesdata = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;m3cookie&quot;];</span><br><span class="line">    if([cookiesdata length]) &#123;</span><br><span class="line">        NSArray *cookies = [NSKeyedUnarchiver unarchiveObjectWithData:cookiesdata];</span><br><span class="line">        NSHTTPCookie *cookie;</span><br><span class="line">        for (cookie in cookies) &#123;</span><br><span class="line">            [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>清理cookie</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSHTTPCookie *cookie;</span><br><span class="line">NSHTTPCookieStorage *storage = [NSHTTPCookieStorage sharedHTTPCookieStorage];</span><br><span class="line">for (cookie in [storage cookies]) &#123;</span><br><span class="line">    [storage deleteCookie:cookie];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考文章：</p><blockquote><p><a href="https://developer.apple.com/documentation/foundation/nshttpcookiestorage" target="_blank" rel="noopener">NSHTTPCookieStorage官方文档</a><br><a href="https://stackoverflow.com/questions/4597763/persisting-cookies-in-an-ios-application/8713316#8713316" target="_blank" rel="noopener">Persisting Cookies In An iOS Application?</a><br><a href="https://stackoverflow.com/questions/21625313/clear-cookies-for-response-in-afnetworking-2" target="_blank" rel="noopener">Clear cookies for response in AFNetworking 2</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/1.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近有一个需求，需要手动的去缓存cookie，然后启动AP
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>imageNamed与imageWithContentsOfFile小结</title>
    <link href="http://crmo.github.io/2018/02/28/imageNamed%E4%B8%8EimageWithContentsOfFile%E5%B0%8F%E7%BB%93/"/>
    <id>http://crmo.github.io/2018/02/28/imageNamed与imageWithContentsOfFile小结/</id>
    <published>2018-02-28T11:41:58.020Z</published>
    <updated>2018-02-28T12:05:08.041Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/3.jpg" alt=""></p><blockquote><p>本文主要讲imageNamed与imageWithContentsOfFile的差异，需要注意的点，与实战中遇到的坑。</p></blockquote><p>好久没写过博客了，什么工作太忙，加班太晚我就不说了，都怪自己太懒😂，时间都是挤出来的。看着各位大牛写的文章，简直过瘾，希望有一天自己也能写出这么高质量、干货密集的文章，先从简单的做起吧。</p><h2 id="从差异说起"><a href="#从差异说起" class="headerlink" title="从差异说起"></a>从差异说起</h2><p>从磁盘加载图片，UIImage主要提供了两种方式：</p><blockquote><p>+(UIImage <em>)imageNamed:(NSString </em>)name;<br>+(UIImage <em>)imageWithContentsOfFile:(NSString </em>)path;</p></blockquote><p>关于这两种方法的使用时机，苹果官方文档描述如下：</p><blockquote><p>Use the imageNamed:inBundle:compatibleWithTraitCollection: method (or the imageNamed: method) to create an image from an image asset or image file located in your app’s main bundle (or some other known bundle). Because these methods cache the image data automatically, they are especially recommended for images that you use frequently.<br>Use the imageWithContentsOfFile: or initWithContentsOfFile: method to create an image object where the initial data is not in a bundle. These methods load the image data from disk each time, so you should not use them to load the same image repeatedly.</p></blockquote><p>也就是说，<code>imageNamed:</code>第一次加载图片时会缓存图片到内存，适合使用频繁的图片，<code>imageWithContentsOfFile:</code>不会把图片缓存到内存，每次调用都要重新从磁盘加载一次。<br>在实际使用中我们要根据业务来判断调用具体的方法，来最优化内存与性能。举个例子：</p><ol><li>登陆背景图，只会在用户登陆的时候使用，而且图片较大，就建议用<code>imageWithContentsOfFile:</code>加载；</li><li>底导航图标，图标较小，使用频繁，就建议使用<code>imageNamed:</code>加载；</li></ol><blockquote><p><code>imageNamed:</code>方法还有个限制，它是在main bundle里找图片，如果图片放在<code>Images.xcassets</code>或者直接把图片方在工程里，参数直接传图片名可以找到。像我司的图片是放在单独建立的bundle里，如果要用<code>imageNamed:</code>加载的话文件名前面就要加上bundle名，像这样<code>a.bundle/b.png</code>。</p></blockquote><h2 id="屏幕适配问题"><a href="#屏幕适配问题" class="headerlink" title="屏幕适配问题"></a>屏幕适配问题</h2><p>iOS的图片文件需要提供3种尺寸的1x、2x、3x，根据不同的屏幕尺寸我们需要加载不同的图片，关于不同屏幕的图片加载，苹果已经帮我们封装好了，我们只需要将3中尺寸的图片放到工程中，然后调用<code>imageNamed:</code>或者<code>imageWithContentsOfFile:</code>，它会自动根据屏幕尺寸来加载不同的图片。<br>关于<code>imageNamed:</code>，官方文档中有这么一段讨论：</p><blockquote><p>This method looks in the system caches for an image object with the specified name and returns the variant of that image that is best suited for the main screen. </p></blockquote><p><code>imageWithContentsOfFile:</code>还没找到官方文档的说明（如果各位知道，欢迎各位大牛在评论中提出），不过我测试过是可以的。</p><h2 id="使用imageWithContentsOfFile的一个坑"><a href="#使用imageWithContentsOfFile的一个坑" class="headerlink" title="使用imageWithContentsOfFile的一个坑"></a>使用imageWithContentsOfFile的一个坑</h2><p>在使用<code>imageWithContentsOfFile:</code>加载图片的时候遇到一个坑，先上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (UIImage *)imageWithName:(NSString *)name type:(NSString *)type inBundle:(NSString *)bundle &#123;</span><br><span class="line">    NSString *imageBundlePath = [[NSBundle mainBundle] pathForResource:bundle ofType:@&quot;bundle&quot;];</span><br><span class="line">    NSBundle *imageBundle = [NSBundle bundleWithPath:imageBundlePath];</span><br><span class="line">    NSString *imagePath = [imageBundle pathForResource:name ofType:type];</span><br><span class="line">    UIImage *image = [UIImage imageWithContentsOfFile:imagePath];</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的一个函数，就是获取bundle全路径，然后再获取到bundle里图片的全路径，然后调用<code>imageWithContentsOfFile:</code>加载图片。在使用的时候也很正常，但是有一天发现某张图加载不出来了。检查资源文件，只有2x的图（又是一个偷懒的程序员。。。很不建议这么玩，虽然只有2x的图，在所有屏幕都能显示，但是会造成图片的压缩与放大，每个细节都很重要！！！），如果加上1x的图就可以加载出来了。<br>经过调试发现问题就出在<code>pathForResource:ofType</code>上，这个函数是精确匹配调用者输入的文件名，不会自动识别文件名后面的<code>@2x</code>。修改后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (UIImage *)imageWithName:(NSString *)name type:(NSString *)type inBundle:(NSString *)bundle &#123;</span><br><span class="line">    NSString *imageBundlePath = [[NSBundle mainBundle] pathForResource:bundle ofType:@&quot;bundle&quot;];</span><br><span class="line">    NSBundle *imageBundle = [NSBundle bundleWithPath:imageBundlePath];</span><br><span class="line">    NSString *imageFullName = [name stringByAppendingPathExtension:type];</span><br><span class="line">    NSString *imagePath = [[imageBundle resourcePath] stringByAppendingPathComponent:imageFullName];</span><br><span class="line">    UIImage *image = [UIImage imageWithContentsOfFile:imagePath];</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要讲imageNamed与imageWithContentsOfFile的差异，需要注意的点，与实战中遇到的坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好久没
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正则表达式笔记</title>
    <link href="http://crmo.github.io/2016/11/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://crmo.github.io/2016/11/20/正则表达式笔记/</id>
    <published>2016-11-20T15:44:53.000Z</published>
    <updated>2016-11-20T15:45:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正则表达式（regular expression）描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的字串做替换或者从某个串中取出符合某个条件的字串等。</p></blockquote><p>正则表达式在线测试：<br><a href="http://www.regexpal.com/" target="_blank" rel="noopener">http://www.regexpal.com/</a></p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>常用元字符：</p><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">匹配除换行符以外的任意字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配字母或数字或下划线或汉字</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配数字</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配空格</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配单词的开始或结束</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符串的开始，如果是处理多行，意义变成行开始处</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符串的结束，如果是处理多行，意义变成行结束处</td></tr></tbody></table><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>常用限定符：</p><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">*前面的内容重复任意次</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">+前面的内容重复一次或者多次</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">重复零次或一次</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">重复n次</td></tr><tr><td style="text-align:center">{n, }</td><td style="text-align:center">重复次数大于等于n</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">重复次数大于等于n小于等于m</td></tr></tbody></table><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>[auiou] 匹配任何一个英文元音字母<br>[.?!] 匹配标点符号（.  ?   !）</p><h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">\W</td><td style="text-align:center">匹配任意不是字母、数字、下划线、汉字的字符</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">匹配任意不是空白符的字符</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">匹配任意非数字的字符</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:center">匹配不是单词开头或结束的位置</td></tr><tr><td style="text-align:center">[^x]</td><td style="text-align:center">匹配除了x以外的任意字符</td></tr><tr><td style="text-align:center">[^abcd]</td><td style="text-align:center">匹配除了abcd以外的任意字符</td></tr></tbody></table><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">说明　</th></tr></thead><tbody><tr><td style="text-align:center">(exp)</td><td style="text-align:center">匹配exp，并捕获文本到自动命名组中</td></tr><tr><td style="text-align:center"><code>(?&lt;name&gt;exp)</code></td><td style="text-align:center">匹配exp,并捕获文本到名称为name的组里，也可以写成(?`name`exp)</td></tr><tr><td style="text-align:center">(?:exp)</td><td style="text-align:center">匹配exp，不捕获匹配的文本，也不给次分组分配组号</td></tr><tr><td style="text-align:center">(?=exp)</td><td style="text-align:center">匹配exp前面的位置</td></tr><tr><td style="text-align:center">(?&lt;=exp)</td><td style="text-align:center">匹配exp后面的位置</td></tr><tr><td style="text-align:center">(?!exp)</td><td style="text-align:center">匹配后面跟的不是exp的位置</td></tr><tr><td style="text-align:center">(?&lt;!exp)</td><td style="text-align:center">匹配前面不是exp的位置</td></tr><tr><td style="text-align:center">(?#comment)</td><td style="text-align:center">注释</td></tr></tbody></table><h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>通常重复限定符的行为是<strong>匹配尽可能多</strong>的字符，在限定符后面加<code>?</code>使之成为惰性限定符，例如<code>*?</code>的含义为<strong>重复任意次数，但是尽可能少</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;正则表达式（regular expression）描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的字串做替换或者从某个串中取出符合某个条件的字串等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正则表达式在线测试：&lt;br&gt;&lt;a
      
    
    </summary>
    
    
      <category term="正则表达式" scheme="http://crmo.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Golang编码规范</title>
    <link href="http://crmo.github.io/2016/11/20/Golang%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://crmo.github.io/2016/11/20/Golang编码规范/</id>
    <published>2016-11-20T14:33:54.000Z</published>
    <updated>2016-11-20T15:46:40.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>gofmt</p><p>大部分的格式问题可以通过gofmt解决，gofmt自动格式化代码，保证所有的go代码与官方推荐的格式保持一致，于是所有格式有关问题，都以gofmt的结果为准。</p></li><li><p>行长</p></li></ul><p>一行最长不超过80个字符，超过的使用换行展示，尽量保持格式优雅。</p><ul><li><p>注释</p><p>在编码阶段应该同步写好变量、函数、包的注释，最后可以利用godoc导出文档。注释必须是完整的句子，句子的结尾应该用句号作为结尾（英文句号）。注释推荐用英文，可以在写代码过程中锻炼英文的阅读和书写能力。而且用英文不会出现各种编码的问题。<br>每个包都应该有一个包注释，一个位于package子句之前的块注释或行注释。包如果有多个go文件，只需要出现在一个go文件中即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ping包实现了常用的ping相关的函数</span><br><span class="line">package ping</span><br></pre></td></tr></table></figure></li></ul><p>导出函数注释，第一条语句应该为一条概括语句，并且使用被声明的名字作为开头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 求a和b的和，返回sum。</span><br><span class="line">func Myfunction(sum int) (a, b int) &#123;</span><br></pre></td></tr></table></figure><ul><li><p>命名</p><ul><li>需要注释来补充的命名就不算是好命名。<ul><li>使用可搜索的名称：单字母名称和数字常量很难从一大堆文字中搜索出来。单字母名称仅适用于短方法中的本地变量，名称长短应与其作用域相对应。若变量或常量可能在代码中多处使用，则应赋其以便于搜索的名称。</li><li>做有意义的区分：Product和ProductInfo和ProductData没有区别，NameString和Name没有区别，要区分名称，就要以读者能鉴别不同之处的方式来区分 。</li></ul></li><li>函数命名规则：驼峰式命名，名字可以长但是得把功能，必要的参数描述清楚，函数名名应当是动词或动词短语，如postPayment、deletePage、save。并依Javabean标准加上get、set、is前缀。例如：xxx + With + 需要的参数名 + And + 需要的参数名 + …..</li><li>结构体命名规则：结构体名应该是名词或名词短语，如Custome、WikiPage、Account、AddressParser，避免使用Manager、Processor、Data、Info、这样的类名，类名不应当是动词。<ul><li>包名命名规则：包名应该为小写单词，不要使用下划线或者混合大小写。</li><li>接口命名规则：单个函数的接口名以”er”作为后缀，如Reader,Writer。接口的实现则去掉“er”。</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">        Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个函数的接口名综合两个函数名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type WriteFlusher interface &#123;</span><br><span class="line">    Write([]byte) (int, error)</span><br><span class="line">    Flush() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 三个以上函数的接口名，抽象这个接口的功能，类似于结构体名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Car interface &#123;</span><br><span class="line">    Start([]byte)</span><br><span class="line">    Stop() error</span><br><span class="line">    Recover()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>常量</li></ul><p>常量均需使用全部大写字母组成，并使用下划线分词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const APP_VER = &quot;1.0&quot;</span><br></pre></td></tr></table></figure><p>如果是枚举类型的常量，需要先创建相应类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Scheme string</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    HTTP  Scheme = &quot;http&quot;</span><br><span class="line">    HTTPS Scheme = &quot;https&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果模块的功能较为复杂、常量名称容易混淆的情况下，为了更好地区分枚举类型，可以使用完整的前缀：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type PullRequestStatus int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    PULL_REQUEST_STATUS_CONFLICT PullRequestStatus = iota</span><br><span class="line">    PULL_REQUEST_STATUS_CHECKING</span><br><span class="line">    PULL_REQUEST_STATUS_MERGEABLE</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p>变量</p><p>变量命名基本上遵循相应的英文表达或简写,在相对简单的环境（对象数量少、针对性强）中，可以将一些名称由完整单词简写为单个字母，例如：</p><ul><li>user 可以简写为 u</li><li>userID 可以简写 uid<br>若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头：</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var isExist bool</span><br><span class="line">var hasConflict bool</span><br><span class="line">var canManage bool</span><br><span class="line">var allowGitHook bool</span><br></pre></td></tr></table></figure><ul><li><p>变量命名惯例</p><p>变量名称一般遵循驼峰法，但遇到特有名词时，需要遵循以下规则：</p><ul><li>如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient</li><li>其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID</li><li>错误示例：UrlArray，应该写成urlArray或者URLArray</li></ul><p>下面列举了一些常见的特有名词：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// A GonicMapper that contains a list of common initialisms taken from golang/lint</span><br><span class="line">var LintGonicMapper = GonicMapper&#123;</span><br><span class="line">    &quot;API&quot;:   true,</span><br><span class="line">    &quot;ASCII&quot;: true,</span><br><span class="line">    &quot;CPU&quot;:   true,</span><br><span class="line">    &quot;CSS&quot;:   true,</span><br><span class="line">    &quot;DNS&quot;:   true,</span><br><span class="line">    &quot;EOF&quot;:   true,</span><br><span class="line">    &quot;GUID&quot;:  true,</span><br><span class="line">    &quot;HTML&quot;:  true,</span><br><span class="line">    &quot;HTTP&quot;:  true,</span><br><span class="line">    &quot;HTTPS&quot;: true,</span><br><span class="line">    &quot;ID&quot;:    true,</span><br><span class="line">    &quot;IP&quot;:    true,</span><br><span class="line">    &quot;JSON&quot;:  true,</span><br><span class="line">    &quot;LHS&quot;:   true,</span><br><span class="line">    &quot;QPS&quot;:   true,</span><br><span class="line">    &quot;RAM&quot;:   true,</span><br><span class="line">    &quot;RHS&quot;:   true,</span><br><span class="line">    &quot;RPC&quot;:   true,</span><br><span class="line">    &quot;SLA&quot;:   true,</span><br><span class="line">    &quot;SMTP&quot;:  true,</span><br><span class="line">    &quot;SSH&quot;:   true,</span><br><span class="line">    &quot;TLS&quot;:   true,</span><br><span class="line">    &quot;TTL&quot;:   true,</span><br><span class="line">    &quot;UI&quot;:    true,</span><br><span class="line">    &quot;UID&quot;:   true,</span><br><span class="line">    &quot;UUID&quot;:  true,</span><br><span class="line">    &quot;URI&quot;:   true,</span><br><span class="line">    &quot;URL&quot;:   true,</span><br><span class="line">    &quot;UTF8&quot;:  true,</span><br><span class="line">    &quot;VM&quot;:    true,</span><br><span class="line">    &quot;XML&quot;:   true,</span><br><span class="line">    &quot;XSRF&quot;:  true,</span><br><span class="line">    &quot;XSS&quot;:   true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>struct规范</li></ul><p>struct申明和初始化格式采用多行：</p><p>定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type User struct&#123;</span><br><span class="line">    Username  string</span><br><span class="line">    Email     string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u := User&#123;</span><br><span class="line">    Username: &quot;test&quot;,</span><br><span class="line">    Email:    &quot;test@gmail.com&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>控制结构</p><p>if<br>if接受初始化语句，约定如下方式建立局部变量</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if err := file.Chmod(0664); err != nil &#123;</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> for<br>采用短声明建立局部变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := 0</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> return<br>尽早return：一旦有错误发生，马上返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line">d, err := f.Stat()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    f.Close()</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line">codeUsing(f, d)</span><br></pre></td></tr></table></figure><ul><li><p>错误处理</p><ul><li>error作为函数的值返回,必须对error进行处理</li><li>错误描述如果是英文必须为小写，不需要标点结尾</li><li>采用独立的错误流进行处理</li></ul><p>不要采用下面的处理错误写法</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if err != nil &#123;</span><br><span class="line">    // error handling</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // normal code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 采用下面的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if err != nil &#123;</span><br><span class="line">    // error handling</span><br><span class="line">    return // or continue, etc.</span><br><span class="line">&#125;</span><br><span class="line">// normal code</span><br></pre></td></tr></table></figure><p> 使用函数的返回值时，则采用下面的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x, err := f()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    // error handling</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">// use x</span><br></pre></td></tr></table></figure><ul><li>panic</li></ul><p>尽量不要使用panic，除非你知道你在做什么</p><ul><li>import</li></ul><p>对import的包进行分组管理，用换行符分割，而且标准库作为分组的第一组。如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line"></span><br><span class="line">    &quot;kmg/a&quot;</span><br><span class="line">    &quot;kmg/b&quot;</span><br><span class="line"></span><br><span class="line">    &quot;code.google.com/a&quot;</span><br><span class="line">    &quot;github.com/b&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> 在项目中不要使用相对路径引入包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误示例</span><br><span class="line">import “../net”</span><br><span class="line"></span><br><span class="line">// 正确的做法</span><br><span class="line">import “github.com/repo/proj/src/net”</span><br></pre></td></tr></table></figure><p>goimports会自动帮你格式化</p><ul><li><p>参数传递</p><ul><li>对于少量数据，不要传递指针</li><li>对于大量数据的struct可以考虑使用指针</li><li>传入参数是map，slice，chan不要传递指针，因为map，slice，chan是引用类型，不需要传递指针的指针</li></ul></li><li><p>单元测试</p></li></ul><p>单元测试文件名命名规范为 example_test.go<br>测试用例的函数名称必须以 Test 开头，例如：TestExample</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;gofmt&lt;/p&gt;
&lt;p&gt;大部分的格式问题可以通过gofmt解决，gofmt自动格式化代码，保证所有的go代码与官方推荐的格式保持一致，于是所有格式有关问题，都以gofmt的结果为准。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行长&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
      <category term="golang" scheme="http://crmo.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="http://crmo.github.io/tags/golang/"/>
    
  </entry>
  
</feed>
