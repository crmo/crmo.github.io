<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CR.MO`s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://crmo.github.io/"/>
  <updated>2018-08-03T07:28:47.235Z</updated>
  <id>http://crmo.github.io/</id>
  
  <author>
    <name>CR.MO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>dispatch_sync死锁问题</title>
    <link href="http://crmo.github.io/2018/08/03/dispatch_sync%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <id>http://crmo.github.io/2018/08/03/dispatch_sync死锁问题/</id>
    <published>2018-08-02T16:00:00.000Z</published>
    <updated>2018-08-03T07:28:47.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>使用<code>dispatch_sync</code>的时候要小心谨慎，稍不注意就会导致死锁问题，先看两个典型的案例：</p><p>案例一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)deadlock1 &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)deadlock2 &#123;</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_sync(queue1, ^&#123;</span><br><span class="line">        dispatch_sync(queue2, ^&#123;</span><br><span class="line">            dispatch_sync(queue1, ^&#123;</span><br><span class="line">                NSLog(@&quot;&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个案例死锁的原因都是同一个串行队列的任务相互等待。 当然实际工程中遇到的死锁问题会更加复杂，难以分析。</p><h2 id="典型误区"><a href="#典型误区" class="headerlink" title="典型误区"></a>典型误区</h2><p>在阅读相关书籍、博客都提到了一个方法<code>dispatch_get_current_queue()</code>，通过这个方法可以获取到当前队列，于是有人就用它来解决死锁问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)safeSync:(void(^)())block &#123;</span><br><span class="line">    if (!block) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dispatch_get_current_queue() == queue) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            block();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一眼看起来天衣无缝，对于案例一的确可以完美解决，但是对于案例二这种对队列的情况就判断不了。难怪苹果在iOS6就注释了这个方法。</p><hr><p>推荐阅读：</p><p><a href="https://www.objc.io/issues/2-concurrency/thread-safe-class-design/#pitfalls-of-gcd" target="_blank" rel="noopener">Thread-Safe Class Design</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;dispatch_sync&lt;/code&gt;的时候要小心谨慎，稍不注意就会导致死锁问题，先看两个典型的案例：&lt;/
      
    
    </summary>
    
    
      <category term="知识小结" scheme="http://crmo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UIWebView获取详细浏览记录</title>
    <link href="http://crmo.github.io/2018/08/01/UIWebView%E8%8E%B7%E5%8F%96history/"/>
    <id>http://crmo.github.io/2018/08/01/UIWebView获取history/</id>
    <published>2018-07-31T16:00:00.000Z</published>
    <updated>2018-08-06T08:49:24.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所用方法会使用到苹果私有API，上架APP Store请谨慎使用。</p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>获取<code>UIWebView</code>的前进后退的浏览记录，举个例子，比如从A-&gt;B-&gt;C-&gt;B，此时B上一页是A，下一页是C，需要获取A、C的URL信息。</p><blockquote><p>WKWebView暴露了这个属性，<code>WKBackForwardList *backForwardList</code>。可以很容易的取到，无奈项目还是使用的<code>UIWebView</code>，于是有了后面的探索。</p></blockquote><p>首先在<code>UIWebView</code>提供的API里找，相关的API只有<code>canGoBack</code>和<code>canGoForward</code>，命名很直观，是否可以后退和前进，这条路走不通。<br>想到是否可以通过JS的Window.history获取到，查了下API，唯一一个有点像的<code>length</code>属性，智能取到浏览记录中的所有URL的数量，不区分前后，比如在上面提到的例子中，在B页面取到的<code>length</code>是3，而且不能取出具体的URL。</p><p><img src="/images/15325235986699.jpg" alt="15325235986699"></p><p>无奈只有上源码了，我下载的是<a href="https://opensource.apple.com/release/ios-110.html" target="_blank" rel="noopener">“WebKit-7604.1.38.0.7”和“WebCore-7604.1.38.0.7”</a>。</p><h2 id="Window-History-length实现本质"><a href="#Window-History-length实现本质" class="headerlink" title="Window.History.length实现本质"></a>Window.History.length实现本质</h2><p>在WebCore里面找到了JS方法<code>Window.History.length</code>实现的本质，上代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebCore History.cpp</span></span><br><span class="line"><span class="keyword">unsigned</span> History::length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_frame)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span>* page = m_frame-&gt;page();</span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> page-&gt;backForward().count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebCore BackForwardController.cpp</span></span><br><span class="line"><span class="keyword">int</span> BackForwardController::count() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// count = 当前页之前的页面总数 + 当前页之后的页面总数 + 1</span></span><br><span class="line">    <span class="keyword">return</span> m_client-&gt;backListCount() + <span class="number">1</span> + m_client-&gt;forwardListCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>WebCore</code>里面<code>backListCount()</code>、<code>forwardListCount()</code>定义是虚函数，具体实现在<code>WebKit</code>可以找到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebKit BackForwardList.mm</span></span><br><span class="line"><span class="keyword">int</span> BackForwardList::backListCount()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_current == NoCurrentItemIndex ? <span class="number">0</span> : m_current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BackForwardList::forwardListCount()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_current == NoCurrentItemIndex ? <span class="number">0</span> : (<span class="keyword">int</span>)m_entries.size() - (m_current + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个方法我们需要关注一下，后面会用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebKit BackForwardList.mm</span></span><br><span class="line"><span class="comment">// 获取之前最多几条历史记录</span></span><br><span class="line"><span class="keyword">void</span> BackForwardList::backListWithLimit(<span class="keyword">int</span> limit, Vector&lt;Ref&lt;HistoryItem&gt;&gt;&amp; <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span>.clear();</span><br><span class="line">    <span class="keyword">if</span> (m_current != NoCurrentItemIndex) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> first = <span class="built_in">std</span>::max(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(m_current) - limit, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (; first &lt; m_current; ++first)</span><br><span class="line">            <span class="built_in">list</span>.append(m_entries[first].get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取History"><a href="#获取History" class="headerlink" title="获取History"></a>获取History</h2><p>在<code>WebView</code>的中，我们可以找到<code>WebBackForwardList</code>的定义。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    @property backForwardList</span></span><br><span class="line"><span class="comment">    @abstract The backforward list for this WebView.</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) WebBackForwardList *backForwardList;</span><br></pre></td></tr></table></figure><p><code>WebBackForwardList</code>是对<code>BackForwardList</code>的一层封装，阅读一下它的.h文件，不难找到获取浏览记录的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">    @method backListWithLimit:</span><br><span class="line">    @abstract Returns a portion of the list before the current entry.</span><br><span class="line">    @param limit A cap on the size of the array returned.</span><br><span class="line">    @result An array of items before the current entry, or nil if there are none.  The entries are in the order that they were originally visited.</span><br><span class="line">*/</span><br><span class="line">- (NSArray *)backListWithLimit:(int)limit;</span><br></pre></td></tr></table></figure><p>上面的方法可以获取到一个<code>WebHistoryItem</code>数组，<code>WebHistoryItem</code>保存了浏览记录的详细信息。</p><h2 id="获取WebBackForwardList"><a href="#获取WebBackForwardList" class="headerlink" title="获取WebBackForwardList"></a>获取WebBackForwardList</h2><p><code>UIWebView</code>没有暴露获取<code>WebView</code>或者<code>WebBackForwardList</code>的方法，但是我们可以用KVO曲线救国，于是我们需要找到<code>WebView</code>的私有变量名。用runtime可以做到，为了简化这个过程，我写了一个工具类来辅助搜索，具体可以看<a href="https://crmo.github.io/2018/07/31/runtime实现私有变量搜索/">这篇文章-runtime实现私有变量搜索</a>。简单来说就是用runtime获取类成员变量列表，然后用BFS来搜索我们要找的类。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以UIWebView为根节点，BFS搜索WebView</span></span><br><span class="line">[BFSSearchClass searchClass:<span class="string">@"WebView"</span> inClass:<span class="string">@"UIWebView"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索结果如下</span></span><br><span class="line"><span class="comment">// Class Name：类名，Ivar Name：变量名，Super Class：父类</span></span><br><span class="line">Class Name:【WebView】,Ivar Name:【_webView】</span><br><span class="line">Class Name:【<span class="built_in">UIWebDocumentView</span>】,Ivar Name:【Super Class】</span><br><span class="line">Class Name:【<span class="built_in">UIWebBrowserView</span>】,Ivar Name:【browserView】</span><br><span class="line">Class Name:【<span class="built_in">UIWebViewInternal</span>】,Ivar Name:【_internal】</span><br><span class="line">Root Class:<span class="built_in">UIWebView</span></span><br></pre></td></tr></table></figure><p>有了上面的结论，我们就可以用KVC来获取到浏览记录了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printWebViewHistory:(<span class="built_in">UIWebView</span> *)aWebView &#123;</span><br><span class="line">    <span class="keyword">id</span> webviewInternal = [aWebView valueForKey:<span class="string">@"_internal"</span>];</span><br><span class="line">    <span class="keyword">id</span> browserView = [webviewInternal valueForKey:<span class="string">@"browserView"</span>];</span><br><span class="line">    <span class="keyword">id</span> webView = [browserView valueForKey:<span class="string">@"_webView"</span>];</span><br><span class="line">    <span class="keyword">id</span> backForwardList = [webView performSelector:<span class="keyword">@selector</span>(backForwardList)];</span><br><span class="line">    <span class="comment">// WebHistoryItem存储的具体某条浏览记录信息</span></span><br><span class="line">    <span class="built_in">NSArray</span> *historyItems = [backForwardList performSelector:<span class="keyword">@selector</span>(backListWithLimit:) withObject:@<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> item <span class="keyword">in</span> historyItems) &#123;</span><br><span class="line">        <span class="comment">// 获取浏览记录的url </span></span><br><span class="line">        <span class="built_in">NSString</span> *url = [item performSelector:<span class="keyword">@selector</span>(URLString)];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文所用方法会使用到苹果私有API，上架APP Store请谨慎使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="知识小结" scheme="http://crmo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>runtime实现私有变量搜索</title>
    <link href="http://crmo.github.io/2018/07/31/runtime%E5%AE%9E%E7%8E%B0%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E6%90%9C%E7%B4%A2/"/>
    <id>http://crmo.github.io/2018/07/31/runtime实现私有变量搜索/</id>
    <published>2018-07-30T16:00:00.000Z</published>
    <updated>2018-08-03T07:28:45.847Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文Demo(<a href="https://github.com/crmo/BFSSearchClass)地址" target="_blank" rel="noopener">https://github.com/crmo/BFSSearchClass)地址</a></p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在开发功能时，为了满足产品变态的需求，难免有系统类提供的API不够用的时候，这时候私有变量就可以发挥它光和热了。怎么通过一个类，一层一层的找到特定类型的私有成员变量？<br>受益于Objective-C的动态语言特性，就算苹果<code>UIKit</code>不开源，但是在runtime面前，类的结构还是暴露无遗。我的思路是逐层手动打印成员变量信息，如果是UI控件可以用Reveal来加快进度，配合KVC机制，获取私有变量就如同探囊取物一般。<br>在多次遇到这个问题后，我决定实现一个工具类来简化这个过程，毕竟能自动化的就尽量不要手动。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>搜索范围：成员变量、属性</p></blockquote><p>关键步骤如下：</p><ol><li>runtime中的方法<code>class_copyIvarList()</code>，可以取出类的所有成员变量结构体<code>Ivar</code>。</li><li>从Ivar中可以取出成员变量类型<code>Type Encodings</code></li><li>用<code>Type Encodings</code>获取到类名</li><li>遍历类的所有<code>Ivar</code>，获取到类的所有成员变量的类信息</li></ol><p>但是问题没这么简单，比如ClassA是ClassB的成员变量，ClassB是ClassC的成员变量，想通过ClassC找到ClassA，需要向下找两层才能找到，还要考虑父类的情况。<br>整个搜索过程就是一颗以待搜索类为根的树，可以用BFS来搜索，步骤如下（如图，数字是搜索顺序）：</p><ol><li>从根节点开始搜索</li><li>首先遍历当前节点的父类，加入搜索队列</li><li>再取出当前节点的所有成员变量，加入搜索队列</li></ol><p><img src="/images/QQ20180731-202956@2x.png" alt="QQ20180731-202956@2x"></p><h2 id="如何从Ivar中获取Class"><a href="#如何从Ivar中获取Class" class="headerlink" title="如何从Ivar中获取Class"></a>如何从Ivar中获取Class</h2><p>Ivar中不能直接取出对应类名，只能取出<code>Type Encodings</code>，间接可以得到类名。从<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">官方文档</a>截了张图，可以清晰的看到Code的定义。</p><p><img src="/images/15329163411347.jpg" alt="15329163411347"></p><p>基本数据类型、id类型、集合类型、结构体等类型就不需要搜索了，可以过滤掉。我们只搜索两种类型</p><ol><li>类，例如<code>@&quot;UIWebViewInternal&quot;</code></li><li>代理，例如<code>@&quot;&lt;UIViewControllerTransitioningDelegate&gt;&quot;</code></li></ol><h2 id="优化及存在问题"><a href="#优化及存在问题" class="headerlink" title="优化及存在问题"></a>优化及存在问题</h2><ol><li>可以用一个<code>NSMutableSet</code>存储已经搜索过的类，每次搜索前判断一下是否已经搜索过</li><li>记录搜索次数，可以限制搜索次数。</li><li>对于定义为id类型、集合类的成员变量没有做处理，可以继续深入遍历</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文Demo(&lt;a href=&quot;https://github.com/crmo/BFSSearchClass)地址&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/crmo/BFSSearchC
      
    
    </summary>
    
    
      <category term="知识小结" scheme="http://crmo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS横竖屏总结</title>
    <link href="http://crmo.github.io/2018/07/23/iOS%E6%A8%AA%E7%AB%96%E5%B1%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://crmo.github.io/2018/07/23/iOS横竖屏总结/</id>
    <published>2018-07-22T16:00:00.000Z</published>
    <updated>2018-08-03T07:28:45.361Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>Auto Layout</code>来进行布局就不用自己去监听横竖屏事件了，只需要绘制多套布局即可。但是项目有很多页面是自己手动计算的，于是只有想办法再旋转屏幕时重新布局。</p><h2 id="相关枚举"><a href="#相关枚举" class="headerlink" title="相关枚举"></a>相关枚举</h2><p>屏幕方向有3个相关枚举，界面方向<code>UIInterfaceOrientation</code>，设备方向<code>UIDeviceOrientation</code>，支持旋转方向<code>UIInterfaceOrientationMask</code>。</p><blockquote><p>注意UIInterfaceOrientation与UIDeviceOrientation左右方向是相反的</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIInterfaceOrientation</span>) &#123;</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationUnknown</span>            = <span class="built_in">UIDeviceOrientationUnknown</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationPortrait</span>           = <span class="built_in">UIDeviceOrientationPortrait</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationPortraitUpsideDown</span> = <span class="built_in">UIDeviceOrientationPortraitUpsideDown</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationLandscapeLeft</span>      = <span class="built_in">UIDeviceOrientationLandscapeRight</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationLandscapeRight</span>     = <span class="built_in">UIDeviceOrientationLandscapeLeft</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIInterfaceOrientationMask</span>) &#123;</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskPortrait</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationPortrait</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationLandscapeLeft</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationLandscapeRight</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskPortraitUpsideDown</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationPortraitUpsideDown</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscape</span> = (<span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskAll</span> = (<span class="built_in">UIInterfaceOrientationMaskPortrait</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span> | <span class="built_in">UIInterfaceOrientationMaskPortraitUpsideDown</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskAllButUpsideDown</span> = (<span class="built_in">UIInterfaceOrientationMaskPortrait</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="横竖屏控制"><a href="#横竖屏控制" class="headerlink" title="横竖屏控制"></a>横竖屏控制</h2><p>控制界面横竖屏切换有3个重要的点，最终结果以这三个地方的值取交集。</p><p><strong>1.info.plist全局控制</strong></p><p>可以在<code>General-&gt;Deplyment Info</code>界面上勾选</p><p><img src="/images/15320065885480.jpg" alt="15320065885480"></p><p> info.plist文件中配置也是一样的，两边会同步变更</p><p><img src="/images/15320512384395.jpg" alt="15320512384395"></p><p><strong>2.AppDelegate中根据不同Window控制</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppDelegate</span></span><br><span class="line">- (<span class="built_in">UIInterfaceOrientationMask</span>)application:(<span class="built_in">UIApplication</span> *)application supportedInterfaceOrientationsForWindow:(<span class="built_in">UIWindow</span> *)window &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskPortrait</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.在ViewController中控制当前页面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// UIViewController</span><br><span class="line">- (BOOL)shouldAutorotate &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</span><br><span class="line">    return UIInterfaceOrientationMaskLandscapeLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，交集不能为空，否则会导致crash</p></blockquote><p>*** Terminating app due to uncaught exception ‘UIApplicationInvalidInterfaceOrientation’, reason: ‘Supported orientations has no common orientation with the application, and [ViewController<br>shouldAutorotate] is returning YES’</p><p><img src="/images/15320548897266-1.jpg" alt="15320548897266"></p><h2 id="旋转事件监听"><a href="#旋转事件监听" class="headerlink" title="旋转事件监听"></a>旋转事件监听</h2><h3 id="旋转事件传递过程"><a href="#旋转事件传递过程" class="headerlink" title="旋转事件传递过程"></a>旋转事件传递过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">op0=&gt;operation: __CFRunLoopDoSources0</span><br><span class="line">op1=&gt;operation: UIDevice</span><br><span class="line">op2=&gt;operation: UIWindow</span><br><span class="line">op3=&gt;operation: UIViewController</span><br><span class="line">op4=&gt;operation: UIView</span><br><span class="line"></span><br><span class="line">op1-&gt;op2-&gt;op3-&gt;op4</span><br></pre></td></tr></table></figure><h3 id="屏幕旋转相关事件"><a href="#屏幕旋转相关事件" class="headerlink" title="屏幕旋转相关事件"></a>屏幕旋转相关事件</h3><p>viewWillTransitionToSize:withTransitionCoordinator:</p><ul><li>ViewController被父容器变更size时调用（例如window旋转时调用root view controller的该方法）</li><li>如果重载该方法，需要调用super传递事件给子ViewController</li><li>这个方法是最关键的，可以在该方法中对界面进行重新布局</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator</span><br><span class="line">&#123;</span><br><span class="line">    // coordinator用来处理转换动画</span><br><span class="line">    [coordinator animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context)</span><br><span class="line">     &#123;</span><br><span class="line">         // 开始旋转</span><br><span class="line">     &#125; completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context)</span><br><span class="line">     &#123;</span><br><span class="line">         // 旋转结束</span><br><span class="line">     &#125;];</span><br><span class="line">     // 记得调用super</span><br><span class="line">    [super viewWillTransitionToSize:size withTransitionCoordinator:coordinator];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UIApplicationWillChangeStatusBarOrientationNotification </p><ul><li>状态栏将要旋转，这个时候取view的frame还是旋转之前的</li><li>NSNotification中用key <code>UIApplicationStatusBarOrientationUserInfoKey</code>可以取到将要旋转到的方向。</li></ul><p>UIApplicationDidChangeStatusBarOrientationNotification </p><ul><li>状态栏已经旋转，这个时候取view的frame是旋转之后的</li><li>NSNotification中用key <code>UIApplicationStatusBarOrientationUserInfoKey</code>可以取到旋转之前的方向。</li></ul><p>UIDeviceOrientationDidChangeNotification </p><ul><li>设备方向变更，在收到通知时取view的frame是旋转之后的。</li><li>在手机上将旋转屏幕锁定之后，设备方向变更之后收不到该通知</li><li>在代码里面限制设备旋转方向，设备方向变更后依然能收到该通知</li></ul><p>调用顺序如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 旋转屏幕</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op1=&gt;operation: viewWillTransitionToSize:withTransitionCoordinator:</span><br><span class="line">op2=&gt;operation: UIApplicationWillChangeStatusBarOrientationNotification</span><br><span class="line">op3=&gt;operation: UIApplicationDidChangeStatusBarOrientationNotification</span><br><span class="line">op4=&gt;operation: viewWillLayoutSubviews</span><br><span class="line">op5=&gt;operation: viewDidLayoutSubviews</span><br><span class="line">op6=&gt;operation: UIDeviceOrientationDidChangeNotification</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;e</span><br></pre></td></tr></table></figure><h2 id="自定义Window的旋转事件"><a href="#自定义Window的旋转事件" class="headerlink" title="自定义Window的旋转事件"></a>自定义Window的旋转事件</h2><p>如果想要在自定义Window的子View收到屏幕旋转通知，要设置UIWindow的rootViewController，然后把所有子view都加到rootViewController，系统会处理横竖屏事件。这里我还遇到一个坑<a href="https://crmo.github.io/2018/07/19/记一个实现UIWindow子类的小坑/">记一个实现UIWindow子类的小坑</a>。</p><hr><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://satanwoo.github.io/2016/09/17/uiwindow-iOS/" target="_blank" rel="noopener">https://satanwoo.github.io/2016/09/17/uiwindow-iOS/</a><br><a href="https://tbd.ink/2017/07/05/iOS/17070501.iOS屏幕旋转知识点以及实现/index/" target="_blank" rel="noopener">iOS屏幕旋转知识点以及实现</a><br><a href="https://imtangqi.com/2017/03/08/handle-orientation-changes-one/" target="_blank" rel="noopener">iOS 屏幕旋转的那些事（一）</a><br><a href="https://satanwoo.github.io/2016/09/17/uiwindow-iOS/" target="_blank" rel="noopener">浅谈iOS的多Window处理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用&lt;code&gt;Auto Layout&lt;/code&gt;来进行布局就不用自己去监听横竖屏事件了，只需要绘制多套布局即可。但是项目有很多页面是自己手动计算的，于是只有想办法再旋转屏幕时重新布局。&lt;/p&gt;
&lt;h2 id=&quot;相关枚举&quot;&gt;&lt;a href=&quot;#相关枚举&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="知识小结" scheme="http://crmo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>记一个实现UIWindow子类的小坑</title>
    <link href="http://crmo.github.io/2018/07/19/%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0UIWindow%E5%AD%90%E7%B1%BB%E7%9A%84%E5%B0%8F%E5%9D%91/"/>
    <id>http://crmo.github.io/2018/07/19/记一个实现UIWindow子类的小坑/</id>
    <published>2018-07-18T16:00:00.000Z</published>
    <updated>2018-08-03T07:29:54.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>项目中为了实现一个全局遮罩界面，使用了一个UIWindow的子类<code>MyWindow</code>，<code>MyWindow</code>为了实现回调定义了代理<code>MyWindowDelegate</code>。代码大致如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MyWindowDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyWindow</span> : <span class="title">UIWindow</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>)<span class="keyword">id</span>&lt;MyWindowDelegate&gt; delegate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyWindow</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.windowLevel = <span class="built_in">UIWindowLevelNormal</span>;</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        <span class="built_in">UIViewController</span> *vc = [[ViewController2 alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.rootViewController = vc;</span><br><span class="line">        <span class="keyword">self</span>.hidden = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后在实现界面横屏时，发现整个UIWindow不响应横竖屏事件。刚开始以为横竖屏设置被关闭了，查了各种资料，发现这种写法是没有问题的。设置UIWindow的rootViewController，然后把所有子view都加到rootViewController，系统会处理横竖屏问题。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>用Runtime把UIWindow的私有变量打出来，就发现问题了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printUIWindowIvars &#123;</span><br><span class="line">    Ivar *ivars = class_copyIvarList([<span class="built_in">UIWindow</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, ivar_getName(ivar));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看输出，发现有个私有变量<code>_delegate</code>。</p><p><img src="/images/15319834677166.jpg" alt="15319834677166"></p><p><code>MyWindow</code>的属性<code>delegate</code>覆盖了父类<code>UIWindow</code>的变量，导致横竖屏切换事件失效。在代理命名的时候一定要注意啊，<code>delegate</code>看来不是一个好的实践，应该加前缀区分避免覆盖父类的实现，特别是这种私有的变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;项目中为了实现一个全局遮罩界面，使用了一个UIWindow的子类&lt;code&gt;MyWindow&lt;/code&gt;，&lt;code&gt;My
      
    
    </summary>
    
    
      <category term="知识小结" scheme="http://crmo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>一个autoreleasepool的使用场景</title>
    <link href="http://crmo.github.io/2018/07/18/%E4%B8%80%E4%B8%AAautoreleasepool%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://crmo.github.io/2018/07/18/一个autoreleasepool的使用场景/</id>
    <published>2018-07-17T16:00:00.000Z</published>
    <updated>2018-08-03T07:29:13.417Z</updated>
    
    <content type="html"><![CDATA[<p>今天在学习大佬博客的时候看到一个问题，下面代码会有什么问题？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// largeNumber是一个很大的数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; largeNumber; i++) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"hello -%04d"</span>, i];</span><br><span class="line">    str = [str stringByAppendingString:<span class="string">@" - world"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始没看出什么问题，就是普通的循环，每次循环创建一个局部变量<code>NSString</code>。于是写了个Demo验证了下，在观察内存的时候发现了端倪，在循环过程中，内存不断飙升。</p><p><img src="/images/15318782609811.jpg" alt="15318782609811"></p><p>顿时明白了，原来问题的关键就是这个<code>largeNumber</code>，当循环此时很大时，就会创建大量的局部变量，而且得不到释放，于是内存就爆了。这时候就该<code>@autoreleasepool</code>上场了，优化后代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; largeNumber; i++) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"hello -%04d"</span>, i];</span><br><span class="line">        str = [str stringByAppendingString:<span class="string">@" - world"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看运行内存，可以看到非常平稳。</p><p><img src="/images/15318784002251.jpg" alt="15318784002251"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在学习大佬博客的时候看到一个问题，下面代码会有什么问题？&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br
      
    
    </summary>
    
    
      <category term="知识小结" scheme="http://crmo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UITabbar自定义Badge</title>
    <link href="http://crmo.github.io/2018/07/10/UITabbar%E8%87%AA%E5%AE%9A%E4%B9%89Badge/"/>
    <id>http://crmo.github.io/2018/07/10/UITabbar自定义Badge/</id>
    <published>2018-07-09T16:00:00.000Z</published>
    <updated>2018-08-03T07:29:12.314Z</updated>
    
    <content type="html"><![CDATA[<p>tabBarItem的Badge默认样式是带数字的，但是产品要求只要一个小红点，不需要数字，这就需要我们自定义Badge了。</p><p>用Reveal分析UITabBar，发现每个按钮是一个<code>UITabBarButton</code>，层级如下：</p><blockquote><p>-UITabBarButton<br>–UITabBarSwappableImageView // 图标<br>–UITabBarButtonLabel // 文字</p></blockquote><p>如何从<code>UITabBar</code>中找到对应index的<code>UITabBarButton</code>呢？我们断点调试下，可以看到可以直接从<code>UITabBar</code>中用KVC取出。</p><p><img src="/images/QQ20180711-174329.png" alt="QQ20180711-174329"></p><p>实现方案如下：</p><ul><li>用KVC找到UITabBarSwappableImageView，关键函数<code>__iconViewWithIndex</code></li><li>新建Badge，加到UITabBarSwappableImageView上</li><li>新建Badge的时候设置Tag，通过Tag来移除Badge</li></ul><p>上代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kBadgeViewTagBase = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITabBar</span> (<span class="title">badge</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示Badge</span></span><br><span class="line">- (<span class="keyword">void</span>)showBadgeOnItemIndex:(<span class="keyword">int</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="keyword">self</span>.items.count) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果之前添加过，直接设置hidden为NO</span></span><br><span class="line">    <span class="built_in">UIView</span> *icon = [<span class="keyword">self</span> __iconViewWithIndex:index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subView <span class="keyword">in</span> icon.subviews) &#123;</span><br><span class="line">        <span class="keyword">if</span> (subView.tag == kBadgeViewTagBase) &#123;</span><br><span class="line">            subView.hidden = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *badgeView = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    badgeView.tag = kBadgeViewTagBase;</span><br><span class="line">    badgeView.layer.cornerRadius = <span class="number">5</span>;</span><br><span class="line">    badgeView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    badgeView.frame = <span class="built_in">CGRectMake</span>(icon.frame.size.width - <span class="number">5</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">9</span>);</span><br><span class="line">    [icon addSubview:badgeView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏Badge</span></span><br><span class="line">- (<span class="keyword">void</span>)hideBadgeOnItemIndex:(<span class="keyword">int</span>)index &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *icon = [<span class="keyword">self</span> __iconViewWithIndex:index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subView <span class="keyword">in</span> icon.subviews) &#123;</span><br><span class="line">        <span class="keyword">if</span> (subView.tag == kBadgeViewTagBase) &#123;</span><br><span class="line">            subView.hidden = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取图标所在View</span></span><br><span class="line">- (<span class="built_in">UIView</span> *)__iconViewWithIndex:(<span class="keyword">int</span>)index &#123;</span><br><span class="line">    <span class="built_in">UITabBarItem</span> *item = <span class="keyword">self</span>.items[index];</span><br><span class="line">    <span class="built_in">UIView</span> *tabBarButton = [item valueForKey:<span class="string">@"_view"</span>];</span><br><span class="line">    <span class="built_in">UIView</span> *icon = [tabBarButton valueForKey:<span class="string">@"_info"</span>];</span><br><span class="line">    <span class="keyword">return</span> icon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tabBarItem的Badge默认样式是带数字的，但是产品要求只要一个小红点，不需要数字，这就需要我们自定义Badge了。&lt;/p&gt;
&lt;p&gt;用Reveal分析UITabBar，发现每个按钮是一个&lt;code&gt;UITabBarButton&lt;/code&gt;，层级如下：&lt;/p&gt;
&lt;b
      
    
    </summary>
    
    
      <category term="知识小结" scheme="http://crmo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>计算文字长度</title>
    <link href="http://crmo.github.io/2018/07/09/%E8%AE%A1%E7%AE%97%E6%96%87%E5%AD%97%E9%95%BF%E5%BA%A6/"/>
    <id>http://crmo.github.io/2018/07/09/计算文字长度/</id>
    <published>2018-07-08T16:00:00.000Z</published>
    <updated>2018-08-03T07:29:12.707Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://developer.apple.com/documentation/foundation/nsstring/1524729-boundingrectwithsize?language=occ" target="_blank" rel="noopener">官方文档</a></p></blockquote><h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSRect</span>)boundingRectWithSize:(<span class="built_in">NSSize</span>)size </span><br><span class="line">                       options:(<span class="built_in">NSStringDrawingOptions</span>)options </span><br><span class="line">                    attributes:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSAttributedStringKey</span>, <span class="keyword">id</span>&gt; *)attributes </span><br><span class="line">                       context:(<span class="built_in">NSStringDrawingContext</span> *)context;</span><br></pre></td></tr></table></figure><h2 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h2><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>绘制的限制size，计算出来的值不会超过这个大小。</p><h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><p>一些配置项。定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSStringDrawingOptions</span>) &#123;</span><br><span class="line">    <span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">// The specified origin is the line fragment origin, not the base line origin</span></span><br><span class="line">    <span class="built_in">NSStringDrawingUsesFontLeading</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">// Uses the font leading for calculating line heights</span></span><br><span class="line">    <span class="built_in">NSStringDrawingUsesDeviceMetrics</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">// Uses image glyph bounds instead of typographic bounds</span></span><br><span class="line">    <span class="built_in">NSStringDrawingTruncatesLastVisibleLine</span> <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">6</span>_0) = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">// Truncates and adds the ellipsis character to the last visible line if the text doesn't fit into the bounds specified. Ignored if NSStringDrawingUsesLineFragmentOrigin is not also set.</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">6</span>_0);</span><br></pre></td></tr></table></figure><p>实际测试使用<code>NSStringDrawingUsesLineFragmentOrigin|NSStringDrawingUsesFontLeading</code>可以满足需求，<code>NSStringDrawingUsesLineFragmentOrigin</code>是必须的，<code>NSStringDrawingUsesFontLeading</code>加不加在测试的时候没发现区别，但是在<a href="https://stackoverflow.com/questions/13621084/boundingrectwithsize-for-nsattributedstring-returning-wrong-size/15399767#15399767" target="_blank" rel="noopener">stackoverflow相关讨论</a>里加上了，留个坑，后面知道为什么了来补充吧。</p><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><p>字体</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>上下文</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>如果是多行文字，options要加上<code>NSStringDrawingUsesLineFragmentOrigin</code></li><li>返回的值是小数，需要调用<code>ceil</code>向上取整</li><li>得到的宽度可能比实际宽</li></ol><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">CGSize</span>)getTextLabelSize:(<span class="built_in">NSString</span> *)message &#123;</span><br><span class="line">    <span class="keyword">if</span> ([message length] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 文本框的最大宽度</span></span><br><span class="line">        <span class="keyword">float</span> maxWidth = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">CGRect</span> textRect = [message</span><br><span class="line">                           boundingRectWithSize:<span class="built_in">CGSizeMake</span>(maxWidth, <span class="built_in">CGFLOAT_MAX</span>)</span><br><span class="line">                           options:(<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> |</span><br><span class="line">                                    <span class="built_in">NSStringDrawingUsesFontLeading</span>)</span><br><span class="line">                           attributes:@&#123;</span><br><span class="line">                                        <span class="built_in">NSFontAttributeName</span> :</span><br><span class="line">                                            [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">16</span>]</span><br><span class="line">                                        &#125;</span><br><span class="line">                           context:<span class="literal">nil</span>];</span><br><span class="line">        textRect.size.height = ceilf(textRect.size.height);</span><br><span class="line">        textRect.size.width = ceilf(textRect.size.width);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGSizeMake</span>(textRect.size.width, textRect.size.height);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGSizeZero</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring/1524729-boundingrectwithsize?language=occ&quot; target=&quot;_b
      
    
    </summary>
    
    
      <category term="知识小结" scheme="http://crmo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UITextField控制输入长度</title>
    <link href="http://crmo.github.io/2018/07/06/UITextField%E6%8E%A7%E5%88%B6%E8%BE%93%E5%85%A5%E9%95%BF%E5%BA%A6/"/>
    <id>http://crmo.github.io/2018/07/06/UITextField控制输入长度/</id>
    <published>2018-07-05T16:00:00.000Z</published>
    <updated>2018-08-03T07:29:11.873Z</updated>
    
    <content type="html"><![CDATA[<p>有些时候会有控制输入框文字长度的需求，记录一个简单的思路。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)textField:(<span class="built_in">UITextField</span> *)textField shouldChangeCharactersInRange:(<span class="built_in">NSRange</span>)range replacementString:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    <span class="keyword">if</span> (string.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> limit = <span class="number">15</span>; <span class="comment">// 文本的最大长度</span></span><br><span class="line">    <span class="built_in">NSString</span> *newStr = [textField.text stringByAppendingString:string]; <span class="comment">// 修改之后的新字符串</span></span><br><span class="line">    <span class="built_in">NSInteger</span> newStrLength = newStr.length;</span><br><span class="line">    newStrLength -= [textField textInRange:[textField markedTextRange]].length; <span class="comment">// 去掉高亮内容，输入中文拼音的情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newStrLength &gt; limit) &#123;</span><br><span class="line">        <span class="comment">// 处理composed character, 比如emoji</span></span><br><span class="line">        <span class="built_in">NSString</span> *tempStr = [newStr substringWithRange:[newStr rangeOfComposedCharacterSequencesForRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, limit)]];</span><br><span class="line">        textField.text = tempStr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个坑注意下：</p><ol><li>emoji是<code>composed character</code>，它是由多个字符组合，长度不是1。最开始用的<code>substringToIndex</code>会导致最后一个emoji乱码。</li><li>计算长度的时候要去掉中文输入的时候高亮部分</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有些时候会有控制输入框文字长度的需求，记录一个简单的思路。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="知识小结" scheme="http://crmo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>property or synthsize</title>
    <link href="http://crmo.github.io/2018/07/05/property%20or%20synthsize/"/>
    <id>http://crmo.github.io/2018/07/05/property or synthsize/</id>
    <published>2018-07-04T16:00:00.000Z</published>
    <updated>2018-08-03T07:29:54.048Z</updated>
    
    <content type="html"><![CDATA[<p>@property (nonatomic, retain) NSObject *var;</p><ul><li>生成var的set、get方法的方法声明</li><li>生成var的set、get方法的实现（<strong>早期版本编译器不生成</strong>）</li><li>生成成员变量_var（<strong>早期版本编译器不生成</strong>）</li></ul><p>@synthsize var = _var</p><ul><li>生成var的set、get方法的实现</li><li>生成var对应的成员变量_var</li></ul><blockquote><p>mrc年代的get、set方法的写法</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setVar:(<span class="built_in">NSObject</span> *)var &#123;</span><br><span class="line">    <span class="keyword">if</span> (_var != var) &#123; <span class="comment">// 如果多次set同一个对象，如果不判断会导致对象被释放</span></span><br><span class="line">        <span class="comment">// 释放之前的var</span></span><br><span class="line">        [_var release];</span><br><span class="line">        _var = [var <span class="keyword">retain</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSObject</span> *)var &#123;</span><br><span class="line">    <span class="keyword">return</span> _var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@property (nonatomic, retain) NSObject *var;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成var的set、get方法的方法声明&lt;/li&gt;
&lt;li&gt;生成var的set、get方法的实现（&lt;strong&gt;早期版本编译器不生成&lt;/strong&gt;）&lt;/
      
    
    </summary>
    
    
      <category term="知识小结" scheme="http://crmo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Tagged Pointer小记</title>
    <link href="http://crmo.github.io/2018/07/04/Tagged%20Pointer%E5%B0%8F%E8%AE%B0/"/>
    <id>http://crmo.github.io/2018/07/04/Tagged Pointer小记/</id>
    <published>2018-07-03T16:00:00.000Z</published>
    <updated>2018-07-04T12:40:48.157Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文使用的测试环境是arm64架构真机</p></blockquote><p>为了探究Tagged Pointer本质，可以查看runtime源码，主要看文件<code>objc-internal.h</code>。</p><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>可以看到以下宏定义，只有在64位系统才支持<code>Tagged Pointer</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJC_HAVE_TAGGED_POINTERS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>64-bit的mac，tag存储在LSB（Least Significant Bit 最低位）。其它情况比如64位的真机和模拟器，tag存储在MSB（Most Significant Bit 最高位）。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if TARGET_OS_OSX &amp;&amp; __x86_64__</span></span><br><span class="line">    <span class="comment">// 64-bit Mac - tag bit is LSB</span></span><br><span class="line"><span class="meta">#   define OBJC_MSB_TAGGED_POINTERS 0</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="comment">// Everything else - tag bit is MSB</span></span><br><span class="line"><span class="meta">#   define OBJC_MSB_TAGGED_POINTERS 1</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if OBJC_MSB_TAGGED_POINTERS</span></span><br><span class="line"><span class="meta">#   define _OBJC_TAG_MASK (1UL<span class="meta-string">&lt;&lt;63)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_INDEX_SHIFT 60</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_SLOT_SHIFT 60</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_PAYLOAD_LSHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_PAYLOAD_RSHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_MASK (0xfUL&lt;&lt;60)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_INDEX_SHIFT 52</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_SLOT_SHIFT 52</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 12</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#else</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_MASK 1UL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_INDEX_SHIFT 1</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_SLOT_SHIFT 0</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_PAYLOAD_LSHIFT 0</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_PAYLOAD_RSHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_MASK 0xfUL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_INDEX_SHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_SLOT_SHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 0</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#endif</span></span></span><br></pre></td></tr></table></figure><p>接下来是一个枚举定义，定义了默认的使用<code>Tagged Pointer</code>的类。例如NSString、NSNumber、NSIndexPath、NSDate（OBJC_TAG_NSAtom、OBJC_TAG_1、OBJC_TAG_NSManagedObjectID不知道是啥意思，还请知道的同学告诉我）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">objc_tag_index_t</span> : <span class="keyword">uint16_t</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    OBJC_TAG_NSAtom            = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_1                 = <span class="number">1</span>, </span><br><span class="line">    OBJC_TAG_NSString          = <span class="number">2</span>, </span><br><span class="line">    OBJC_TAG_NSNumber          = <span class="number">3</span>, </span><br><span class="line">    OBJC_TAG_NSIndexPath       = <span class="number">4</span>, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID = <span class="number">5</span>, </span><br><span class="line">    OBJC_TAG_NSDate            = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_RESERVED_7        = <span class="number">7</span>, </span><br><span class="line"></span><br><span class="line">    OBJC_TAG_First60BitPayload = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_Last60BitPayload  = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_First52BitPayload = <span class="number">8</span>, </span><br><span class="line">    OBJC_TAG_Last52BitPayload  = <span class="number">263</span>, </span><br><span class="line"></span><br><span class="line">    OBJC_TAG_RESERVED_264      = <span class="number">264</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><p>判断是不是<code>Tagged Pointer</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_objc_isTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成一个<code>Tagged Pointer</code>，最高的4位是tagged，剩下的是数据</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> * _Nonnull</span><br><span class="line">_objc_makeTaggedPointer(objc_tag_index_t tag, uintptr_t value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag &lt;= OBJC_TAG_Last60BitPayload) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)</span><br><span class="line">            (_OBJC_TAG_MASK | </span><br><span class="line">             ((uintptr_t)tag &lt;&lt; _OBJC_TAG_INDEX_SHIFT) | </span><br><span class="line">             ((value &lt;&lt; _OBJC_TAG_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_LSHIFT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)</span><br><span class="line">            (_OBJC_TAG_EXT_MASK |</span><br><span class="line">             ((uintptr_t)(tag - OBJC_TAG_First52BitPayload) &lt;&lt; _OBJC_TAG_EXT_INDEX_SHIFT) |</span><br><span class="line">             ((value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>Tagged Pointer</code>中取出值</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uintptr_t</span><br><span class="line">_objc_getTaggedPointerValue(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class="line">    uintptr_t basicTag = ((uintptr_t)ptr &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class="line">    <span class="keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((uintptr_t)ptr &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((uintptr_t)ptr &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NSNumber应用举例"><a href="#NSNumber应用举例" class="headerlink" title="NSNumber应用举例"></a>NSNumber应用举例</h2><p>可以使用下面代码来验证NSNumber如何使用<code>Tagged Pointer</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *charNumber = [<span class="built_in">NSNumber</span> numberWithChar:<span class="string">'1'</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *shortNumber = [<span class="built_in">NSNumber</span> numberWithShort:<span class="number">1</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *intNumber = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *floatNumber = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.0</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *longNumber = [<span class="built_in">NSNumber</span> numberWithLong:<span class="number">1</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *doubleNumber = [<span class="built_in">NSNumber</span> numberWithDouble:<span class="number">1.0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出变量的指针地址：</span></span><br><span class="line"><span class="comment">// charNumber 0xb000000000000310</span></span><br><span class="line"><span class="comment">// shortNumber 0xb000000000000011</span></span><br><span class="line"><span class="comment">// intNumber 0xb000000000000012</span></span><br><span class="line"><span class="comment">// floatNumber 0xb000000000000014</span></span><br><span class="line"><span class="comment">// longNumber 0xb000000000000013</span></span><br><span class="line"><span class="comment">// doubleNumber 0xb000000000000015</span></span><br></pre></td></tr></table></figure><p>不难发现规律，都是以b(1011)开头</p><ul><li>最高位是1，说明这个指针是一个<code>Tagged Pointer</code></li><li>第61-63位是11（十进制是3），也就是<code>OBJC_TAG_NSNumber</code>（查上面的枚举）</li><li>第1-4位是NSNumber的类型：比如，char是0、short是1、int是2、float是4</li><li>剩下的56位就是真正的值了</li></ul><h2 id="NSString应用举例"><a href="#NSString应用举例" class="headerlink" title="NSString应用举例"></a>NSString应用举例</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str1 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"a"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"ab"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出变量的指针地址：</span></span><br><span class="line"><span class="comment">// str1: 0xa000000000000611</span></span><br><span class="line"><span class="comment">// str2: 0xa000000000062612</span></span><br></pre></td></tr></table></figure><p>与NSNumber类似</p><ul><li>最高位是1，说明这个指针是一个<code>Tagged Pointer</code></li><li>第61-63位是11（十进制是2），也就是<code>OBJC_TAG_NSString</code></li><li>第1-4位是字符串长度</li><li>剩下的56位就是真正的值了</li></ul><blockquote><p>更多细节推荐这篇文章<a href="http://www.cocoachina.com/ios/20150918/13449.html" target="_blank" rel="noopener">采用Tagged Pointer的字符串</a></p></blockquote><hr><p>参考文章</p><ul><li><a href="https://www.jianshu.com/p/e354f9137ba8" target="_blank" rel="noopener">iOS Tagged Pointer</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" target="_blank" rel="noopener">wiki</a></li><li><a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer" target="_blank" rel="noopener">深入理解Tagged Pointer</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文使用的测试环境是arm64架构真机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了探究Tagged Pointer本质，可以查看runtime源码，主要看文件&lt;code&gt;objc-internal.h&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;宏
      
    
    </summary>
    
    
      <category term="每日小结" scheme="http://crmo.github.io/tags/%E6%AF%8F%E6%97%A5%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>URLWithString return nil</title>
    <link href="http://crmo.github.io/2018/07/03/URLWithString%20return%20nil/"/>
    <id>http://crmo.github.io/2018/07/03/URLWithString return nil/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2018-07-03T12:43:58.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在使用<code>URLWithString</code>生成NSURL时，如果出现中文，会导致返回的NSURL为nil。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSURL *aUrl = [NSURL URLWithString:@&quot;http://中文域名&quot;];</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/1981390/urlwithstring-returns-nil" target="_blank" rel="noopener">stackoverflow相关讨论</a></p><p>查询了<a href="https://developer.apple.com/documentation/foundation/nsurl/1572047-urlwithstring?changes=_1&amp;language=objc" target="_blank" rel="noopener">URLWithString的官方文档</a>，其中有一段话解决了我的疑惑。</p><blockquote><p>This method expects URLString to contain only characters that are allowed in a properly formed URL. All other characters must be properly percent escaped. Any percent-escaped characters are interpreted using UTF-8 encoding.</p></blockquote><p>意思就是该方法的输入参数<code>URLString</code>只能包含URL的合法字符，包含非法字符的URL需要进行百分号编码(percent escaped)</p><h2 id="百分号编码（percent-escaped）"><a href="#百分号编码（percent-escaped）" class="headerlink" title="百分号编码（percent escaped）"></a>百分号编码（percent escaped）</h2><p><a href="https://zh.wikipedia.org/wiki/百分号编码" target="_blank" rel="noopener">wiki相关词条</a></p><p>有两种情况必须使用百分号编码</p><ol><li>参数中出现保留字符</li></ol><p>URL所允许的字符分作保留与未保留，保留字符是那些具有特殊含义的字符</p><p><img src="/images/15305867541997.jpg" alt=""></p><ol><li>URL中出现非ASCII字符</li></ol><p>对于非ASCII字符, 需要转换为UTF-8字节序，再进行百分号编码</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用方法<code>stringByAddingPercentEscapesUsingEncoding</code>对URL字符串百分号编码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *encodeUrl = [url stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    NSURL *aUrl = [NSURL URLWithString:encodeUrl];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在使用&lt;code&gt;URLWithString&lt;/code&gt;生成NSURL时，如果出现中文，会导致返回的NSURL为nil。代
      
    
    </summary>
    
    
      <category term="每日小结" scheme="http://crmo.github.io/tags/%E6%AF%8F%E6%97%A5%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS消息转发小记</title>
    <link href="http://crmo.github.io/2018/05/31/iOS%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E5%B0%8F%E8%AE%B0/"/>
    <id>http://crmo.github.io/2018/05/31/iOS消息转发小记/</id>
    <published>2018-05-30T16:00:00.000Z</published>
    <updated>2018-06-05T01:23:31.777Z</updated>
    
    <content type="html"><![CDATA[<p>消息转发流程图</p><p><img src="/images/15277558865032.jpg" alt=""></p><p>如果类接收到无法处理的消息，会触发消息转发机制，一共有三个步骤，接受者在每一步中均有机会处理消息。步骤越往后，处理消息的代价就越大，所以最好再第一步就处理完。</p><h2 id="第一道防线"><a href="#第一道防线" class="headerlink" title="第一道防线"></a>第一道防线</h2><p>在类里面实现两个方法来处理未知消息。执行动态方法解析之前，先会判断是否曾经有动态解析。</p><ul><li><code>resolveInstanceMethod</code>：处理实例方法</li><li><code>resolveClassMethod</code>：处理类方法</li></ul><p>我们来看个Demo，先看调用方代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TestA *testA = [[TestA alloc] init];</span><br><span class="line">[testA instanceMethod];</span><br><span class="line">[TestA classMethod];</span><br></pre></td></tr></table></figure><p>再来看看TestA的定义。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestA.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestA</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)instanceMethod;</span><br><span class="line">+ (<span class="keyword">void</span>)classMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestA.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestA</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)newInstanceMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"newInstanceMethod"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)newClassMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"newClassMethod"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(instanceMethod)) &#123;</span><br><span class="line">        <span class="comment">// 动态添加方法newInstanceMethod</span></span><br><span class="line">        Method method = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(newInstanceMethod));</span><br><span class="line">        IMP imp = method_getImplementation(method);</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, imp, method_getTypeEncoding(method));</span><br><span class="line">        <span class="comment">// 成功处理，消息转发机制结束，调用newInstanceMethod</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能处理，进入第二步</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(classMethod)) &#123;</span><br><span class="line">        <span class="comment">// 动态添加方法newClassMethod</span></span><br><span class="line">        Method method = class_getInstanceMethod(object_getClass(<span class="keyword">self</span>), <span class="keyword">@selector</span>(newClassMethod));</span><br><span class="line">        IMP imp = method_getImplementation(method);</span><br><span class="line">        class_addMethod(object_getClass(<span class="keyword">self</span>), sel, imp, method_getTypeEncoding(method));</span><br><span class="line">        <span class="comment">// 成功处理，消息转发机制结束，调用newClassMethod</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能处理，进入第二步</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>TestA中头文件定义了两个方法，但是没有实现，如果不用消息转发机制处理异常，会导致crash，log想必大家应该很熟悉</p><blockquote><p>*** Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[TestA funcA]: unrecognized selector sent to instance 0x6040000125c0’</p></blockquote><p>实例方法存储在类对象，类方法存储在元类对象，在调用<code>class_addMethod</code>时，第一个参数需要注意。</p><h2 id="第二道防线"><a href="#第二道防线" class="headerlink" title="第二道防线"></a>第二道防线</h2><p>第二道防线依赖一个函数<code>forwardingTargetForSelector</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类方法</span></span><br><span class="line"><span class="comment">//+ (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(instanceMethod)) &#123;</span><br><span class="line">        <span class="comment">// 消息转发给TestB实例</span></span><br><span class="line">        <span class="keyword">return</span> [TestB new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消息转发失败，进入下一步</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestB.m</span></span><br><span class="line">- (<span class="keyword">void</span>)instanceMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"instanceMethod"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三道防线"><a href="#第三道防线" class="headerlink" title="第三道防线"></a>第三道防线</h2><p>第三道防线有两步</p><ol><li>调用<code>methodSignatureForSelector</code>，获取新的方法签名（返回值类型，参数类型）</li><li>调用<code>forwardInvocation</code>，转发消息，</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法签名（返回值类型，参数类型）</span></span><br><span class="line"><span class="comment">// 类方法减号改为加号</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [TestB instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSInvocation封装了方法调用，包括：方法调用者、方法名、方法参数</span></span><br><span class="line"><span class="comment">// anInvocation.target 消息接受者</span></span><br><span class="line"><span class="comment">// anInvocation.selector 函数名</span></span><br><span class="line"><span class="comment">// [anInvocation getArgument:NULL atIndex:0]; 获取参数</span></span><br><span class="line"><span class="comment">// 类方法减号改为加号</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[TestB new]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;消息转发流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/15277558865032.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果类接收到无法处理的消息，会触发消息转发机制，一共有三个步骤，接受者在每一步中均有机会处理消息。步骤越往后，处理消息的代价就越大，所以最
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>探寻Objective-C引用计数本质</title>
    <link href="http://crmo.github.io/2018/05/26/%E6%8E%A2%E5%AF%BBObjective-C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    <id>http://crmo.github.io/2018/05/26/探寻Objective-C引用计数本质/</id>
    <published>2018-05-25T16:00:00.000Z</published>
    <updated>2018-07-04T12:49:11.824Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文涉及到的CPU架构为arm64，其它架构大同小异。<br>源码来自<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">苹果开源-runtime</a>。</p></blockquote><p>Objective-C中采用引用计数机制来管理内存，在MRC时代，需要我们手动<code>retain</code>和<code>release</code>，在苹果引入ARC后大部分时间我们不用再关心引用计数问题。但是为了深入Objective-C本质，引用计数究竟是怎么实现的还是值得我们去探寻的。</p><h2 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h2><p>OC中的对象的实质其实是结构体，其中大部分对象都有isa，指向类对象（有一种神奇的存在叫做<code>Tagged Pointer</code>），源码中关于对象结构体<code>objc_object</code>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-private.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">id <span class="title">retain</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">id <span class="title">autorelease</span><span class="params">()</span></span>;</span><br><span class="line">    ... <span class="comment">//省略了其它方法，感兴趣可以直接看源码</span></span><br></pre></td></tr></table></figure><h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p>除了有一种特殊的对象<code>Tagged Pointer</code>，这种类型的对象值就存在指针当中，存取性能高。可以用来存储少量数据的对象，例如NSNumber、NSDate、NSString。(更多Tagged Pointer知识，具体看这篇<a href="https://crmo.github.io/2018/07/04/Tagged%20Pointer小记/">Tagged Pointer小记</a>)。也就没有引用计数、内存释放的问题。</p><h3 id="NONPOINTER-ISA"><a href="#NONPOINTER-ISA" class="headerlink" title="NONPOINTER ISA"></a>NONPOINTER ISA</h3><p>arm64架构isa占64位，苹果为了优化性能，存储类对象地址只用了33位，剩下的位用来存储一些其它信息，比如本文讨论的引用计数。</p><p>NONPOINTER ISA存储的字段定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">    struct &#123;</span><br><span class="line">        uintptr_t nonpointer        : 1;</span><br><span class="line">        uintptr_t has_assoc         : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">        uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000</span><br><span class="line">        uintptr_t magic             : 6;</span><br><span class="line">        uintptr_t weakly_referenced : 1;</span><br><span class="line">        uintptr_t deallocating      : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">        uintptr_t extra_rc          : 19;</span><br><span class="line">#       define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#       define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="extra-rc"><a href="#extra-rc" class="headerlink" title="extra_rc"></a>extra_rc</h2><p>那引用计数存在哪里呢？秘密就在<code>extra_rc</code>中。</p><blockquote><p>extra_rc只是存储了额外的引用计数，实际的引用计数计算公式：<code>引用计数=extra_rc+1</code>。</p></blockquote><p><code>extra_rc</code>占了19位，可以存储的最大引用计数：$2^{19}-1+1=524288$，超过它就需要进位到<code>SideTables</code>。SideTables是一个Hash表，根据对象地址可以找到对应的<code>SideTable</code>，<code>SideTable</code>内包含一个<code>RefcountMap</code>，根据对象地址取出其引用计数，类型是<code>size_t</code>。<br>它是一个<code>unsigned long</code>，最低两位是标志位，剩下的62位用来存储引用计数。我们可以计算出引用计数的理论最大值：$2^{62+19}=2.417851639229258e24$。</p><blockquote><p>其实isa能存储的524288在日常开发已经完全够用了，为什么还要搞个Side Table？我猜测是因为历史问题，以前cpu是32位的，isa中能存储的引用计数就只有$2^{7}=128$。因此在arm64下，引用计数通常是存储在isa中的。</p></blockquote><h2 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h2><p>有了前面的铺垫，我们知道引用计数怎么存储的了，那引用计数又是怎么改变的呢？通过剖析<code>retain</code>源码我们就可以得出结论了。<br>objc_object的方法全部定义在objc-object.h文件中，全是内联函数，应该是为了性能的考虑。</p><p>我们来看看<code>retain</code>的函数定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> id </span><br><span class="line">objc_object::retain()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        <span class="keyword">return</span> rootRetain();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((id(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_retain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这层比较简单，做了三件事情：</p><ol><li>判断指针是不是<code>Tagged Pointer</code></li><li>判断是否有自定义<code>retain</code>，如果有调用自定义的。</li><li>最后调用<code>rootRetain</code></li></ol><p>我们来看看关键函数<code>rootRetain</code>的实现（为了便于阅读，代码有所删减）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain(<span class="keyword">bool</span> tryRetain, <span class="keyword">bool</span> handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">isa_t</span> oldisa;</span><br><span class="line">    <span class="keyword">isa_t</span> newisa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁，用汇编指令ldxr来保证原子性</span></span><br><span class="line">    oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    newisa = oldisa;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newisa.nonpointer = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// newisa.nonpointer = 0说明所有位数都是地址值</span></span><br><span class="line">        <span class="comment">// 释放锁，使用汇编指令clrex</span></span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 由于所有位数都是地址值，直接使用sidetable来存储引用计数</span></span><br><span class="line">        <span class="keyword">return</span> sidetable_retain();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储extra_rc++后的结果</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> carry;</span><br><span class="line">    <span class="comment">// extra_rc++</span></span><br><span class="line">    newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// extra_rc++后溢出，进位到side table</span></span><br><span class="line">        newisa.extra_rc = RC_HALF;</span><br><span class="line">        newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 将newisa写入isa</span></span><br><span class="line">    StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)</span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个细节可以了解下，如何用汇编来实现原子性操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE</span><br><span class="line"><span class="keyword">uintptr_t</span> </span><br><span class="line">LoadExclusive(<span class="keyword">uintptr_t</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> result;</span><br><span class="line">    <span class="comment">// 在多核CPU下，对一个地址的访问可能引起冲突，ldxr解决了冲突，保证原子性。</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"ldxr %x0, [%x1]"</span> </span><br><span class="line">        : <span class="string">"=r"</span> (result) </span><br><span class="line">        : <span class="string">"r"</span> (src), <span class="string">"m"</span> (*src));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><p><code>release</code>代码逻辑基本上就是<code>retain</code>反过来走一遍，有点不同的是在引用计数减到0时，会调用对象的dealloc方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE bool</span><br><span class="line">objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line">    </span><br><span class="line">retry:</span><br><span class="line">    oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    newisa = oldisa;</span><br><span class="line">    if (newisa.nonpointer == 0) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        if (sideTableLocked) sidetable_unlock();</span><br><span class="line">        return sidetable_release(performDealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    uintptr_t carry;</span><br><span class="line">    // extra_rc--</span><br><span class="line">    newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);</span><br><span class="line">    if (carry == 0) &#123;</span><br><span class="line">        // 需要从SideTable借位，或者引用计数为0</span><br><span class="line">        goto underflow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 存储引用计数到isa</span><br><span class="line">    StoreReleaseExclusive(&amp;isa.bits,</span><br><span class="line">                          oldisa.bits, newisa.bits)</span><br><span class="line">    return false;</span><br><span class="line">    </span><br><span class="line">underflow:</span><br><span class="line">    // 从SideTable借位</span><br><span class="line">    // 或引用计数为0，调用delloc</span><br><span class="line">    </span><br><span class="line">    // 此处省略N多代码</span><br><span class="line">    // 总结一下:修改Side Table与extra_rc，</span><br><span class="line">    </span><br><span class="line">    // 引用计数减为0时，调用dealloc</span><br><span class="line">    if (performDealloc) &#123;</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>引用计数存在哪？</p></blockquote><ol><li><code>Tagged Pointer</code>不需要引用计数</li><li><code>NONPOINTER ISA</code>(isa的第一位为1)的引用计数优先存在isa中，大于524288了进位到<code>Side Tables</code></li><li>非<code>NONPOINTER ISA</code>引用计数存在<code>Side Tables</code></li></ol><blockquote><p>retain/release的实质</p></blockquote><ul><li>找到引用计数存储区域，然后+1/-1</li><li>如果是<code>NONPOINTER ISA</code>，还要处理进位/借位的情况</li><li>release在引用计数减为0时，调用<code>dealloc</code></li></ul><hr><p>参考</p><ul><li><a href="https://github.com/Draveness/analyze/blob/master/contents/objc/黑箱中的%20retain%20和%20release.md" target="_blank" rel="noopener">黑箱中的 retain 和 release</a></li><li><a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer" target="_blank" rel="noopener">深入理解Tagged Pointer</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文涉及到的CPU架构为arm64，其它架构大同小异。&lt;br&gt;源码来自&lt;a href=&quot;https://opensource.apple.com/tarballs/objc4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;苹果开
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cordova源码解析（二）- 自定义UserAgent</title>
    <link href="http://crmo.github.io/2018/05/15/Cordova%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-%20%E8%87%AA%E5%AE%9A%E4%B9%89UserAgent/"/>
    <id>http://crmo.github.io/2018/05/15/Cordova源码解析（二）- 自定义UserAgent/</id>
    <published>2018-05-14T16:00:00.000Z</published>
    <updated>2018-05-15T11:25:56.421Z</updated>
    
    <content type="html"><![CDATA[<p>本文分析的源码是基于Cordova 4.2.1版本，<a href="https://cordova.apache.org" target="_blank" rel="noopener">Cordova官网</a>。</p><h1 id="Cordova源码解析（二）-自定义UserAgent"><a href="#Cordova源码解析（二）-自定义UserAgent" class="headerlink" title="Cordova源码解析（二）- 自定义UserAgent"></a>Cordova源码解析（二）- 自定义UserAgent</h1><p><code>UIWebView</code>没有提供设置UserAgent的接口，但是有一个办法可以间接的设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary* dict = [[NSDictionary alloc] initWithObjectsAndKeys:value, @&quot;UserAgent&quot;, nil];</span><br><span class="line">[[NSUserDefaults standardUserDefaults] registerDefaults:dict];</span><br></pre></td></tr></table></figure><p>通过设置<code>NSUserDefaults</code>中<code>UserAgent</code>的值来修改，但是这种设置方法有一个限制，需要在<code>UIWebView</code>的<code>loadRequest</code>之前调用才能生效(加载PDF比较特殊)。这是Cordova源码中关于这个问题的描述</p><blockquote><p>Setting the UserAgent must occur before a UIWebView is instantiated.<br>It is read per instantiation, so it does not affect previously created views.<br>Except! When a PDF is loaded, all currently active UIWebViews reload their<br>User-Agent from the NSUserDefaults some time after the DidFinishLoad of the PDF bah!</p></blockquote><h2 id="CDVUserAgentUtil"><a href="#CDVUserAgentUtil" class="headerlink" title="CDVUserAgentUtil"></a>CDVUserAgentUtil</h2><p>在多WebView的情况下，如果每个WebView都有不同的<code>UserAgent</code>，就会产生数据竞争的问题，大家都要修改<code>NSUserDefaults</code>中<code>UserAgent</code>的值，于是需要对资源加锁来保证每个WebView都设置预期的<code>UserAgent</code>。在Cordova中，专门有一个类<code>CDVUserAgentUtil</code>来实现这个功能。</p><p><code>CDVUserAgentUtil.h</code>文件中定义了四个方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取UIWebView默认的UserAgent</span></span><br><span class="line">+ (<span class="built_in">NSString</span>*)originalUserAgent;</span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">+ (<span class="keyword">void</span>)acquireLock:(<span class="keyword">void</span> (^)(<span class="built_in">NSInteger</span> lockToken))block;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">+ (<span class="keyword">void</span>)releaseLock:(<span class="built_in">NSInteger</span>*)lockToken;</span><br><span class="line"><span class="comment">// 设置UIWebView的UserAgent</span></span><br><span class="line">+ (<span class="keyword">void</span>)setUserAgent:(<span class="built_in">NSString</span>*)value lockToken:(<span class="built_in">NSInteger</span>)lockToken;</span><br></pre></td></tr></table></figure><h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><p>每次加锁成功会返回一个NSInteger类型的token，在释放锁的时候需要把token传入。token会不断递增，保证每次加锁返回的token都不回重复。加锁的实现代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVUserAgentUtil.m</span></span><br><span class="line">+ (<span class="keyword">void</span>)acquireLock:(<span class="keyword">void</span> (^)(<span class="built_in">NSInteger</span> lockToken))block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gCurrentLockToken == <span class="number">0</span>) &#123;</span><br><span class="line">        gCurrentLockToken = ++gNextLockToken;</span><br><span class="line">        VerboseLog(<span class="string">@"Gave lock %d"</span>, gCurrentLockToken);</span><br><span class="line">        block(gCurrentLockToken);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (gPendingSetUserAgentBlocks == <span class="literal">nil</span>) &#123;</span><br><span class="line">            gPendingSetUserAgentBlocks = [[<span class="built_in">NSMutableArray</span> alloc] initWithCapacity:<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        VerboseLog(<span class="string">@"Waiting for lock"</span>);</span><br><span class="line">        [gPendingSetUserAgentBlocks addObject:block];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>acquireLock:</code>，首先会判断<code>gCurrentLockToken</code>是否等于0</p><ul><li>如果是0说明没有模块正在修改<code>UserAgent</code>，能够成功获取到锁，<code>gCurrentLockToken</code>递增，标致当前有模块正在修改<code>UserAgent</code>，并回调<code>block</code>，返回<code>gCurrentLockToken</code></li><li>如果不为0说明当前有模块正在修改<code>UserAgent</code>，将<code>block</code>回调存在一个队列<code>gPendingSetUserAgentBlocks</code>中</li></ul><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>释放锁需要传入token，释放锁代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)releaseLock:(<span class="built_in">NSInteger</span>*)lockToken</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*lockToken == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSAssert</span>(gCurrentLockToken == *lockToken, <span class="string">@"Got token %ld, expected %ld"</span>, (<span class="keyword">long</span>)*lockToken, (<span class="keyword">long</span>)gCurrentLockToken);</span><br><span class="line"></span><br><span class="line">    VerboseLog(<span class="string">@"Released lock %d"</span>, *lockToken);</span><br><span class="line">    <span class="keyword">if</span> ([gPendingSetUserAgentBlocks count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> (^block)() = [gPendingSetUserAgentBlocks objectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [gPendingSetUserAgentBlocks removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        gCurrentLockToken = ++gNextLockToken;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Gave lock %ld"</span>, (<span class="keyword">long</span>)gCurrentLockToken);</span><br><span class="line">        block(gCurrentLockToken);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        gCurrentLockToken = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *lockToken = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果要释放的<code>lockToken</code>为0，说明还没加过锁，就调用释放了，直接返回</li><li>从队列<code>gPendingSetUserAgentBlocks</code>中取出最早加入的<code>block</code>，从队列中移除</li><li><code>gCurrentLockToken</code>递增生成新token，回调<code>block</code></li><li>如果队列<code>gPendingSetUserAgentBlocks</code>释放完成，说明释放锁的调用次数&gt;加锁的次数，不做操作，然后把<code>gCurrentLockToken</code>置为0</li></ul><h2 id="设置UserAgent"><a href="#设置UserAgent" class="headerlink" title="设置UserAgent"></a>设置UserAgent</h2><p>在Cordova实际运用中，操作锁的时机：<br>加锁时机：<code>CDVViewController</code>加载完毕，在<code>viewDidLoad</code>里调用<br>释放锁时机：</p><ul><li><code>UIWebView</code>的<code>webViewDidFinishLoad:</code>回调</li><li><code>UIWebView</code>的<code>webView:didFailLoadWithError:</code>回调</li><li><code>CDVViewController</code>的<code>dealloc</code></li><li><code>CDVViewController</code>的<code>viewDidUnload</code></li></ul><p>加锁代码，省略了不相关代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVViewController.m</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [CDVUserAgentUtil acquireLock:^(<span class="built_in">NSInteger</span> lockToken) &#123;</span><br><span class="line">        _userAgentLockToken = lockToken;</span><br><span class="line">        [CDVUserAgentUtil setUserAgent:<span class="keyword">self</span>.userAgent lockToken:lockToken];</span><br><span class="line">        <span class="built_in">NSURLRequest</span>* appReq = [<span class="built_in">NSURLRequest</span> requestWithURL:appURL cachePolicy:<span class="built_in">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class="number">20.0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.webViewEngine loadRequest:appReq];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放锁代码，这里只看正常逻辑，在网页加载完成回调<code>webViewDidFinishLoad:</code>中释放逻辑。不考虑异常情况，省略了不相关代码。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVUIWebViewNavigationDelegate.m</span></span><br><span class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span>*)theWebView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Finished load of: %@"</span>, theWebView.request.URL);</span><br><span class="line">    CDVViewController* vc = (CDVViewController*)<span class="keyword">self</span>.enginePlugin.viewController;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It's safe to release the lock even if this is just a sub-frame that's finished loading.</span></span><br><span class="line">    [CDVUserAgentUtil releaseLock:vc.userAgentLockToken];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>webViewDidFinishLoad:</code>回调时，UserAgent已经设置成功，所以可以释放锁，让其它WebView操作UserDefault了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文分析的源码是基于Cordova 4.2.1版本，&lt;a href=&quot;https://cordova.apache.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cordova官网&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;Cordova源码解析（二）-自
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cordova源码解析</title>
    <link href="http://crmo.github.io/2018/05/09/Cordova%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://crmo.github.io/2018/05/09/Cordova源码解析/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2018-07-10T11:50:53.078Z</updated>
    
    <content type="html"><![CDATA[<p>本文设计到的源码是基于Cordova 4.2.1版本，<a href="https://cordova.apache.org" target="_blank" rel="noopener">Cordova官网</a>。</p><h2 id="CDVViewController"><a href="#CDVViewController" class="headerlink" title="CDVViewController"></a>CDVViewController</h2><p><code>CDVViewController</code>是Cordova最主要的类，它把所有模块整合在一起，直接初始化一个它的实例就可以使用。例如下面的代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CDVViewController *vc = [[CDVViewController alloc] init];</span><br><span class="line">vc.startPage = <span class="string">@"www.baidu.com"</span>;</span><br><span class="line">[<span class="keyword">self</span> presentViewController:vc animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p><code>CDVViewController</code>主要实现的功能：</p><ul><li>注册、初始化插件</li><li>读取、应用配置文件</li><li>初始化并配置WebView，设置其代理</li><li>管理js与原生的方法调用</li><li><p>管理应用与网页的生命周期<br>。。。</p><p>它主要的属性有：</p></li><li><p>CDVWebViewEngineProtocol：webview相关的回调</p></li><li>CDVCommandDelegate：js与原生插件交互方法，插件初始化</li><li>CDVCommandQueue：命令执行队列</li></ul><p><code>CDVCommandDelegate</code>和<code>CDVCommandQueue</code>会在js调用原生插件与插件初始化提到，这里先不细说。<br><code>CDVWebViewEngineProtocol</code>定义了<code>WebView</code>引擎的抽象类，具体实现由插件提供，例如<code>CDVUIWebViewEngine</code>实现<code>UIWebView</code>的引擎。</p><h3 id="CDVWebViewEngineProtocol协议定义"><a href="#CDVWebViewEngineProtocol协议定义" class="headerlink" title="CDVWebViewEngineProtocol协议定义"></a>CDVWebViewEngineProtocol协议定义</h3><p><code>CDVWebViewEngineProtocol</code>协议其实是对于WebView的一层封装，屏蔽了不同<code>WebView</code>接口的差异，现在iOS有<code>UIWebView</code>与<code>WKWebView</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CDVWebViewEngineProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIView</span>* engineWebView;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)loadRequest:(<span class="built_in">NSURLRequest</span>*)request;</span><br><span class="line">- (<span class="keyword">id</span>)loadHTMLString:(<span class="built_in">NSString</span>*)string baseURL:(<span class="built_in">NSURL</span>*)baseURL;</span><br><span class="line">- (<span class="keyword">void</span>)evaluateJavaScript:(<span class="built_in">NSString</span>*)javaScriptString completionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">id</span>, <span class="built_in">NSError</span>*))completionHandler;</span><br><span class="line">- (<span class="built_in">NSURL</span>*)URL;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canLoadRequest:(<span class="built_in">NSURLRequest</span>*)request;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame;</span><br><span class="line">- (<span class="keyword">void</span>)updateWithInfo:(<span class="built_in">NSDictionary</span>*)info;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>engineWebView</code>属性对外直接暴露了内部封装的<code>WebView</code>，其它方法都是对<code>WebView</code>方法的一层简单封装。</p><h3 id="UIWebView引擎CDVUIWebViewEngine"><a href="#UIWebView引擎CDVUIWebViewEngine" class="headerlink" title="UIWebView引擎CDVUIWebViewEngine"></a>UIWebView引擎CDVUIWebViewEngine</h3><p>我们以<code>UIWebView</code>的实现<code>CDVUIWebViewEngine</code>为例说明，它是以插件的形式实现的，主要作用是初始化UIWebView的配置，对UIWebView的方法和代理进行了一层封装。它实现了协议<code>CDVWebViewEngineProtocol</code>，主要有以下几个属性。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVUIWebViewEngine</span></span><br><span class="line"><span class="comment">// UIWebview</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">UIView</span>* engineWebView;</span><br><span class="line"><span class="comment">// UIWebView的代理</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="keyword">id</span> &lt;<span class="built_in">UIWebViewDelegate</span>&gt; uiWebViewDelegate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) CDVUIWebViewNavigationDelegate* navWebViewDelegate;</span><br></pre></td></tr></table></figure><p>初始化从<code>initWithFrame:</code>方法开始，它创建了一个<code>UIWebView</code>，并赋值给了<code>engineWebView</code>，然后在插件初始化方法<code>pluginInitialize</code>中初始化<code>UIWebView</code>的代理和配置。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)pluginInitialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIWebView</span>* uiWebView = (<span class="built_in">UIWebView</span>*)_engineWebView;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前controller是否实现了UIWebViewDelegate</span></span><br><span class="line">    <span class="comment">// 如果实现了就把当前controller设置为CDVUIWebViewDelegate的代理实现</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.viewController conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">UIWebViewDelegate</span>)]) </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.uiWebViewDelegate = [[CDVUIWebViewDelegate alloc] initWithDelegate:(<span class="keyword">id</span> &lt;<span class="built_in">UIWebViewDelegate</span>&gt;)<span class="keyword">self</span>.viewController];</span><br><span class="line">        uiWebView.delegate = <span class="keyword">self</span>.uiWebViewDelegate;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果没有实现，创建一个CDVUIWebViewNavigationDelegate，作为CDVUIWebViewDelegate的代理实现</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.navWebViewDelegate = [[CDVUIWebViewNavigationDelegate alloc] initWithEnginePlugin:<span class="keyword">self</span>];</span><br><span class="line">        <span class="keyword">self</span>.uiWebViewDelegate = [[CDVUIWebViewDelegate alloc] initWithDelegate:<span class="keyword">self</span>.navWebViewDelegate];</span><br><span class="line">        uiWebView.delegate = <span class="keyword">self</span>.uiWebViewDelegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化配置信息</span></span><br><span class="line">    <span class="comment">// self.commandDelegate.settings是CDVViewController的配置信息，定义在config.xml</span></span><br><span class="line">    [<span class="keyword">self</span> updateSettings:<span class="keyword">self</span>.commandDelegate.settings];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js调用原生插件解析"><a href="#js调用原生插件解析" class="headerlink" title="js调用原生插件解析"></a>js调用原生插件解析</h2><p>插件调用流程：</p><ol><li>js发起请求<code>gap://</code></li><li>实现<code>WebView</code>的代理<code>webView:shouldStartLoadWithRequest:navigationType:</code>，拦截<code>scheme</code>为<code>gap</code>的请求</li><li>执行js方法<code>cordova.require(&#39;cordova/exec&#39;).nativeFetchMessages()</code>获取需要执行的原生插件的信息（插件名，插件方法，回调ID，参数）</li><li>将需要执行的原生插件信息放入命令队列等待执行</li><li>执行原生插件，并把结果回调给js</li></ol><p>插件调用堆栈如图所示：</p><p><img src="/images/15256629038423.jpg" alt=""></p><h3 id="js请求拦截"><a href="#js请求拦截" class="headerlink" title="js请求拦截"></a>js请求拦截</h3><p><code>CDVUIWebViewDelegate</code>实现了UIWebView的<code>webView:shouldStartLoadWithRequest:navigationType:</code>代理，在页面加载前做一些处理。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span>*)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span>*)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> shouldLoad = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 判断如果有代理，先调用代理方法</span></span><br><span class="line">    <span class="comment">// 这里的_delegate是CDVUIWebViewNavigationDelegate</span></span><br><span class="line">    <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(webView:shouldStartLoadWithRequest:navigationType:)]) &#123;</span><br><span class="line">        shouldLoad = [_delegate webView:webView shouldStartLoadWithRequest:request navigationType:navigationType];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldLoad) &#123;</span><br><span class="line">        <span class="comment">// 是否是调试工具refresh</span></span><br><span class="line">        <span class="built_in">BOOL</span> isDevToolsRefresh = (request == webView.request);</span><br><span class="line">        <span class="comment">// 是否是顶层页面</span></span><br><span class="line">        <span class="built_in">BOOL</span> isTopLevelNavigation = isDevToolsRefresh || [request.URL isEqual:[request mainDocumentURL]];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isTopLevelNavigation) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> request:request isEqualToRequestAfterStrippingFragments:webView.request]) &#123;</span><br><span class="line">                <span class="built_in">NSString</span>* prevURL = [<span class="keyword">self</span> evalForCurrentURL:webView];</span><br><span class="line">                <span class="keyword">if</span> ([prevURL isEqualToString:[request.URL absoluteString]]) &#123;</span><br><span class="line">                    VerboseLog(<span class="string">@"Page reload detected."</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    VerboseLog(<span class="string">@"Detected hash change shouldLoad"</span>);</span><br><span class="line">                    <span class="keyword">return</span> shouldLoad;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (_state) &#123;</span><br><span class="line">                <span class="keyword">case</span> STATE_WAITING_FOR_LOAD_FINISH:</span><br><span class="line">                    <span class="comment">// 重定向情况，判断loadCount是否是1</span></span><br><span class="line">                    <span class="keyword">if</span> (_loadCount != <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@"CDVWebViewDelegate: Detected redirect when loadCount=%ld"</span>, (<span class="keyword">long</span>)_loadCount);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> STATE_IDLE:</span><br><span class="line">                <span class="keyword">case</span> STATE_IOS5_POLLING_FOR_LOAD_START:</span><br><span class="line">                <span class="keyword">case</span> STATE_CANCELLED:</span><br><span class="line">                    <span class="comment">// 页面导航开始</span></span><br><span class="line">                    _loadCount = <span class="number">0</span>;</span><br><span class="line">                    _state = STATE_WAITING_FOR_LOAD_START;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 其它情况，回调webView:didFailLoadWithError:</span></span><br><span class="line">                        <span class="built_in">NSString</span>* description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"CDVWebViewDelegate: Navigation started when state=%ld"</span>, (<span class="keyword">long</span>)_state];</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, description);</span><br><span class="line">                        _loadCount = <span class="number">0</span>;</span><br><span class="line">                        _state = STATE_WAITING_FOR_LOAD_START;</span><br><span class="line">                        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(webView:didFailLoadWithError:)]) &#123;</span><br><span class="line">                            <span class="built_in">NSDictionary</span>* errorDictionary = @&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : description&#125;;</span><br><span class="line">                            <span class="built_in">NSError</span>* error = [[<span class="built_in">NSError</span> alloc] initWithDomain:<span class="string">@"CDVUIWebViewDelegate"</span> code:<span class="number">1</span> userInfo:errorDictionary];</span><br><span class="line">                            [_delegate webView:webView didFailLoadWithError:error];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 屏蔽一些无效网站的访问</span></span><br><span class="line">            shouldLoad = shouldLoad &amp;&amp; [<span class="keyword">self</span> shouldLoadRequest:request];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldLoad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截js调用原生插件请求的关键代码在<code>CDVUIWebViewNavigationDelegate</code>，它实现了<code>CDVUIWebViewDelegate</code>的代理，在<code>CDVUIWebViewDelegate</code>会把请求转发给它。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span>*)theWebView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span>*)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span>* url = [request URL];</span><br><span class="line">    CDVViewController* vc = (CDVViewController*)<span class="keyword">self</span>.enginePlugin.viewController;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// H5调用原生插件，后面分析</span></span><br><span class="line">    <span class="keyword">if</span> ([[url scheme] isEqualToString:<span class="string">@"gap"</span>]) &#123;</span><br><span class="line">        [vc.commandQueue fetchCommandsFromJs];</span><br><span class="line">        [vc.commandQueue executePending];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给插件预留了一个处理URL的方法，调用插件的方法`shouldOverrideLoadWithRequest:navigationType:`，获取返回值</span></span><br><span class="line">    <span class="comment">// 应用：系统默认插件CDVIntentAndNavigationFilter中，实现了Intent与Navigation的白名单机制。</span></span><br><span class="line">    <span class="built_in">BOOL</span> anyPluginsResponded = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> shouldAllowRequest = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span>* pluginName <span class="keyword">in</span> vc.pluginObjects) &#123;</span><br><span class="line">        CDVPlugin* plugin = [vc.pluginObjects objectForKey:pluginName];</span><br><span class="line">        SEL selector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"shouldOverrideLoadWithRequest:navigationType:"</span>);</span><br><span class="line">        <span class="keyword">if</span> ([plugin respondsToSelector:selector]) &#123;</span><br><span class="line">            anyPluginsResponded = <span class="literal">YES</span>;</span><br><span class="line">            shouldAllowRequest = (((<span class="built_in">BOOL</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>, <span class="keyword">int</span>))objc_msgSend)(plugin, selector, request, navigationType));</span><br><span class="line">            <span class="keyword">if</span> (!shouldAllowRequest) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (anyPluginsResponded) &#123;</span><br><span class="line">        <span class="keyword">return</span> shouldAllowRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 处理其它类型的url,file:类型直接返回YES</span></span><br><span class="line">    <span class="built_in">BOOL</span> shouldAllowNavigation = [<span class="keyword">self</span> defaultResourcePolicyForURL:url];</span><br><span class="line">    <span class="keyword">if</span> (shouldAllowNavigation) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotification:[<span class="built_in">NSNotification</span> notificationWithName:CDVPluginHandleOpenURLNotification object:url]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="H5调用原生插件"><a href="#H5调用原生插件" class="headerlink" title="H5调用原生插件"></a>H5调用原生插件</h3><p>Cordova调用原生插件的方式是通过拦截<code>gap://</code>的URL，然后执行js代码<code>cordova.require(&#39;cordova/exec&#39;).nativeFetchMessages()</code>获取参数，来实现调用。</p><p>我们来看关键代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVUIWebViewNavigationDelegate.m</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span>*)theWebView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span>*)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType</span><br><span class="line">&#123;</span><br><span class="line">    CDVViewController* vc = (CDVViewController*)<span class="keyword">self</span>.enginePlugin.viewController;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([[url scheme] isEqualToString:<span class="string">@"gap"</span>]) &#123;</span><br><span class="line">        [vc.commandQueue fetchCommandsFromJs];</span><br><span class="line">        [vc.commandQueue executePending];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)fetchCommandsFromJs</span><br><span class="line">&#123;</span><br><span class="line">    __<span class="keyword">weak</span> CDVCommandQueue* weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSString</span>* js = <span class="string">@"cordova.require('cordova/exec').nativeFetchMessages()"</span>;</span><br><span class="line"></span><br><span class="line">    [_viewController.webViewEngine evaluateJavaScript:js</span><br><span class="line">                                    completionHandler:^(<span class="keyword">id</span> obj, <span class="built_in">NSError</span>* error) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((error == <span class="literal">nil</span>) &amp;&amp; [obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span>* queuedCommandsJSON = (<span class="built_in">NSString</span>*)obj;</span><br><span class="line">            <span class="comment">// 调用的插件信息加入到queue中</span></span><br><span class="line">            [weakSelf enqueueCommandBatch:queuedCommandsJSON];</span><br><span class="line">            <span class="comment">// 调用执行方法</span></span><br><span class="line">            [<span class="keyword">self</span> executePending];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用js方法<code>cordova.require(&#39;cordova/exec&#39;).nativeFetchMessages()</code>，获取调用的插件信息。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 插件信息示例</span><br><span class="line">[[<span class="string">"DevicePlugin1678563772"</span>,<span class="string">"DevicePlugin"</span>,<span class="string">"getDeviceInfo"</span>,[]]]</span><br></pre></td></tr></table></figure><h3 id="命令队列CDVCommandQueue"><a href="#命令队列CDVCommandQueue" class="headerlink" title="命令队列CDVCommandQueue"></a>命令队列CDVCommandQueue</h3><p>js的每次调用信息会封装被封装为一个命令<code>CDVInvokedUrlCommand</code>，<code>CDVInvokedUrlCommand</code>继承自<code>NSObject</code>，主要存储了下面的信息：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVInvokedUrlCommand</span></span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>* arguments;</span><br><span class="line"><span class="comment">// 回调ID</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span>* callbackId;</span><br><span class="line"><span class="comment">// 类名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span>* className;</span><br><span class="line"><span class="comment">// 方法名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span>* methodName;</span><br></pre></td></tr></table></figure><p><code>CDVCommandQueue</code>管理着所有的命令，实现了一个命令的队列。在js调用原生插件时，会调用<code>CDVCommandQueue</code>的<code>enqueueCommandBatch:</code>方法，将插件调用信息加到<code>commandBatchHolder</code>数组中，最后<code>commandBatchHolder</code>数组添加到<code>CDVCommandQueue</code>的<code>queue</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enqueueCommandBatch:(<span class="built_in">NSString</span>*)batchJSON</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([batchJSON length] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span>* commandBatchHolder = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        [_queue addObject:commandBatchHolder];</span><br><span class="line">        <span class="keyword">if</span> ([batchJSON length] &lt; JSON_SIZE_FOR_MAIN_THREAD) &#123;</span><br><span class="line">            [commandBatchHolder addObject:[batchJSON cdv_JSONObject]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^() &#123;</span><br><span class="line">                <span class="built_in">NSMutableArray</span>* result = [batchJSON cdv_JSONObject];</span><br><span class="line">                <span class="keyword">@synchronized</span>(commandBatchHolder) &#123;</span><br><span class="line">                    [commandBatchHolder addObject:result];</span><br><span class="line">                &#125;</span><br><span class="line">                [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(executePending) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件的执行由<code>CDVCommandQueue</code>管理，每个<code>CDVViewController</code>有自己的队列，有两个重要的成员变量。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二维数组，存储着所有插件调用的json */</span></span><br><span class="line"><span class="built_in">NSMutableArray</span>* _queue;</span><br><span class="line"><span class="comment">/* 记录开始调用的时间 */</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> _startExecutionTime;</span><br></pre></td></tr></table></figure><p><code>executePending</code>负责执行命令队列中待执行的插件，具体实现就是遍历执行二维数组<code>queue</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)executePending</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果已经开始执行了，返回</span></span><br><span class="line">    <span class="keyword">if</span> (_startExecutionTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="comment">// 记录开始执行的时间</span></span><br><span class="line">        _startExecutionTime = [<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历_queue</span></span><br><span class="line">        <span class="keyword">while</span> ([_queue count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSMutableArray</span>* commandBatchHolder = _queue[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">NSMutableArray</span>* commandBatch = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">@synchronized</span>(commandBatchHolder) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([commandBatchHolder count] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                commandBatch = commandBatchHolder[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历commandBatch</span></span><br><span class="line">            <span class="keyword">while</span> ([commandBatch count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                    <span class="comment">// 取出commandBatch的第一条数据，并移除</span></span><br><span class="line">                    <span class="built_in">NSArray</span>* jsonEntry = [commandBatch cdv_dequeue];</span><br><span class="line">                    <span class="keyword">if</span> ([commandBatch count] == <span class="number">0</span>) &#123;</span><br><span class="line">                        [_queue removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 用插件调用json信息，创建CDVInvokedUrlCommand</span></span><br><span class="line">                    CDVInvokedUrlCommand* command = [CDVInvokedUrlCommand commandFromJson:jsonEntry];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 调用插件</span></span><br><span class="line">                    [<span class="keyword">self</span> execute:command]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对于性能的一个优化，后面会详细说</span></span><br><span class="line">                <span class="keyword">if</span> (([_queue count] &gt; <span class="number">0</span>) &amp;&amp; ([<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate] - _startExecutionTime &gt; MAX_EXECUTION_TIME)) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(executePending) withObject:<span class="literal">nil</span> afterDelay:<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">@finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        _startExecutionTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用Runloop优化性能"><a href="#用Runloop优化性能" class="headerlink" title="用Runloop优化性能"></a>用Runloop优化性能</h3><p>Cordova对于插件的执行进行了优化，保证页面的流程度，运用了RunLoop，巧妙的将代码分割为多块分次执行，避免由于插件执行导致主线程阻塞，影响页面绘制，导致掉帧。具体代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVCommandQueue.m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MAX_EXECUTION_TIME ≈ 1s / 60 / 2</span></span><br><span class="line"><span class="comment">// 计算出绘制一帧时间的一半</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> MAX_EXECUTION_TIME = <span class="number">.008</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断本次执行时间，如果大于MAX_EXECUTION_TIME，调用performSelector:withObject:afterDelay，结束本次调用</span></span><br><span class="line"><span class="keyword">if</span> (([_queue count] &gt; <span class="number">0</span>) &amp;&amp; ([<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate] - _startExecutionTime &gt; MAX_EXECUTION_TIME)) &#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(executePending) withObject:<span class="literal">nil</span> afterDelay:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化策略分析：</p><ul><li>将队列中的插件分割为很多小块来执行</li><li>开始执行<code>executePending</code>方法时，记录开始时间，每次执行完一个插件方法后，判断本次执行时间是否超过<code>MAX_EXECUTION_TIME</code>，如果没有超过，继续执行，如果超过了<code>MAX_EXECUTION_TIME</code>，调用<code>performSelector:withObject:afterDelay</code>，结束本次调用</li><li>如果要保证UI流畅，需要满足条件<code>CPU时间 + GPU时间 &lt;= 1s/60</code>， 为了给GPU留下足够的时间渲染，要尽量让CPU占用时间小于<code>1s/60/2</code></li><li>Runloop执行的流程如下图所示，系统在收到<code>kCFRunLoopBeforeWaiting</code>（线程即将休眠）通知时，会触发一次界面的渲染，也就是在完成<code>source0</code>的处理后</li><li><code>source0</code>在这里就是插件的执行代码，在<code>kCFRunLoopBeforeWaiting</code>通知之前，如果<code>source0</code>执行时间过长就会导致界面没有得到及时的刷新。</li><li>函数<code>performSelector:withObject:afterDelay</code>，会将方法注册到<code>Timer</code>，结束<code>source0</code>调用，开始渲染界面。界面渲染完成后，<code>Runloop</code>开始<code>sleep</code>，然后被<code>timer</code>唤醒又开始继续处理<code>source0</code>。</li></ul><p><img src="/images/15256833278020.png" alt=""></p><h3 id="插件方法执行"><a href="#插件方法执行" class="headerlink" title="插件方法执行"></a>插件方法执行</h3><p>方法最终的执行在方法<code>execute:</code>中，从command中取出要执行的插件类、方法、参数，然后执行方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)execute:(CDVInvokedUrlCommand*)command</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取插件实例</span></span><br><span class="line">    CDVPlugin* obj = [_viewController.commandDelegate getCommandInstance:command.className];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> retVal = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">double</span> started = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970] * <span class="number">1000.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span>* methodName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@:"</span>, command.methodName];</span><br><span class="line">    SEL normalSelector = <span class="built_in">NSSelectorFromString</span>(methodName);</span><br><span class="line">    <span class="keyword">if</span> ([obj respondsToSelector:normalSelector]) &#123;</span><br><span class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))objc_msgSend)(obj, normalSelector, command);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// There's no method to call, so throw an error.</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"ERROR: Method '%@' not defined in Plugin '%@'"</span>, methodName, command.className);</span><br><span class="line">        retVal = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> elapsed = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970] * <span class="number">1000.0</span> - started;</span><br><span class="line">    <span class="comment">// 监控插件方法执行时间，打印出大于10ms的方法</span></span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"THREAD WARNING: ['%@'] took '%f' ms. Plugin should use a background thread."</span>, command.className, elapsed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原生回调js"><a href="#原生回调js" class="headerlink" title="原生回调js"></a>原生回调js</h3><p>原生方法执行完成后，会把结果返回给js，调用方法<code>sendPluginResult:callbackId:</code>，用<code>CDVPluginResult</code>来传递回调参数，用<code>callbackId</code>来区分是哪次调用（callbackId由js产生）。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVCommandDelegateImpl.m</span></span><br><span class="line">- (<span class="keyword">void</span>)sendPluginResult:(CDVPluginResult*)result callbackId:(<span class="built_in">NSString</span>*)callbackId</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断callbackId长度是否小于100</span></span><br><span class="line">    <span class="comment">// 用正则表达式"[^A-Za-z0-9._-]"来验证callbackId</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> isValidCallbackId:callbackId]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态码</span></span><br><span class="line">    <span class="keyword">int</span> status = [result.status intValue];</span><br><span class="line">    <span class="comment">// 是否持续回调</span></span><br><span class="line">    <span class="built_in">BOOL</span> keepCallback = [result.keepCallback boolValue];</span><br><span class="line">    <span class="comment">// 会带哦参数</span></span><br><span class="line">    <span class="built_in">NSString</span>* argumentsAsJSON = [result argumentsAsJSON];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行js方法，回调</span></span><br><span class="line">    <span class="built_in">NSString</span>* js = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"cordova.require('cordova/exec').nativeCallback('%@',%d,%@,%d, %d)"</span>, callbackId, status, argumentsAsJSON, keepCallback, debug];</span><br><span class="line">    [<span class="keyword">self</span> evalJsHelper:js];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CDVPlugin注册与初始化"><a href="#CDVPlugin注册与初始化" class="headerlink" title="CDVPlugin注册与初始化"></a>CDVPlugin注册与初始化</h2><p>我们先看看配置文件中插件的定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义插件名为HandleOpenUrl的插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">feature</span> <span class="attr">name</span>=<span class="string">"HandleOpenUrl"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对应的iOS类名是CDVHandleOpenURL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ios-package"</span> <span class="attr">value</span>=<span class="string">"CDVHandleOpenURL"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 需要默认加载的插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"onload"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">feature</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="加载默认插件"><a href="#加载默认插件" class="headerlink" title="加载默认插件"></a>加载默认插件</h3><p>在<code>CDVViewController</code>的<code>viewDidLoad</code>时，从Cordova的配置文件<code>config.xml</code>中，读取出需要默认加载的插件，遍历初始化。</p><p><code>CDVViewController</code>中初始化默认插件代码。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    <span class="comment">// Load settings</span></span><br><span class="line">    [<span class="keyword">self</span> loadSettings];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.startupPluginNames count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [CDVTimer start:<span class="string">@"TotalPluginStartup"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span>* pluginName <span class="keyword">in</span> <span class="keyword">self</span>.startupPluginNames) &#123;</span><br><span class="line">            [CDVTimer start:pluginName];</span><br><span class="line">            <span class="comment">// 初始化插件</span></span><br><span class="line">            [<span class="keyword">self</span> getCommandInstance:pluginName];</span><br><span class="line">            [CDVTimer stop:pluginName];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [CDVTimer stop:<span class="string">@"TotalPluginStartup"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插件初始化"><a href="#插件初始化" class="headerlink" title="插件初始化"></a>插件初始化</h3><p>插件初始化的过程：</p><ol><li>加载配置文件<code>config.xml</code></li><li>根据插件名获取对应类名</li><li>根据类名从缓存中查找，如果命中直接返回</li><li>没有缓存重新创建一个实例，并写入缓存</li></ol><p>插件初始化的入口是<code>getCommandInstance</code>，传入参数是插件名称，返回一个插件的实例对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)getCommandInstance:(<span class="built_in">NSString</span>*)pluginName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在pluginsMap中用插件名称获取类名（插件名不区分大小写）</span></span><br><span class="line">    <span class="built_in">NSString</span>* className = [<span class="keyword">self</span>.pluginsMap objectForKey:[pluginName lowercaseString]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有配置插件，初始化失败</span></span><br><span class="line">    <span class="keyword">if</span> (className == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从缓存中获取，如果命中直接返回缓存</span></span><br><span class="line">    <span class="keyword">id</span> obj = [<span class="keyword">self</span>.pluginObjects objectForKey:className];</span><br><span class="line">    <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">        <span class="comment">// 没有缓存，创建一个新的实例</span></span><br><span class="line">        obj = [[<span class="built_in">NSClassFromString</span>(className)alloc] initWithWebViewEngine:_webViewEngine];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">// 实例创建成功，注册插件</span></span><br><span class="line">            [<span class="keyword">self</span> registerPlugin:obj withClassName:className];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"CDVPlugin class %@ (pluginName: %@) does not exist."</span>, className, pluginName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册插件的关键方法<code>registerPlugin:withClassName:</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerPlugin:(CDVPlugin*)plugin withClassName:(<span class="built_in">NSString</span>*)className</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([plugin respondsToSelector:<span class="keyword">@selector</span>(setViewController:)]) &#123;</span><br><span class="line">        [plugin setViewController:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([plugin respondsToSelector:<span class="keyword">@selector</span>(setCommandDelegate:)]) &#123;</span><br><span class="line">        [plugin setCommandDelegate:_commandDelegate];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入缓存</span></span><br><span class="line">    [<span class="keyword">self</span>.pluginObjects setObject:plugin forKey:className];</span><br><span class="line">    [plugin pluginInitialize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cordova还提供了插件名注册插件的方式，使用函数<code>registerPlugin:withPluginName:</code>，实现方式差不多，就不赘述了。</p><p>注册插件步骤</p><ol><li>设置插件的<code>viewController</code>和<code>delegate</code></li><li>将插件以<code>className</code>为key放入<code>pluginObjects</code>中，<code>pluginObjects</code>是一个插件的缓存</li><li>调用插件的<code>pluginInitialize</code></li></ol><h3 id="插件销毁"><a href="#插件销毁" class="headerlink" title="插件销毁"></a>插件销毁</h3><p>插件销毁的时机是创建插件的<code>CDVViewController</code>释放的时候，因为插件实例被创建后被缓存map引用，对应的销毁代码。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVViewController.m</span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    [CDVUserAgentUtil releaseLock:&amp;_userAgentLockToken];</span><br><span class="line">    [_commandQueue dispose];</span><br><span class="line">    [[<span class="keyword">self</span>.pluginObjects allValues] makeObjectsPerformSelector:<span class="keyword">@selector</span>(dispose)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CDVPlugin.m</span></span><br><span class="line">- (<span class="keyword">void</span>)dispose</span><br><span class="line">&#123;</span><br><span class="line">    viewController = <span class="literal">nil</span>;</span><br><span class="line">    commandDelegate = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>在<code>config.xml</code>文件中配置插件，声明插件与类的映射关系，以及加载策略</li><li>插件的初始化时懒加载，除了<code>onload</code>配置为<code>YES</code>的插件会默认加载，其它插件都是使用时加载</li><li>插件使用了两个Map来缓存，<code>pluginObjects</code>建立了类名与插件实例对象的映射，<code>pluginsMap</code>建立了插件名与类名的映射。</li><li>在一个<code>CDVViewController</code>中，同一个插件同时只会存在一个实例</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文设计到的源码是基于Cordova 4.2.1版本，&lt;a href=&quot;https://cordova.apache.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cordova官网&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;CDVViewControll
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅析AutoreleasePool源码</title>
    <link href="http://crmo.github.io/2018/04/14/%E6%B5%85%E6%9E%90AutoreleasePool%E6%BA%90%E7%A0%81/"/>
    <id>http://crmo.github.io/2018/04/14/浅析AutoreleasePool源码/</id>
    <published>2018-04-14T07:31:00.000Z</published>
    <updated>2018-04-14T07:31:28.990Z</updated>
    
    <content type="html"><![CDATA[<p>最近在拜读Draveness大佬的一篇文章<a href="https://draveness.me/autoreleasepool" target="_blank" rel="noopener">自动释放池的前世今生 —- 深入解析 autoreleasepool</a>，看到文中给读者留了一个问题：</p><blockquote><p>我到现在也不是很清楚为什么要根据当前页的不同状态 kill 掉不同 child 的页面。</p></blockquote><p>关于<code>AutoreleasePool</code>是什么，强力推荐阅读原文，写的很好。这里就不说了，直接讨论问题。</p><p>首先是整个<code>pop</code>方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static inline void pop(void *token) </span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        // Popping the top-level placeholder pool.</span><br><span class="line">        if (hotPage()) &#123;</span><br><span class="line">            // Pool was used. Pop its contents normally.</span><br><span class="line">            // Pool pages remain allocated for re-use as usual.</span><br><span class="line">            pop(coldPage()-&gt;begin());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Pool was never used. Clear the placeholder.</span><br><span class="line">            setHotPage(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);</span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    if (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        if (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            // Start of coldest page may correctly not be POOL_BOUNDARY:</span><br><span class="line">            // 1. top-level pool is popped, leaving the cold page in place</span><br><span class="line">            // 2. an object is autoreleased with no pool</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Error. For bincompat purposes this is not </span><br><span class="line">            // fatal in executables built with old SDKs.</span><br><span class="line">            return badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (PrintPoolHiwat) printHiwat();</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    // memory: delete empty children</span><br><span class="line">    if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        // special case: delete everything during page-per-pool debugging</span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        // special case: delete everything for pop(top) </span><br><span class="line">        // when debugging missing autorelease pools</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    else if (page-&gt;child) &#123;</span><br><span class="line">        // hysteresis: keep one empty child if page is more than half fully</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先看看释放的函数<code>releaseUntil</code>，它在释放的时候其实会一直顺着<code>parent</code>往前释放，直到参数<code>stop</code>，也就是说可能一次性释放好几个<code>page</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 代码有所删减</span><br><span class="line">void releaseUntil(id *stop)</span><br><span class="line">&#123;</span><br><span class="line">    while (this-&gt;next != stop) &#123;</span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line">        </span><br><span class="line">        while (page-&gt;empty()) &#123;</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        id obj = *--page-&gt;next;</span><br><span class="line">        memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));</span><br><span class="line">        </span><br><span class="line">        if (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    setHotPage(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们来看看这段有疑问的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// memory: delete empty children</span><br><span class="line">if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;  // 分支1</span><br><span class="line">    // special case: delete everything during page-per-pool debugging</span><br><span class="line">    AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">    page-&gt;kill();</span><br><span class="line">    setHotPage(parent);</span><br><span class="line">&#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123; // 分支2</span><br><span class="line">    // special case: delete everything for pop(top) </span><br><span class="line">    // when debugging missing autorelease pools</span><br><span class="line">    page-&gt;kill();</span><br><span class="line">    setHotPage(nil);</span><br><span class="line">&#125; </span><br><span class="line">else if (page-&gt;child) &#123; // 分支3</span><br><span class="line">    // hysteresis: keep one empty child if page is more than half fully</span><br><span class="line">    if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">        page-&gt;child-&gt;kill();</span><br><span class="line">    &#125;</span><br><span class="line">    else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">        page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码的作用是删除空的子节点，释放内存。pop之后三种情况：</p><ol><li>当前<code>page</code>为空，直接kill掉当前<code>page</code>，然后把<code>parent</code>设置为<code>hotpage</code>；</li><li>当前<code>page</code>为空，而且没有<code>parent</code>，kill掉当前<code>page</code>，<code>hotpage</code>置为空；</li><li>当前<code>page</code>不为空，但是有<code>child</code>，如果当前<code>page</code>的空间占用不到一半，释放<code>child</code>，如果当前<code>page</code>的空间占用超过一半，且<code>child</code>还有<code>child</code>，直接释放这个孙子辈的<code>page</code>。（对于第三步注释中的解释是：keep one empty child if page is more than half fully）</li></ol><p>我们再看看<code>kill</code>的实现，可以发现他是会顺着<code>child</code>一直往后释放，保证释放节点的<code>child page</code>都被释放了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void kill()</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page = this;</span><br><span class="line">    while (page-&gt;child) page = page-&gt;child;</span><br><span class="line">    </span><br><span class="line">    AutoreleasePoolPage *deathptr;</span><br><span class="line">    do &#123;</span><br><span class="line">        deathptr = page;</span><br><span class="line">        page = page-&gt;parent;</span><br><span class="line">        if (page) &#123;</span><br><span class="line">            page-&gt;unprotect();</span><br><span class="line">            page-&gt;child = nil;</span><br><span class="line">            page-&gt;protect();</span><br><span class="line">        &#125;</span><br><span class="line">        delete deathptr;</span><br><span class="line">    &#125; while (deathptr != this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就可以得出结论了：</p><ol><li>pop之后，所有<code>child page</code>肯定都为空了，且当前<code>page</code>一定是<code>hotPage</code></li><li>系统为了节约内存，判断，如果当前<code>page</code>空间使用少于一半，就释放掉所有的<code>child page</code>，如果当前<code>page</code>空间使用大于一半，就从孙子<code>page</code>开始释放，预留一个<code>child page</code>。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在拜读Draveness大佬的一篇文章&lt;a href=&quot;https://draveness.me/autoreleasepool&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自动释放池的前世今生 —- 深入解析 autoreleasepool&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS用原生代码读写Webview的Local Storage</title>
    <link href="http://crmo.github.io/2018/04/03/iOS%E7%94%A8%E5%8E%9F%E7%94%9F%E4%BB%A3%E7%A0%81%E8%AF%BB%E5%86%99Webview%E7%9A%84Local%20Storage/"/>
    <id>http://crmo.github.io/2018/04/03/iOS用原生代码读写Webview的Local Storage/</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-04-03T12:41:51.225Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/15226724314775.jpg" alt=""></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司项目使用的<code>Cordova</code>混合开发的，有一个模块以前用H5实现的，新版本用原生来实现，于是需要迁移数据。H5使用的Local Storage存的数据，原生要拿到数据有两种方案：</p><ol><li>用<code>WebView</code>执行js方法来读取数据；</li><li>找到<code>Local Storage</code>存储路径，直接读取；</li></ol><p>方案一实现起来比较简单，但是会存在一些问题，需要多开一个Webview来迁移数据，而且这个过程不好控制，不是最优解，本文讨论的是方案二。</p><h2 id="直接读写Local-Storage"><a href="#直接读写Local-Storage" class="headerlink" title="直接读写Local Storage"></a>直接读写Local Storage</h2><p>先说结论，<code>Local Storage</code>的其实是一个Sqlite数据库，我们要读写数据只要找到这个数据库，然后就可以实现手动读写了。</p><h3 id="数据库存放路径"><a href="#数据库存放路径" class="headerlink" title="数据库存放路径"></a>数据库存放路径</h3><blockquote><p>iOS 5.1及之前使用UIWebView：Library/Caches/<br>iOS 5.1之后使用UIWebView：Library/WebKit/LocalStorage/<br>WKWebView：Library/WebKit/WebsiteData/LocalStorage/</p></blockquote><blockquote><p>// UIWebView可以从UserDefault取出LocalStorage的路径<br>[[NSUserDefaults standardUserDefaults] objectForKey:@”WebKitLocalStorageDatabasePathPreferenceKey”]</p></blockquote><p><img src="/images/15226716925888.jpg" alt=""></p><h3 id="数据存储方式"><a href="#数据存储方式" class="headerlink" title="数据存储方式"></a>数据存储方式</h3><p>数据存在<code>ItemTable</code>表，只有<code>key</code>和<code>value</code>两个字段，key直接用NSString可以取出来，value取出来是一个NSData，需要用<code>NSUTF16LittleEndianStringEncoding</code>解码。</p><p><img src="/images/15226719772136.jpg" alt=""></p><h3 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h3><p>写了个简易的Demo，用的<a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a>来操作数据库，这里就不介绍了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 取数据</span><br><span class="line">- (NSString *)valueWithKey:(NSString *)key &#123;</span><br><span class="line">    if ([NSString isNull:key]) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __block NSString *result;</span><br><span class="line">    [self.dataQueue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">        NSData *data = [db dataForQuery:@&quot;select value from ItemTable where key = ?&quot;, key];</span><br><span class="line">        result = [[NSString alloc] initWithData:data encoding:NSUTF16LittleEndianStringEncoding];</span><br><span class="line">    &#125;];</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 存数据</span><br><span class="line">- (BOOL)saveValue:(NSString *)value forKey:(NSString *)key &#123;</span><br><span class="line">    if ([NSString isNull:value] ||</span><br><span class="line">        [NSString isNull:key]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __block BOOL result;</span><br><span class="line">    [self.dataQueue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">        [db executeUpdate:@&quot;delete from ItemTable where key = ?&quot;, key];</span><br><span class="line">        NSData *data = [value dataUsingEncoding:NSUTF16LittleEndianStringEncoding];</span><br><span class="line">        result = [db executeUpdate:@&quot;insert into ItemTable (key, value) values (?, ?)&quot;, key, data];</span><br><span class="line">    &#125;];</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebKit源码分析"><a href="#WebKit源码分析" class="headerlink" title="WebKit源码分析"></a>WebKit源码分析</h2><p>为了找到<code>Local Storage</code>存放的路径，在网上找了很多资料，发现这方面的资料很少，也没有怕出现各种坑或者系统版本兼容，于是决定研究下WebKit源码，从源码里面找答案。</p><p>Webkit、WebCore<a href="https://opensource.apple.com/release/ios-110.html" target="_blank" rel="noopener">源码地址</a>。可以看到WebKit有两个版本，<code>WebKit-7604.1.38.0.7</code>和<code>WebKit2-7604.1.38.0.7</code>，前者是UIWebView的，后者是WKWebView的。</p><p><img src="/images/15226724314772.jpg" alt=""></p><p>解压<code>WebKit-7604.1.38.0.7</code>。用Xcode打开工程文件，工程名叫<code>WebKitLegacy</code>，这个命名太形象了，WebKit的遗产。苦于各种历史原因，公司项目还停留在UIWebView的阶段，心塞。<br>在WebStorageManager.m类中可以看到关于<code>Local Storage</code>保存路径的定义，路径是<code>Library/WebKit/LocalStorage/</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void initializeLocalStoragePath()</span><br><span class="line">&#123;</span><br><span class="line">    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">    sLocalStoragePath = [defaults objectForKey:WebStorageDirectoryDefaultsKey];</span><br><span class="line">    if (!sLocalStoragePath || ![sLocalStoragePath isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">        NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);</span><br><span class="line">        NSString *libraryDirectory = [paths objectAtIndex:0];</span><br><span class="line">        sLocalStoragePath = [libraryDirectory stringByAppendingPathComponent:@&quot;WebKit/LocalStorage&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    sLocalStoragePath = [[sLocalStoragePath stringByStandardizingPath] retain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解压<code>WebKit2-7604.1.38.0.7</code>，路径定义在<code>WKProcessPool.mm</code>类中，路径是<code>Library/WebKit/WebsiteData/LocalStorage/</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURL *)_websiteDataURLForContainerWithURL:(NSURL *)containerURL bundleIdentifierIfNotInContainer:(NSString *)bundleIdentifier</span><br><span class="line">&#123;</span><br><span class="line">    NSURL *url = [containerURL URLByAppendingPathComponent:@&quot;Library&quot; isDirectory:YES];</span><br><span class="line">    url = [url URLByAppendingPathComponent:@&quot;WebKit&quot; isDirectory:YES];</span><br><span class="line"></span><br><span class="line">    if (!WebKit::processHasContainer() &amp;&amp; bundleIdentifier)</span><br><span class="line">        url = [url URLByAppendingPathComponent:bundleIdentifier isDirectory:YES];</span><br><span class="line"></span><br><span class="line">    return [url URLByAppendingPathComponent:@&quot;WebsiteData&quot; isDirectory:YES];</span><br></pre></td></tr></table></figure><p>至此关于<code>UIWebView</code>和<code>WKWebView</code>的存放路径我们已经能够确定了，那么文件名是怎么定义的呢，这要看<code>WebCore</code>的源码了，在<code>SecurityOriginData.cpp</code>中定义了文件名命名规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String SecurityOriginData::databaseIdentifier() const</span><br><span class="line">&#123;</span><br><span class="line">    // Historically, we&apos;ve used the following (somewhat non-sensical) string</span><br><span class="line">    // for the databaseIdentifier of local files. We used to compute this</span><br><span class="line">    // string because of a bug in how we handled the scheme for file URLs.</span><br><span class="line">    // Now that we&apos;ve fixed that bug, we still need to produce this string</span><br><span class="line">    // to avoid breaking existing persistent state.</span><br><span class="line">    if (equalIgnoringASCIICase(protocol, &quot;file&quot;))</span><br><span class="line">        return ASCIILiteral(&quot;file__0&quot;);</span><br><span class="line">    </span><br><span class="line">    StringBuilder stringBuilder;</span><br><span class="line">    stringBuilder.append(protocol);</span><br><span class="line">    stringBuilder.append(separatorCharacter);</span><br><span class="line">    stringBuilder.append(encodeForFileName(host));</span><br><span class="line">    stringBuilder.append(separatorCharacter);</span><br><span class="line">    stringBuilder.appendNumber(port.value_or(0));</span><br><span class="line">    </span><br><span class="line">    return stringBuilder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码我们可以得出结论，如果是file协议的url，文件名定义为<code>file__0</code>，否则会根据它的url来生成一个文件名。</p><p>在跟代码的时候，发现<code>UIWebView</code>会把<code>Local Storage</code>的存储路径存在<code>UserDefault</code>里，存储的Key是<code>WebKitLocalStorageDatabasePathPreferenceKey</code>（定义在<code>WebPreferenceKeysPrivate.h</code>）。在文件<code>WebPrefences.mm</code>中可以找到相关代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)_localStorageDatabasePath</span><br><span class="line">&#123;</span><br><span class="line">    return [[self _stringValueForKey:WebKitLocalStorageDatabasePathPreferenceKey] stringByStandardizingPath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSString *)_stringValueForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    id s = [self _valueForKey:key];</span><br><span class="line">    return [s isKindOfClass:[NSString class]] ? (NSString *)s : nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)_valueForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_key = KEY(key);</span><br><span class="line">#if PLATFORM(IOS)</span><br><span class="line">    __block id o = nil;</span><br><span class="line">    dispatch_sync(_private-&gt;readWriteQueue, ^&#123;</span><br><span class="line">        o = [_private-&gt;values.get() objectForKey:_key];</span><br><span class="line">    &#125;);</span><br><span class="line">#else</span><br><span class="line">    id o = [_private-&gt;values.get() objectForKey:_key];</span><br><span class="line">#endif</span><br><span class="line">    if (o)</span><br><span class="line">        return o;</span><br><span class="line">    o = [[NSUserDefaults standardUserDefaults] objectForKey:_key];</span><br><span class="line">    if (!o &amp;&amp; key != _key)</span><br><span class="line">        o = [[NSUserDefaults standardUserDefaults] objectForKey:key];</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Local-Storage存在的问题"><a href="#Local-Storage存在的问题" class="headerlink" title="Local Storage存在的问题"></a>Local Storage存在的问题</h2><p>在查询资料的过程中，发现了很多Local Storage的缺陷，有一篇关于Local Storage的<a href="https://thinkmind.org/download.php?articleid=mobility_2017_2_10_90007" target="_blank" rel="noopener">论文</a>可以参考。有以下几点：</p><ol><li>不要用Local Storage来做持久化存储，在iOS中，出现存储空间紧张时，它会被系统清理掉；</li><li>不要用Local Storage来存大数据，它的读写效率很低下，因为它需要序列化/反序列化</li><li>它有5M的大小限制</li></ol><p>总结起来就一句话，不要滥用Local Storage。有很多替代方案，比如<a href="https://github.com/TheCocoaProject/cordova-plugin-nativestorage" target="_blank" rel="noopener">https://github.com/TheCocoaProject/cordova-plugin-nativestorage</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/wootwoot1234/react-native-webkit-localstorage-reader/issues/4" target="_blank" rel="noopener">https://github.com/wootwoot1234/react-native-webkit-localstorage-reader/issues/4</a><br><a href="https://blog.csdn.net/shuimuniao/article/details/8027276" target="_blank" rel="noopener">https://blog.csdn.net/shuimuniao/article/details/8027276</a><br><a href="https://stackoverflow.com/questions/26465409/restore-localstorage-data-from-old-cordova-app/49604587#49604587" target="_blank" rel="noopener">https://stackoverflow.com/questions/26465409/restore-localstorage-data-from-old-cordova-app/49604587#49604587</a><br><a href="https://stackoverflow.com/questions/9067249/how-do-i-access-html5-local-storage-created-by-phonegap-on-ios/49604541#49604541" target="_blank" rel="noopener">https://stackoverflow.com/questions/9067249/how-do-i-access-html5-local-storage-created-by-phonegap-on-ios/49604541#49604541</a><br><a href="https://issues.apache.org/jira/browse/CB-12509" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/CB-12509</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/15226724314775.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;公司项目使用的&lt;code&gt;Cord
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AFNetworking下载文件时文件名长度的坑</title>
    <link href="http://crmo.github.io/2018/03/29/AFNetworking%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%97%B6%E6%96%87%E4%BB%B6%E5%90%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E5%9D%91/"/>
    <id>http://crmo.github.io/2018/03/29/AFNetworking下载文件时文件名长度的坑/</id>
    <published>2018-03-29T14:23:00.000Z</published>
    <updated>2018-03-28T14:24:52.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近遇到一个Bug，在用AFNetworking下载文件的时候莫名其妙的失败了，跟了一下发现一个小坑，记录一下防止以后再掉进去。</p><blockquote><p>iOS和Linux的文件名的长度限制相同都是255个字符！！！</p></blockquote><p>问题根源是文件名超度超过了255个字符，AFNetworking下载文件是成功了（框架会把文件下载到一个临时文件，例如：<code>CFNetworkDownload_xxx.tmp</code>，这个文件名不会出现过长的问题），下载成功之后会copy到调用者指定路径，在这里指定的文件名超过了255个字符，导致创建文件失败，于是回调是成功了，但是在设置的路径找不到这个文件。</p><p>上代码！</p><p>下载代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 注意对文件名长度进行处理！！！</span><br><span class="line">NSString *destination = @&quot;下载地址（长度大于255）&quot;;</span><br><span class="line">NSURLSessionDownloadTask *aTask = [self.updownloadSessionManager downloadTaskWithRequest:mutableRequest progress:^(NSProgress * _Nonnull downloadProgress) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123;</span><br><span class="line">        return [NSURL fileURLWithPath:destination];</span><br><span class="line">    &#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) &#123;</span><br><span class="line">        // 下载成功后会回调该block，但是路径`destination`找不到这个文件</span><br><span class="line">    &#125;];</span><br><span class="line">    [aTask resume];</span><br></pre></td></tr></table></figure><p>出错的地方<strong>AFURLSessionManager.m</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">    self.downloadFileURL = nil;</span><br><span class="line"></span><br><span class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        if (self.downloadFileURL) &#123;</span><br><span class="line">            NSError *fileManagerError = nil;</span><br><span class="line"></span><br><span class="line">            // location是临时文件，是下载成功了</span><br><span class="line">            // self.downloadFileURL 是目标路径，文件名超过255</span><br><span class="line">            // 移动文件会报错</span><br><span class="line">            if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError]) &#123;</span><br><span class="line">            // 出错会发通知，可以监听处理</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看<code>AFURLSessionDownloadTaskDidFailToMoveFileNotification</code>的定义<br><strong>AFURLSessionManager.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> Posted when a session download task encountered an error when moving the temporary download file to a specified destination.</span><br><span class="line"> */</span><br><span class="line">FOUNDATION_EXPORT NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近遇到一个Bug，在用AFNetworking下载文件的时候莫名其妙的失败了，跟了一下发现一个小坑，记录一下防止以后再掉进去。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS用CallKit实现来电识别、来电拦截</title>
    <link href="http://crmo.github.io/2018/03/03/iOS%E7%94%A8CallKit%E5%AE%9E%E7%8E%B0%E6%9D%A5%E7%94%B5%E8%AF%86%E5%88%AB&amp;%E6%9D%A5%E7%94%B5%E6%8B%A6%E6%88%AA/"/>
    <id>http://crmo.github.io/2018/03/03/iOS用CallKit实现来电识别&amp;来电拦截/</id>
    <published>2018-03-03T09:33:54.000Z</published>
    <updated>2018-05-29T12:21:06.586Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2018.5.28日更新<br>CallKit在国内已经被禁止上架了，亲测被拒。企业版还能继续使用，想上架就乖乖屏蔽吧（要是哪位同学成功上架了一定私信我怎么做到的。）</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近需要实现一个新需求，用iOS 10出的CallKit实现将APP的通讯录的信息同步到系统中，可以不把人员信息加到通讯录中，实现来电号码识别。这个功能在xx安全卫士、xx管家中很早就实现了，但是网上相关的资料较少，而且官方的文档写的太简单了，很多坑还要自己去摸索。于是记录一下和各位分享，如有错误之处请各位指出！</p></blockquote><p>PS: 先说个题外话吧，CallKit功能在iOS 10的时候还不太稳定，iOS 10刚出来的时候为了体验骚扰拦截功能，手贱装了两个不同的拦截APP，然后就悲剧了。盗一张网上的图：</p><p><img src="http://upload-images.jianshu.io/upload_images/2665383-e1a2d7ab18506810.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p><p>然后各种重启、重装APP都没有用，写的Demo也跑不起来，唯一的办法只有重置系统。说多了都是泪！</p><blockquote><p>本文涉及的<a href="https://github.com/crmo/CRCallDirectoryDemo" target="_blank" rel="noopener">Demo</a>。</p></blockquote><h2 id="一、Call-Directory-app-extension"><a href="#一、Call-Directory-app-extension" class="headerlink" title="一、Call Directory app extension"></a>一、Call Directory app extension</h2><p>实现来电识别、来电拦截功能需要使用CallKit当中的<code>Call Directory app extension</code>，首先，需要了解extension。关于extension网上有很多教程，这里就不细说了。推荐两篇文章，英文好的推荐看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html" target="_blank" rel="noopener">官方文档</a>，还有一篇<a href="http://foggry.com/blog/2014/06/23/wwdc2014zhi-app-extensionsxue-xi-bi-ji/" target="_blank" rel="noopener">中文博客</a>。</p><p>使用Call Directory Extension主要需要和3个类打交道，分别是<br><code>CXCallDirectoryProvider</code>、<code>CXCallDirectoryExtensionContext</code>、<code>CXCallDirectoryManager</code>。</p><p><img src="http://upload-images.jianshu.io/upload_images/2665383-c7c5d8e8809480bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p><h3 id="CXCallDirectoryProvider"><a href="#CXCallDirectoryProvider" class="headerlink" title="CXCallDirectoryProvider"></a>CXCallDirectoryProvider</h3><blockquote><p>官方文档：The principal object for a Call Directory app extension for a host app.</p></blockquote><p>正如官方文档所说，这是Call Directory app extension最重要的一个类。<br>用系统模板新建Call Directory Extension之后会自动生成一个类，继承自<code>CXCallDirectoryProvider</code>。入口方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有两种情况改方法会被调用</span></span><br><span class="line"><span class="comment">// 1.第一次打开设置-电话-来电阻止与身份识别开关时，系统自动调用</span></span><br><span class="line"><span class="comment">// 2.调用CXCallDirectoryManager的reloadExtensionWithIdentifier方法会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)beginRequestWithExtensionContext:(CXCallDirectoryExtensionContext *)context &#123;</span><br><span class="line">    context.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 添加号码识别信息与号码拦截列表</span></span><br><span class="line">    [<span class="keyword">self</span> addIdentificationPhoneNumbersToContext:context];</span><br><span class="line">    [context completeRequestWithCompletionHandler:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="CXCallDirectoryExtensionContext"><a href="#CXCallDirectoryExtensionContext" class="headerlink" title="CXCallDirectoryExtensionContext"></a>CXCallDirectoryExtensionContext</h3><blockquote><p>官方文档：A programmatic interface for adding identification and blocking entries to a Call Directory app extension.<br>CXCallDirectoryExtensionContext objects are not initialized directly, but are instead passed as arguments to the CXCallDirectoryProvider instance method beginRequestWithExtensionContext:.</p></blockquote><p>大致意思就是说，这是一个为Call Directory app extension添加号码识别、号码拦截的入口。<code>CXCallDirectoryExtensionContext</code>不需要自己初始化，它会作为<code>CXCallDirectoryProvider</code>的<code>beginRequestWithExtensionContext</code>函数的参数传递给使用者。<br>它的主要方法有两个：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置号码识别信息</span></span><br><span class="line">- (<span class="keyword">void</span>)addIdentificationEntryWithNextSequentialPhoneNumber:(CXCallDirectoryPhoneNumber)phoneNumber label:(<span class="built_in">NSString</span> *)label;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置号码拦截列表</span></span><br><span class="line">- (<span class="keyword">void</span>)addBlockingEntryWithNextSequentialPhoneNumber:(CXCallDirectoryPhoneNumber)phoneNumber;</span><br></pre></td></tr></table></figure><blockquote><p>在设置时候要注意：</p><ol><li>号码不能重复，不然会报错<code>CXErrorCodeCallDirectoryManagerErrorDuplicateEntries</code></li><li>号码必须按照升序写入，不然会报错<code>CXErrorCodeCallDirectoryManagerErrorEntriesOutOfOrder</code></li><li>号码必须格式化后传入，手机号码必须加上国家码，例如18012341234就不行，需要加上86，构造成8618012341234；固话需要格式为：国家码+区号（去掉第一个0）+号码，例如010-61001234格式化之后为，861061001234。如果号码格式错误，会导致识别不出来。</li><li>上限数据是200万（在其它文章里看到的，然后自己测试了下，构造了200万条数据写入的时候会报错<code>CXErrorCodeCallDirectoryManagerErrorMaximumEntriesExceeded</code>，150万条数据是OK的，所以这个数据上限一定要注意。实测安装了XX安全卫士、XX管家实现骚扰电话拦截用了3个extension，可能数据量太大就是一个原因。）</li><li>在用户第一次打开设置时，会调用<code>beginRequestWithExtensionContext</code>，这时候不宜写太多数据，不然会卡在设置那里转圈，用户体验很差。可以先写部分数据，然后回到主APP了调用<code>reloadExtensionWithIdentifier</code>去刷新。</li></ol></blockquote><h3 id="CXCallDirectoryManager"><a href="#CXCallDirectoryManager" class="headerlink" title="CXCallDirectoryManager"></a>CXCallDirectoryManager</h3><blockquote><p>官方文档：The programmatic interface to an object that manages a Call Directory app extension.</p></blockquote><p><code>CXCallDirectoryManager</code>主要作用是管理Call Directory app extension。<br>有两个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新设置号码识别、电话拦截列表</span></span><br><span class="line"><span class="comment">// 调用该方法后会重置之前设置的列表，然后调用beginRequestWithExtensionContext:</span></span><br><span class="line">- (<span class="keyword">void</span>)reloadExtensionWithIdentifier:(<span class="built_in">NSString</span> *)identifier completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *_Nullable error))completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取extension是否可用，需要在“设置-电话-来电阻止与身份识别"中开启权限</span></span><br><span class="line">- (<span class="keyword">void</span>)getEnabledStatusForExtensionWithIdentifier:(<span class="built_in">NSString</span> *)identifier completionHandler:(<span class="keyword">void</span> (^)(CXCallDirectoryEnabledStatus enabledStatus, <span class="built_in">NSError</span> *_Nullable error))completion;</span><br></pre></td></tr></table></figure><h2 id="二、实战"><a href="#二、实战" class="headerlink" title="二、实战"></a>二、实战</h2><blockquote><p>先上<a href="https://github.com/crmo/CRCallDirectoryDemo" target="_blank" rel="noopener">Demo地址</a>。下面会一步步讲解。</p></blockquote><h3 id="创建extension"><a href="#创建extension" class="headerlink" title="创建extension"></a>创建extension</h3><p>新建一个Target（File-New-Target）。</p><p><img src="http://upload-images.jianshu.io/upload_images/2665383-bb94a974d77e4e75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p><p>会自动建立一个目录，默认有三个文件。在.m文件中有系统给出的示例代码</p><p><img src="http://upload-images.jianshu.io/upload_images/2665383-6a832bc0e0f65e67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p><p>我们来看看系统的模板代码，首先是入口函数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)beginRequestWithExtensionContext:(CXCallDirectoryExtensionContext *)context &#123;</span><br><span class="line">    context.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">if</span> (context.isIncremental) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addOrRemoveIncrementalBlockingPhoneNumbersToContext:context];</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> addOrRemoveIncrementalIdentificationPhoneNumbersToContext:context];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> addAllBlockingPhoneNumbersToContext:context];</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> addAllIdentificationPhoneNumbersToContext:context];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [context completeRequestWithCompletionHandler:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CallDirectoryHandler"><a href="#CallDirectoryHandler" class="headerlink" title="CallDirectoryHandler"></a>CallDirectoryHandler</h3><p>我在Xcode 9生成的代码，<code>context.isIncremental</code>是iOS 11才增加的，还有所有的remove的方法也是iOS 11才有的，为了适配iOS 10，还是不推荐使用。<br>系统模板代码大致逻辑就是，先添加号码识别、号码拦截记录，添加完成后调用<code>completeRequestWithCompletionHandler:</code>完成整个过程。<br>由于号码拦截比较简单，只是写入一个号码的数组，本文就以号码识别为例，号码识别方法系统模板这么写的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addAllIdentificationPhoneNumbersToContext:(CXCallDirectoryExtensionContext *)context &#123;</span><br><span class="line">    CXCallDirectoryPhoneNumber allPhoneNumbers[] = &#123; <span class="number">8618788888888</span>, <span class="number">8618885555555</span> &#125;;</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *labels = @[ <span class="string">@"送餐电话"</span>, <span class="string">@"诈骗电话"</span> ];</span><br><span class="line">    <span class="built_in">NSUInteger</span> count = (<span class="keyword">sizeof</span>(allPhoneNumbers) / <span class="keyword">sizeof</span>(CXCallDirectoryPhoneNumber));</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; count; i += <span class="number">1</span>) &#123;</span><br><span class="line">        CXCallDirectoryPhoneNumber phoneNumber = allPhoneNumbers[i];</span><br><span class="line">        <span class="built_in">NSString</span> *label = labels[i];</span><br><span class="line">        [context addIdentificationEntryWithNextSequentialPhoneNumber:phoneNumber label:label];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这么多代码，核心就是一行<code>[context addIdentificationEntryWithNextSequentialPhoneNumber:phoneNumber label:label];</code>,注意phoneNumber是<code>CXCallDirectoryPhoneNumber</code>类型，其实就是<code>long long</code>类型。<br>在这个函数里，需要把需要识别的号码和识别信息，一条一条的写入</p><h3 id="检查授权"><a href="#检查授权" class="headerlink" title="检查授权"></a>检查授权</h3><p>开启extension功能需要在“设置-电话-来电阻止与身份识别”中开启，我们在写入数据时第一步是引导用户给我们的extension授权。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> CXCallDirectoryManager *manager = [CXCallDirectoryManager sharedInstance];</span><br><span class="line"> [manage</span><br><span class="line">  getEnabledStatusForExtensionWithIdentifier:<span class="keyword">self</span>.externsionIdentifier</span><br><span class="line">  completionHandler:^(CXCallDirectoryEnabledStatus enabledStatus, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">      <span class="comment">// 根据error，enabledStatus判断授权情况</span></span><br><span class="line"><span class="comment">// error == nil &amp;&amp; enabledStatus == CXCallDirectoryEnabledStatusEnabled 说明可用</span></span><br><span class="line"><span class="comment">// error 见 CXErrorCodeCallDirectoryManagerError</span></span><br><span class="line"><span class="comment">// enabledStatus 见 CXCallDirectoryEnabledStatus</span></span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure></p><h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><p>用户在设置开启后，调用<code>reloadExtensionWithIdentifier</code>即可触发<code>CallDirectoryHandler</code>更新数据逻辑。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CXCallDirectoryManager *manager = [CXCallDirectoryManager sharedInstance];</span><br><span class="line">[manager reloadExtensionWithIdentifier:<span class="keyword">self</span>.externsionIdentifier completionHandler:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">// error 见 CXErrorCodeCallDirectoryManagerError</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>接下来在真机下跑下（一定要在插了电话卡的iPhone上调试，模拟器不行！），写入成功后，打开电话，拨号18788888888，提示”送餐电话”。说明写入成功！</p><p><img src="http://upload-images.jianshu.io/upload_images/2665383-2261a7358b0a6964.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p><h2 id="三、extension和containing-app数据共享"><a href="#三、extension和containing-app数据共享" class="headerlink" title="三、extension和containing app数据共享"></a>三、extension和containing app数据共享</h2><p>上面的步骤中，号码信息是写死在代码中的，在实际应用中这些号码信息肯定不是写死的，一般需要从服务器获取。这就需要我们的APP与extension进行通信，需要用到APP Groups，怎么用网上有很多文章了，我就不多说了，<a href="http://foggry.com/blog/2014/06/23/wwdc2014zhi-app-extensionsxue-xi-bi-ji/" target="_blank" rel="noopener">推荐一篇</a>。<br>其实本质就是通过<code>APP Groups</code>，开辟一片空间，extension和containing app都可以访问，然后我们的APP就可以通过NSUserDefaults、文件、数据库等方式共享数据给extension了。前期我使用过NSUserDefaults，效率很低，大概在5万数据的时候就爆内存了，使用extension一定要注意内存，不然很容易被系统干掉，所以不推荐使用这种方式。<br>Demo中采用的是读写文件的方式，大致思路（<code>具体实现看Demo</code>）：</p><ol><li>在APP中把数据序列化之后写到一个文件中</li><li>在extension中读取这个文件，读取一行，调用一次<code>addIdentificationEntryWithNextSequentialPhoneNumber</code>，然后及时释放<br>这种方式理论上是可以达到最大限制200w条的（实际测试150万没有问题）。</li></ol><h3 id="获取APP-Groups文件路径"><a href="#获取APP-Groups文件路径" class="headerlink" title="获取APP Groups文件路径"></a>获取APP Groups文件路径</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSURL</span> *containerURL = [[<span class="built_in">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class="keyword">self</span>.groupIdentifier];</span><br><span class="line">    containerURL = [containerURL URLByAppendingPathComponent:<span class="string">@"CallDirectoryData"</span>];</span><br><span class="line">    <span class="built_in">NSString</span>* filePath = containerURL.path;</span><br></pre></td></tr></table></figure><h3 id="进度监控"><a href="#进度监控" class="headerlink" title="进度监控"></a>进度监控</h3><p>在xx安全卫士中，开启骚扰电话拦截功能有一个进度条，非常的直观。但是在extension中是没法更新UI的，有一种实现方式，可以用开源框架<a href="https://github.com/mutualmobile/MMWormhole" target="_blank" rel="noopener">MMWormhole</a>来实现APP与extension通信，然后把进度从extension传到APP中，在APP中更新进度条。理论上该方案是可行的，感兴趣的同学可以尝试下。</p><hr><ul><li>参考链接<br><a href="https://developer.apple.com/documentation/callkit" target="_blank" rel="noopener">https://developer.apple.com/documentation/callkit</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/230/" target="_blank" rel="noopener">https://developer.apple.com/videos/play/wwdc2016/230/</a><br><a href="https://colin1994.github.io/2016/06/17/Call-Directory-Extension-Study/" target="_blank" rel="noopener">https://colin1994.github.io/2016/06/17/Call-Directory-Extension-Study/</a><br><a href="https://yunissong.github.io/2017/03/29/CallKit/" target="_blank" rel="noopener">https://yunissong.github.io/2017/03/29/CallKit/</a><br><a href="http://www.jianshu.com/p/7f88cbe7948c" target="_blank" rel="noopener">http://www.jianshu.com/p/7f88cbe7948c</a><br><a href="https://www.raywenderlich.com/150015/callkit-tutorial-ios" target="_blank" rel="noopener">https://www.raywenderlich.com/150015/callkit-tutorial-ios</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;2018.5.28日更新&lt;br&gt;CallKit在国内已经被禁止上架了，亲测被拒。企业版还能继续使用，想上架就乖乖屏蔽吧（要是哪位同学成功上架了一定私信我怎么做到的。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
  </entry>
  
</feed>
