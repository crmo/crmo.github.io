<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CR.MO`s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://crmo.github.io/"/>
  <updated>2018-05-26T12:22:23.176Z</updated>
  <id>http://crmo.github.io/</id>
  
  <author>
    <name>CR.MO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>探寻Objective-C引用计数本质</title>
    <link href="http://crmo.github.io/2018/05/26/%E6%8E%A2%E5%AF%BBObjective-C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    <id>http://crmo.github.io/2018/05/26/探寻Objective-C引用计数本质/</id>
    <published>2018-05-25T16:00:00.000Z</published>
    <updated>2018-05-26T12:22:23.176Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文涉及到的CPU架构为arm64，其它架构大同小异。<br>源码来自<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">苹果开源-runtime</a>。</p></blockquote><p>Objective-C中采用引用计数机制来管理内存，在MRC时代，需要我们手动<code>retain</code>和<code>release</code>，在苹果引入ARC后大部分时间我们不用再关心引用计数问题。但是为了深入Objective-C本质，引用计数究竟是怎么实现的还是值得我们去探寻的。</p><h2 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h2><p>OC中的对象的实质其实是结构体，其中大部分对象都有isa，指向类对象（有一种神奇的存在叫做<code>Tagged Pointer</code>），源码中关于对象结构体<code>objc_object</code>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-private.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">id <span class="title">retain</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">id <span class="title">autorelease</span><span class="params">()</span></span>;</span><br><span class="line">    ... <span class="comment">//省略了其它方法，感兴趣可以直接看源码</span></span><br></pre></td></tr></table></figure><h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p>除了有一种特殊的对象<code>Tagged Pointer</code>，这种类型的对象值就存在指针当中，存取性能高。可以用来存储少量数据的对象，例如NSNumber、NSDate、NSString。(更多Tagged Pointer知识，推荐这篇<a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer" target="_blank" rel="noopener">文章</a>)。也就没有引用计数、内存释放的问题。</p><h3 id="NONPOINTER-ISA"><a href="#NONPOINTER-ISA" class="headerlink" title="NONPOINTER ISA"></a>NONPOINTER ISA</h3><p>arm64架构isa占64位，苹果为了优化性能，存储类对象地址只用了33位，剩下的位用来存储一些其它信息，比如本文讨论的引用计数。</p><p>NONPOINTER ISA存储的字段定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">    struct &#123;</span><br><span class="line">        uintptr_t nonpointer        : 1;</span><br><span class="line">        uintptr_t has_assoc         : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">        uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000</span><br><span class="line">        uintptr_t magic             : 6;</span><br><span class="line">        uintptr_t weakly_referenced : 1;</span><br><span class="line">        uintptr_t deallocating      : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">        uintptr_t extra_rc          : 19;</span><br><span class="line">#       define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#       define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="extra-rc"><a href="#extra-rc" class="headerlink" title="extra_rc"></a>extra_rc</h2><p>那引用计数存在哪里呢？秘密就在<code>extra_rc</code>中。</p><blockquote><p>extra_rc只是存储了额外的引用计数，实际的引用计数计算公式：<code>引用计数=extra_rc+1</code>。</p></blockquote><p><code>extra_rc</code>占了19位，可以存储的最大引用计数：$2^{19}-1+1=524288$，超过它就需要进位到<code>SideTables</code>。SideTables是一个Hash表，根据对象地址可以找到对应的<code>SideTable</code>，<code>SideTable</code>内包含一个<code>RefcountMap</code>，根据对象地址取出其引用计数，类型是<code>size_t</code>。<br>它是一个<code>unsigned long</code>，最低两位是标志位，剩下的62位用来存储引用计数。我们可以计算出引用计数的理论最大值：$2^{62+19}=2.417851639229258e24$。</p><blockquote><p>其实isa能存储的524288在日常开发已经完全够用了，为什么还要搞个Side Table？我猜测是因为历史问题，以前cpu是32位的，isa中能存储的引用计数就只有$2^{7}=128$。因此在arm64下，引用计数通常是存储在isa中的。</p></blockquote><h2 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h2><p>有了前面的铺垫，我们知道引用计数怎么存储的了，那引用计数又是怎么改变的呢？通过剖析<code>retain</code>源码我们就可以得出结论了。<br>objc_object的方法全部定义在objc-object.h文件中，全是内联函数，应该是为了性能的考虑。</p><p>我们来看看<code>retain</code>的函数定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> id </span><br><span class="line">objc_object::retain()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        <span class="keyword">return</span> rootRetain();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((id(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_retain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这层比较简单，做了三件事情：</p><ol><li>判断指针是不是<code>Tagged Pointer</code></li><li>判断是否有自定义<code>retain</code>，如果有调用自定义的。</li><li>最后调用<code>rootRetain</code></li></ol><p>我们来看看关键函数<code>rootRetain</code>的实现（为了便于阅读，代码有所删减）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain(<span class="keyword">bool</span> tryRetain, <span class="keyword">bool</span> handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">isa_t</span> oldisa;</span><br><span class="line">    <span class="keyword">isa_t</span> newisa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁，用汇编指令ldxr来保证原子性</span></span><br><span class="line">    oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    newisa = oldisa;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newisa.nonpointer = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// newisa.nonpointer = 0说明所有位数都是地址值</span></span><br><span class="line">        <span class="comment">// 释放锁，使用汇编指令clrex</span></span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 由于所有位数都是地址值，直接使用sidetable来存储引用计数</span></span><br><span class="line">        <span class="keyword">return</span> sidetable_retain();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储extra_rc++后的结果</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> carry;</span><br><span class="line">    <span class="comment">// extra_rc++</span></span><br><span class="line">    newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// extra_rc++后溢出，进位到side table</span></span><br><span class="line">        newisa.extra_rc = RC_HALF;</span><br><span class="line">        newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 将newisa写入isa</span></span><br><span class="line">    StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)</span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个细节可以了解下，如何用汇编来实现原子性操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE</span><br><span class="line"><span class="keyword">uintptr_t</span> </span><br><span class="line">LoadExclusive(<span class="keyword">uintptr_t</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> result;</span><br><span class="line">    <span class="comment">// 在多核CPU下，对一个地址的访问可能引起冲突，ldxr解决了冲突，保证原子性。</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"ldxr %x0, [%x1]"</span> </span><br><span class="line">        : <span class="string">"=r"</span> (result) </span><br><span class="line">        : <span class="string">"r"</span> (src), <span class="string">"m"</span> (*src));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><p><code>release</code>代码逻辑基本上就是<code>retain</code>反过来走一遍，有点不同的是在引用计数减到0时，会调用对象的dealloc方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE bool</span><br><span class="line">objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line">    </span><br><span class="line">retry:</span><br><span class="line">    oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    newisa = oldisa;</span><br><span class="line">    if (newisa.nonpointer == 0) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        if (sideTableLocked) sidetable_unlock();</span><br><span class="line">        return sidetable_release(performDealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    uintptr_t carry;</span><br><span class="line">    // extra_rc--</span><br><span class="line">    newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);</span><br><span class="line">    if (carry == 0) &#123;</span><br><span class="line">        // 需要从SideTable借位，或者引用计数为0</span><br><span class="line">        goto underflow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 存储引用计数到isa</span><br><span class="line">    StoreReleaseExclusive(&amp;isa.bits,</span><br><span class="line">                          oldisa.bits, newisa.bits)</span><br><span class="line">    return false;</span><br><span class="line">    </span><br><span class="line">underflow:</span><br><span class="line">    // 从SideTable借位</span><br><span class="line">    // 或引用计数为0，调用delloc</span><br><span class="line">    </span><br><span class="line">    // 此处省略N多代码</span><br><span class="line">    // 总结一下:修改Side Table与extra_rc，</span><br><span class="line">    </span><br><span class="line">    // 引用计数减为0时，调用dealloc</span><br><span class="line">    if (performDealloc) &#123;</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>引用计数存在哪？</p></blockquote><ol><li><code>Tagged Pointer</code>不需要引用计数</li><li><code>NONPOINTER ISA</code>(isa的第一位为1)的引用计数优先存在isa中，大于524288了进位到<code>Side Tables</code></li><li>非<code>NONPOINTER ISA</code>引用计数存在<code>Side Tables</code></li></ol><blockquote><p>retain/release的实质</p></blockquote><ul><li>找到引用计数存储区域，然后+1/-1</li><li>如果是<code>NONPOINTER ISA</code>，还要处理进位/借位的情况</li><li>release在引用计数减为0时，调用<code>dealloc</code></li></ul><hr><p>参考</p><ul><li><a href="https://github.com/Draveness/analyze/blob/master/contents/objc/黑箱中的%20retain%20和%20release.md" target="_blank" rel="noopener">黑箱中的 retain 和 release</a></li><li><a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer" target="_blank" rel="noopener">深入理解Tagged Pointer</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文涉及到的CPU架构为arm64，其它架构大同小异。&lt;br&gt;源码来自&lt;a href=&quot;https://opensource.apple.com/tarballs/objc4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;苹果开
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cordova源码解析（二）- 自定义UserAgent</title>
    <link href="http://crmo.github.io/2018/05/15/Cordova%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-%20%E8%87%AA%E5%AE%9A%E4%B9%89UserAgent/"/>
    <id>http://crmo.github.io/2018/05/15/Cordova源码解析（二）- 自定义UserAgent/</id>
    <published>2018-05-14T16:00:00.000Z</published>
    <updated>2018-05-15T11:25:56.421Z</updated>
    
    <content type="html"><![CDATA[<p>本文分析的源码是基于Cordova 4.2.1版本，<a href="https://cordova.apache.org" target="_blank" rel="noopener">Cordova官网</a>。</p><h1 id="Cordova源码解析（二）-自定义UserAgent"><a href="#Cordova源码解析（二）-自定义UserAgent" class="headerlink" title="Cordova源码解析（二）- 自定义UserAgent"></a>Cordova源码解析（二）- 自定义UserAgent</h1><p><code>UIWebView</code>没有提供设置UserAgent的接口，但是有一个办法可以间接的设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary* dict = [[NSDictionary alloc] initWithObjectsAndKeys:value, @&quot;UserAgent&quot;, nil];</span><br><span class="line">[[NSUserDefaults standardUserDefaults] registerDefaults:dict];</span><br></pre></td></tr></table></figure><p>通过设置<code>NSUserDefaults</code>中<code>UserAgent</code>的值来修改，但是这种设置方法有一个限制，需要在<code>UIWebView</code>的<code>loadRequest</code>之前调用才能生效(加载PDF比较特殊)。这是Cordova源码中关于这个问题的描述</p><blockquote><p>Setting the UserAgent must occur before a UIWebView is instantiated.<br>It is read per instantiation, so it does not affect previously created views.<br>Except! When a PDF is loaded, all currently active UIWebViews reload their<br>User-Agent from the NSUserDefaults some time after the DidFinishLoad of the PDF bah!</p></blockquote><h2 id="CDVUserAgentUtil"><a href="#CDVUserAgentUtil" class="headerlink" title="CDVUserAgentUtil"></a>CDVUserAgentUtil</h2><p>在多WebView的情况下，如果每个WebView都有不同的<code>UserAgent</code>，就会产生数据竞争的问题，大家都要修改<code>NSUserDefaults</code>中<code>UserAgent</code>的值，于是需要对资源加锁来保证每个WebView都设置预期的<code>UserAgent</code>。在Cordova中，专门有一个类<code>CDVUserAgentUtil</code>来实现这个功能。</p><p><code>CDVUserAgentUtil.h</code>文件中定义了四个方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取UIWebView默认的UserAgent</span></span><br><span class="line">+ (<span class="built_in">NSString</span>*)originalUserAgent;</span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">+ (<span class="keyword">void</span>)acquireLock:(<span class="keyword">void</span> (^)(<span class="built_in">NSInteger</span> lockToken))block;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">+ (<span class="keyword">void</span>)releaseLock:(<span class="built_in">NSInteger</span>*)lockToken;</span><br><span class="line"><span class="comment">// 设置UIWebView的UserAgent</span></span><br><span class="line">+ (<span class="keyword">void</span>)setUserAgent:(<span class="built_in">NSString</span>*)value lockToken:(<span class="built_in">NSInteger</span>)lockToken;</span><br></pre></td></tr></table></figure><h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><p>每次加锁成功会返回一个NSInteger类型的token，在释放锁的时候需要把token传入。token会不断递增，保证每次加锁返回的token都不回重复。加锁的实现代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVUserAgentUtil.m</span></span><br><span class="line">+ (<span class="keyword">void</span>)acquireLock:(<span class="keyword">void</span> (^)(<span class="built_in">NSInteger</span> lockToken))block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gCurrentLockToken == <span class="number">0</span>) &#123;</span><br><span class="line">        gCurrentLockToken = ++gNextLockToken;</span><br><span class="line">        VerboseLog(<span class="string">@"Gave lock %d"</span>, gCurrentLockToken);</span><br><span class="line">        block(gCurrentLockToken);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (gPendingSetUserAgentBlocks == <span class="literal">nil</span>) &#123;</span><br><span class="line">            gPendingSetUserAgentBlocks = [[<span class="built_in">NSMutableArray</span> alloc] initWithCapacity:<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        VerboseLog(<span class="string">@"Waiting for lock"</span>);</span><br><span class="line">        [gPendingSetUserAgentBlocks addObject:block];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>acquireLock:</code>，首先会判断<code>gCurrentLockToken</code>是否等于0</p><ul><li>如果是0说明没有模块正在修改<code>UserAgent</code>，能够成功获取到锁，<code>gCurrentLockToken</code>递增，标致当前有模块正在修改<code>UserAgent</code>，并回调<code>block</code>，返回<code>gCurrentLockToken</code></li><li>如果不为0说明当前有模块正在修改<code>UserAgent</code>，将<code>block</code>回调存在一个队列<code>gPendingSetUserAgentBlocks</code>中</li></ul><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>释放锁需要传入token，释放锁代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)releaseLock:(<span class="built_in">NSInteger</span>*)lockToken</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*lockToken == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSAssert</span>(gCurrentLockToken == *lockToken, <span class="string">@"Got token %ld, expected %ld"</span>, (<span class="keyword">long</span>)*lockToken, (<span class="keyword">long</span>)gCurrentLockToken);</span><br><span class="line"></span><br><span class="line">    VerboseLog(<span class="string">@"Released lock %d"</span>, *lockToken);</span><br><span class="line">    <span class="keyword">if</span> ([gPendingSetUserAgentBlocks count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> (^block)() = [gPendingSetUserAgentBlocks objectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [gPendingSetUserAgentBlocks removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        gCurrentLockToken = ++gNextLockToken;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Gave lock %ld"</span>, (<span class="keyword">long</span>)gCurrentLockToken);</span><br><span class="line">        block(gCurrentLockToken);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        gCurrentLockToken = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *lockToken = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果要释放的<code>lockToken</code>为0，说明还没加过锁，就调用释放了，直接返回</li><li>从队列<code>gPendingSetUserAgentBlocks</code>中取出最早加入的<code>block</code>，从队列中移除</li><li><code>gCurrentLockToken</code>递增生成新token，回调<code>block</code></li><li>如果队列<code>gPendingSetUserAgentBlocks</code>释放完成，说明释放锁的调用次数&gt;加锁的次数，不做操作，然后把<code>gCurrentLockToken</code>置为0</li></ul><h2 id="设置UserAgent"><a href="#设置UserAgent" class="headerlink" title="设置UserAgent"></a>设置UserAgent</h2><p>在Cordova实际运用中，操作锁的时机：<br>加锁时机：<code>CDVViewController</code>加载完毕，在<code>viewDidLoad</code>里调用<br>释放锁时机：</p><ul><li><code>UIWebView</code>的<code>webViewDidFinishLoad:</code>回调</li><li><code>UIWebView</code>的<code>webView:didFailLoadWithError:</code>回调</li><li><code>CDVViewController</code>的<code>dealloc</code></li><li><code>CDVViewController</code>的<code>viewDidUnload</code></li></ul><p>加锁代码，省略了不相关代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVViewController.m</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [CDVUserAgentUtil acquireLock:^(<span class="built_in">NSInteger</span> lockToken) &#123;</span><br><span class="line">        _userAgentLockToken = lockToken;</span><br><span class="line">        [CDVUserAgentUtil setUserAgent:<span class="keyword">self</span>.userAgent lockToken:lockToken];</span><br><span class="line">        <span class="built_in">NSURLRequest</span>* appReq = [<span class="built_in">NSURLRequest</span> requestWithURL:appURL cachePolicy:<span class="built_in">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class="number">20.0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.webViewEngine loadRequest:appReq];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放锁代码，这里只看正常逻辑，在网页加载完成回调<code>webViewDidFinishLoad:</code>中释放逻辑。不考虑异常情况，省略了不相关代码。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVUIWebViewNavigationDelegate.m</span></span><br><span class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span>*)theWebView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Finished load of: %@"</span>, theWebView.request.URL);</span><br><span class="line">    CDVViewController* vc = (CDVViewController*)<span class="keyword">self</span>.enginePlugin.viewController;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It's safe to release the lock even if this is just a sub-frame that's finished loading.</span></span><br><span class="line">    [CDVUserAgentUtil releaseLock:vc.userAgentLockToken];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>webViewDidFinishLoad:</code>回调时，UserAgent已经设置成功，所以可以释放锁，让其它WebView操作UserDefault了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文分析的源码是基于Cordova 4.2.1版本，&lt;a href=&quot;https://cordova.apache.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cordova官网&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;Cordova源码解析（二）-自
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cordova源码解析</title>
    <link href="http://crmo.github.io/2018/05/09/Cordova%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://crmo.github.io/2018/05/09/Cordova源码解析/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2018-05-10T01:36:22.825Z</updated>
    
    <content type="html"><![CDATA[<p>本文设计到的源码是基于Cordova 4.2.1版本，<a href="https://cordova.apache.org" target="_blank" rel="noopener">Cordova官网</a>。</p><h2 id="CDVViewController"><a href="#CDVViewController" class="headerlink" title="CDVViewController"></a>CDVViewController</h2><p><code>CDVViewController</code>是Cordova最主要的类，它把所有模块整合在一起，直接初始化一个它的实例就可以使用。例如下面的代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CDVViewController *vc = [[CDVViewController alloc] init];</span><br><span class="line">vc.startPage = <span class="string">@"www.baidu.com"</span>;</span><br><span class="line">[<span class="keyword">self</span> presentViewController:vc animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p><code>CDVViewController</code>主要实现的功能：</p><ul><li>注册、初始化插件</li><li>读取、应用配置文件</li><li>初始化并配置WebView，设置其代理</li><li>管理js与原生的方法调用</li><li><p>管理应用与网页的生命周期<br>。。。</p><p>它主要的属性有：</p></li><li><p>CDVWebViewEngineProtocol：webview相关的回调</p></li><li>CDVCommandDelegate：js与原生插件交互方法，插件初始化</li><li>CDVCommandQueue：命令执行队列</li></ul><p><code>CDVCommandDelegate</code>和<code>CDVCommandQueue</code>会在js调用原生插件与插件初始化提到，这里先不细说。<br><code>CDVWebViewEngineProtocol</code>定义了<code>WebView</code>引擎的抽象类，具体实现由插件提供，例如<code>CDVUIWebViewEngine</code>实现<code>UIWebView</code>的引擎。</p><h3 id="CDVWebViewEngineProtocol协议定义"><a href="#CDVWebViewEngineProtocol协议定义" class="headerlink" title="CDVWebViewEngineProtocol协议定义"></a>CDVWebViewEngineProtocol协议定义</h3><p><code>CDVWebViewEngineProtocol</code>协议其实是对于WebView的一层封装，屏蔽了不同<code>WebView</code>接口的差异，现在iOS有<code>UIWebView</code>与<code>WKWebView</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CDVWebViewEngineProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIView</span>* engineWebView;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)loadRequest:(<span class="built_in">NSURLRequest</span>*)request;</span><br><span class="line">- (<span class="keyword">id</span>)loadHTMLString:(<span class="built_in">NSString</span>*)string baseURL:(<span class="built_in">NSURL</span>*)baseURL;</span><br><span class="line">- (<span class="keyword">void</span>)evaluateJavaScript:(<span class="built_in">NSString</span>*)javaScriptString completionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">id</span>, <span class="built_in">NSError</span>*))completionHandler;</span><br><span class="line">- (<span class="built_in">NSURL</span>*)URL;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canLoadRequest:(<span class="built_in">NSURLRequest</span>*)request;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame;</span><br><span class="line">- (<span class="keyword">void</span>)updateWithInfo:(<span class="built_in">NSDictionary</span>*)info;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>engineWebView</code>属性对外直接暴露了内部封装的<code>WebView</code>，其它方法都是对<code>WebView</code>方法的一层简单封装。</p><h3 id="UIWebView引擎CDVUIWebViewEngine"><a href="#UIWebView引擎CDVUIWebViewEngine" class="headerlink" title="UIWebView引擎CDVUIWebViewEngine"></a>UIWebView引擎CDVUIWebViewEngine</h3><p>我们以<code>UIWebView</code>的实现<code>CDVUIWebViewEngine</code>为例说明，它是以插件的形式实现的，主要作用是初始化UIWebView的配置，对UIWebView的方法和代理进行了一层封装。它实现了协议<code>CDVWebViewEngineProtocol</code>，主要有以下几个属性。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVUIWebViewEngine</span></span><br><span class="line"><span class="comment">// UIWebview</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">UIView</span>* engineWebView;</span><br><span class="line"><span class="comment">// UIWebView的代理</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="keyword">id</span> &lt;<span class="built_in">UIWebViewDelegate</span>&gt; uiWebViewDelegate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) CDVUIWebViewNavigationDelegate* navWebViewDelegate;</span><br></pre></td></tr></table></figure><p>初始化从<code>initWithFrame:</code>方法开始，它创建了一个<code>UIWebView</code>，并赋值给了<code>engineWebView</code>，然后在插件初始化方法<code>pluginInitialize</code>中初始化<code>UIWebView</code>的代理和配置。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)pluginInitialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIWebView</span>* uiWebView = (<span class="built_in">UIWebView</span>*)_engineWebView;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前controller是否实现了UIWebViewDelegate</span></span><br><span class="line">    <span class="comment">// 如果实现了就把当前controller设置为CDVUIWebViewDelegate的代理实现</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.viewController conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">UIWebViewDelegate</span>)]) </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.uiWebViewDelegate = [[CDVUIWebViewDelegate alloc] initWithDelegate:(<span class="keyword">id</span> &lt;<span class="built_in">UIWebViewDelegate</span>&gt;)<span class="keyword">self</span>.viewController];</span><br><span class="line">        uiWebView.delegate = <span class="keyword">self</span>.uiWebViewDelegate;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果没有实现，创建一个CDVUIWebViewNavigationDelegate，作为CDVUIWebViewDelegate的代理实现</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.navWebViewDelegate = [[CDVUIWebViewNavigationDelegate alloc] initWithEnginePlugin:<span class="keyword">self</span>];</span><br><span class="line">        <span class="keyword">self</span>.uiWebViewDelegate = [[CDVUIWebViewDelegate alloc] initWithDelegate:<span class="keyword">self</span>.navWebViewDelegate];</span><br><span class="line">        uiWebView.delegate = <span class="keyword">self</span>.uiWebViewDelegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化配置信息</span></span><br><span class="line">    <span class="comment">// self.commandDelegate.settings是CDVViewController的配置信息，定义在config.xml</span></span><br><span class="line">    [<span class="keyword">self</span> updateSettings:<span class="keyword">self</span>.commandDelegate.settings];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js调用原生插件解析"><a href="#js调用原生插件解析" class="headerlink" title="js调用原生插件解析"></a>js调用原生插件解析</h2><p>插件调用流程：</p><ol><li>js发起请求<code>gap://</code></li><li>实现<code>WebView</code>的代理<code>webView:shouldStartLoadWithRequest:navigationType:</code>，拦截<code>scheme</code>为<code>gap</code>的请求</li><li>执行js方法<code>cordova.require(&#39;cordova/exec&#39;).nativeFetchMessages()</code>获取需要执行的原生插件的信息（插件名，插件方法，回调ID，参数）</li><li>将需要执行的原生插件信息放入命令队列等待执行</li><li>执行原生插件，并把结果回调给js</li></ol><p>插件调用堆栈如图所示：</p><p><img src="/images/15256629038423.jpg" alt=""></p><h3 id="js请求拦截"><a href="#js请求拦截" class="headerlink" title="js请求拦截"></a>js请求拦截</h3><p><code>CDVUIWebViewDelegate</code>实现了UIWebView的<code>webView:shouldStartLoadWithRequest:navigationType:</code>代理，在页面加载前做一些处理。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span>*)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span>*)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> shouldLoad = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 判断如果有代理，先调用代理方法</span></span><br><span class="line">    <span class="comment">// 这里的_delegate是CDVUIWebViewNavigationDelegate</span></span><br><span class="line">    <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(webView:shouldStartLoadWithRequest:navigationType:)]) &#123;</span><br><span class="line">        shouldLoad = [_delegate webView:webView shouldStartLoadWithRequest:request navigationType:navigationType];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldLoad) &#123;</span><br><span class="line">        <span class="comment">// 是否是调试工具refresh</span></span><br><span class="line">        <span class="built_in">BOOL</span> isDevToolsRefresh = (request == webView.request);</span><br><span class="line">        <span class="comment">// 是否是顶层页面</span></span><br><span class="line">        <span class="built_in">BOOL</span> isTopLevelNavigation = isDevToolsRefresh || [request.URL isEqual:[request mainDocumentURL]];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isTopLevelNavigation) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> request:request isEqualToRequestAfterStrippingFragments:webView.request]) &#123;</span><br><span class="line">                <span class="built_in">NSString</span>* prevURL = [<span class="keyword">self</span> evalForCurrentURL:webView];</span><br><span class="line">                <span class="keyword">if</span> ([prevURL isEqualToString:[request.URL absoluteString]]) &#123;</span><br><span class="line">                    VerboseLog(<span class="string">@"Page reload detected."</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    VerboseLog(<span class="string">@"Detected hash change shouldLoad"</span>);</span><br><span class="line">                    <span class="keyword">return</span> shouldLoad;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (_state) &#123;</span><br><span class="line">                <span class="keyword">case</span> STATE_WAITING_FOR_LOAD_FINISH:</span><br><span class="line">                    <span class="comment">// 重定向情况，判断loadCount是否是1</span></span><br><span class="line">                    <span class="keyword">if</span> (_loadCount != <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@"CDVWebViewDelegate: Detected redirect when loadCount=%ld"</span>, (<span class="keyword">long</span>)_loadCount);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> STATE_IDLE:</span><br><span class="line">                <span class="keyword">case</span> STATE_IOS5_POLLING_FOR_LOAD_START:</span><br><span class="line">                <span class="keyword">case</span> STATE_CANCELLED:</span><br><span class="line">                    <span class="comment">// 页面导航开始</span></span><br><span class="line">                    _loadCount = <span class="number">0</span>;</span><br><span class="line">                    _state = STATE_WAITING_FOR_LOAD_START;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 其它情况，回调webView:didFailLoadWithError:</span></span><br><span class="line">                        <span class="built_in">NSString</span>* description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"CDVWebViewDelegate: Navigation started when state=%ld"</span>, (<span class="keyword">long</span>)_state];</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, description);</span><br><span class="line">                        _loadCount = <span class="number">0</span>;</span><br><span class="line">                        _state = STATE_WAITING_FOR_LOAD_START;</span><br><span class="line">                        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(webView:didFailLoadWithError:)]) &#123;</span><br><span class="line">                            <span class="built_in">NSDictionary</span>* errorDictionary = @&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : description&#125;;</span><br><span class="line">                            <span class="built_in">NSError</span>* error = [[<span class="built_in">NSError</span> alloc] initWithDomain:<span class="string">@"CDVUIWebViewDelegate"</span> code:<span class="number">1</span> userInfo:errorDictionary];</span><br><span class="line">                            [_delegate webView:webView didFailLoadWithError:error];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 屏蔽一些无效网站的访问</span></span><br><span class="line">            shouldLoad = shouldLoad &amp;&amp; [<span class="keyword">self</span> shouldLoadRequest:request];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldLoad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截js调用原生插件请求的关键代码在<code>CDVUIWebViewNavigationDelegate</code>，它实现了<code>CDVUIWebViewDelegate</code>的代理，在<code>CDVUIWebViewDelegate</code>会把请求转发给它。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span>*)theWebView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span>*)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span>* url = [request URL];</span><br><span class="line">    CDVViewController* vc = (CDVViewController*)<span class="keyword">self</span>.enginePlugin.viewController;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// H5调用原生插件，后面分析</span></span><br><span class="line">    <span class="keyword">if</span> ([[url scheme] isEqualToString:<span class="string">@"gap"</span>]) &#123;</span><br><span class="line">        [vc.commandQueue fetchCommandsFromJs];</span><br><span class="line">        [vc.commandQueue executePending];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给插件预留了一个处理URL的方法，调用插件的方法`shouldOverrideLoadWithRequest:navigationType:`，获取返回值</span></span><br><span class="line">    <span class="comment">// 应用：系统默认插件CDVIntentAndNavigationFilter中，实现了Intent与Navigation的白名单机制。</span></span><br><span class="line">    <span class="built_in">BOOL</span> anyPluginsResponded = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> shouldAllowRequest = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span>* pluginName <span class="keyword">in</span> vc.pluginObjects) &#123;</span><br><span class="line">        CDVPlugin* plugin = [vc.pluginObjects objectForKey:pluginName];</span><br><span class="line">        SEL selector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"shouldOverrideLoadWithRequest:navigationType:"</span>);</span><br><span class="line">        <span class="keyword">if</span> ([plugin respondsToSelector:selector]) &#123;</span><br><span class="line">            anyPluginsResponded = <span class="literal">YES</span>;</span><br><span class="line">            shouldAllowRequest = (((<span class="built_in">BOOL</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>, <span class="keyword">int</span>))objc_msgSend)(plugin, selector, request, navigationType));</span><br><span class="line">            <span class="keyword">if</span> (!shouldAllowRequest) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (anyPluginsResponded) &#123;</span><br><span class="line">        <span class="keyword">return</span> shouldAllowRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 处理其它类型的url,file:类型直接返回YES</span></span><br><span class="line">    <span class="built_in">BOOL</span> shouldAllowNavigation = [<span class="keyword">self</span> defaultResourcePolicyForURL:url];</span><br><span class="line">    <span class="keyword">if</span> (shouldAllowNavigation) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotification:[<span class="built_in">NSNotification</span> notificationWithName:CDVPluginHandleOpenURLNotification object:url]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="H5调用原生插件"><a href="#H5调用原生插件" class="headerlink" title="H5调用原生插件"></a>H5调用原生插件</h3><p>Cordova调用原生插件的方式是通过拦截<code>gap://</code>的URL，然后执行js代码<code>cordova.require(&#39;cordova/exec&#39;).nativeFetchMessages()</code>获取参数，来实现调用。</p><p>我们来看关键代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVUIWebViewNavigationDelegate.m</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span>*)theWebView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span>*)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType</span><br><span class="line">&#123;</span><br><span class="line">    CDVViewController* vc = (CDVViewController*)<span class="keyword">self</span>.enginePlugin.viewController;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([[url scheme] isEqualToString:<span class="string">@"gap"</span>]) &#123;</span><br><span class="line">        [vc.commandQueue fetchCommandsFromJs];</span><br><span class="line">        [vc.commandQueue executePending];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)fetchCommandsFromJs</span><br><span class="line">&#123;</span><br><span class="line">    __<span class="keyword">weak</span> CDVCommandQueue* weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSString</span>* js = <span class="string">@"cordova.require('cordova/exec').nativeFetchMessages()"</span>;</span><br><span class="line"></span><br><span class="line">    [_viewController.webViewEngine evaluateJavaScript:js</span><br><span class="line">                                    completionHandler:^(<span class="keyword">id</span> obj, <span class="built_in">NSError</span>* error) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((error == <span class="literal">nil</span>) &amp;&amp; [obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span>* queuedCommandsJSON = (<span class="built_in">NSString</span>*)obj;</span><br><span class="line">            <span class="comment">// 调用的插件信息加入到queue中</span></span><br><span class="line">            [weakSelf enqueueCommandBatch:queuedCommandsJSON];</span><br><span class="line">            <span class="comment">// 调用执行方法</span></span><br><span class="line">            [<span class="keyword">self</span> executePending];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用js方法<code>cordova.require(&#39;cordova/exec&#39;).nativeFetchMessages()</code>，获取调用的插件信息。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 插件信息示例</span><br><span class="line">[[<span class="string">"DevicePlugin1678563772"</span>,<span class="string">"DevicePlugin"</span>,<span class="string">"getDeviceInfo"</span>,[]]]</span><br></pre></td></tr></table></figure><h3 id="命令队列CDVCommandQueue"><a href="#命令队列CDVCommandQueue" class="headerlink" title="命令队列CDVCommandQueue"></a>命令队列CDVCommandQueue</h3><p>js的每次调用信息会封装被封装为一个命令<code>CDVInvokedUrlCommand</code>，<code>CDVInvokedUrlCommand</code>继承自<code>NSObject</code>，主要存储了下面的信息：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVInvokedUrlCommand</span></span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>* arguments;</span><br><span class="line"><span class="comment">// 回调ID</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span>* callbackId;</span><br><span class="line"><span class="comment">// 类名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span>* className;</span><br><span class="line"><span class="comment">// 方法名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span>* methodName;</span><br></pre></td></tr></table></figure><p><code>CDVCommandQueue</code>管理着所有的命令，实现了一个命令的队列。在js调用原生插件时，会调用<code>CDVCommandQueue</code>的<code>enqueueCommandBatch:</code>方法，将插件调用信息加到<code>commandBatchHolder</code>数组中，最后<code>commandBatchHolder</code>数组添加到<code>CDVCommandQueue</code>的<code>queue</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enqueueCommandBatch:(<span class="built_in">NSString</span>*)batchJSON</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([batchJSON length] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span>* commandBatchHolder = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        [_queue addObject:commandBatchHolder];</span><br><span class="line">        <span class="keyword">if</span> ([batchJSON length] &lt; JSON_SIZE_FOR_MAIN_THREAD) &#123;</span><br><span class="line">            [commandBatchHolder addObject:[batchJSON cdv_JSONObject]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^() &#123;</span><br><span class="line">                <span class="built_in">NSMutableArray</span>* result = [batchJSON cdv_JSONObject];</span><br><span class="line">                <span class="keyword">@synchronized</span>(commandBatchHolder) &#123;</span><br><span class="line">                    [commandBatchHolder addObject:result];</span><br><span class="line">                &#125;</span><br><span class="line">                [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(executePending) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件的执行由<code>CDVCommandQueue</code>管理，每个<code>CDVViewController</code>有自己的队列，有两个重要的成员变量。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二维数组，存储着所有插件调用的json */</span></span><br><span class="line"><span class="built_in">NSMutableArray</span>* _queue;</span><br><span class="line"><span class="comment">/* 记录开始调用的时间 */</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> _startExecutionTime;</span><br></pre></td></tr></table></figure><p><code>executePending</code>负责执行命令队列中待执行的插件，具体实现就是遍历执行二维数组<code>queue</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)executePending</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果已经开始执行了，返回</span></span><br><span class="line">    <span class="keyword">if</span> (_startExecutionTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="comment">// 记录开始执行的时间</span></span><br><span class="line">        _startExecutionTime = [<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历_queue</span></span><br><span class="line">        <span class="keyword">while</span> ([_queue count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSMutableArray</span>* commandBatchHolder = _queue[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">NSMutableArray</span>* commandBatch = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">@synchronized</span>(commandBatchHolder) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([commandBatchHolder count] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                commandBatch = commandBatchHolder[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历commandBatch</span></span><br><span class="line">            <span class="keyword">while</span> ([commandBatch count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                    <span class="comment">// 取出commandBatch的第一条数据，并移除</span></span><br><span class="line">                    <span class="built_in">NSArray</span>* jsonEntry = [commandBatch cdv_dequeue];</span><br><span class="line">                    <span class="keyword">if</span> ([commandBatch count] == <span class="number">0</span>) &#123;</span><br><span class="line">                        [_queue removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 用插件调用json信息，创建CDVInvokedUrlCommand</span></span><br><span class="line">                    CDVInvokedUrlCommand* command = [CDVInvokedUrlCommand commandFromJson:jsonEntry];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 调用插件</span></span><br><span class="line">                    [<span class="keyword">self</span> execute:command]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对于性能的一个优化，后面会详细说</span></span><br><span class="line">                <span class="keyword">if</span> (([_queue count] &gt; <span class="number">0</span>) &amp;&amp; ([<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate] - _startExecutionTime &gt; MAX_EXECUTION_TIME)) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(executePending) withObject:<span class="literal">nil</span> afterDelay:<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">@finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        _startExecutionTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用Runloop优化性能"><a href="#用Runloop优化性能" class="headerlink" title="用Runloop优化性能"></a>用Runloop优化性能</h3><p>Cordova对于插件的执行进行了优化，保证页面的流程度，运用了RunLoop，巧妙的将代码分割为多块分次执行，避免由于插件执行导致主线程阻塞，影响页面绘制，导致掉帧。具体代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVCommandQueue.m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MAX_EXECUTION_TIME ≈ 1s / 60 / 2</span></span><br><span class="line"><span class="comment">// 计算出绘制一帧时间的一半</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> MAX_EXECUTION_TIME = <span class="number">.008</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断本次执行时间，如果大于MAX_EXECUTION_TIME，调用performSelector:withObject:afterDelay，结束本次调用</span></span><br><span class="line"><span class="keyword">if</span> (([_queue count] &gt; <span class="number">0</span>) &amp;&amp; ([<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate] - _startExecutionTime &gt; MAX_EXECUTION_TIME)) &#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(executePending) withObject:<span class="literal">nil</span> afterDelay:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化策略分析：</p><ul><li>将队列中的插件分割为很多小块来执行</li><li>开始执行<code>executePending</code>方法时，记录开始时间，每次执行完一个插件方法后，判断本次执行时间是否超过<code>MAX_EXECUTION_TIME</code>，如果没有超过，继续执行，如果超过了<code>MAX_EXECUTION_TIME</code>，调用<code>performSelector:withObject:afterDelay</code>，结束本次调用</li><li>如果要保证UI流畅，需要满足条件<code>CPU时间 + GPU时间 &lt;= 1s/60</code>， 为了给GPU留下足够的时间渲染，要尽量让CPU占用时间小于<code>1s/60/2</code></li><li>Runloop执行的流程如下图所示，系统在收到<code>kCFRunLoopBeforeWaiting</code>（线程即将休眠）通知时，会触发一次界面的渲染，也就是在完成<code>source0</code>的处理后</li><li><code>source0</code>在这里就是插件的执行代码，在<code>kCFRunLoopBeforeWaiting</code>通知之前，如果<code>source0</code>执行时间过长就会导致界面没有得到及时的刷新。</li><li>函数<code>performSelector:withObject:afterDelay</code>，会将方法注册到<code>Timer</code>，结束<code>source0</code>调用，开始渲染界面。界面渲染完成后，<code>Runloop</code>开始<code>sleep</code>，然后被<code>timer</code>唤醒又开始继续处理<code>source0</code>。</li></ul><p><img src="/images/15256833278020.png" alt=""></p><h3 id="插件方法执行"><a href="#插件方法执行" class="headerlink" title="插件方法执行"></a>插件方法执行</h3><p>方法最终的执行在方法<code>execute:</code>中，从command中取出要执行的插件类、方法、参数，然后执行方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)execute:(CDVInvokedUrlCommand*)command</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取插件实例</span></span><br><span class="line">    CDVPlugin* obj = [_viewController.commandDelegate getCommandInstance:command.className];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> retVal = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">double</span> started = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970] * <span class="number">1000.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span>* methodName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@:"</span>, command.methodName];</span><br><span class="line">    SEL normalSelector = <span class="built_in">NSSelectorFromString</span>(methodName);</span><br><span class="line">    <span class="keyword">if</span> ([obj respondsToSelector:normalSelector]) &#123;</span><br><span class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))objc_msgSend)(obj, normalSelector, command);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// There's no method to call, so throw an error.</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"ERROR: Method '%@' not defined in Plugin '%@'"</span>, methodName, command.className);</span><br><span class="line">        retVal = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> elapsed = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970] * <span class="number">1000.0</span> - started;</span><br><span class="line">    <span class="comment">// 监控插件方法执行时间，打印出大于10ms的方法</span></span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"THREAD WARNING: ['%@'] took '%f' ms. Plugin should use a background thread."</span>, command.className, elapsed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原生回调js"><a href="#原生回调js" class="headerlink" title="原生回调js"></a>原生回调js</h3><p>原生方法执行完成后，会把结果返回给js，调用方法<code>sendPluginResult:callbackId:</code>，用<code>CDVPluginResult</code>来传递回调参数，用<code>callbackId</code>来区分是哪次调用（callbackId由js产生）。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVCommandDelegateImpl.m</span></span><br><span class="line">- (<span class="keyword">void</span>)sendPluginResult:(CDVPluginResult*)result callbackId:(<span class="built_in">NSString</span>*)callbackId</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断callbackId长度是否小于100</span></span><br><span class="line">    <span class="comment">// 用正则表达式"[^A-Za-z0-9._-]"来验证callbackId</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> isValidCallbackId:callbackId]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态码</span></span><br><span class="line">    <span class="keyword">int</span> status = [result.status intValue];</span><br><span class="line">    <span class="comment">// 是否持续回调</span></span><br><span class="line">    <span class="built_in">BOOL</span> keepCallback = [result.keepCallback boolValue];</span><br><span class="line">    <span class="comment">// 会带哦参数</span></span><br><span class="line">    <span class="built_in">NSString</span>* argumentsAsJSON = [result argumentsAsJSON];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行js方法，回调</span></span><br><span class="line">    <span class="built_in">NSString</span>* js = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"cordova.require('cordova/exec').nativeCallback('%@',%d,%@,%d, %d)"</span>, callbackId, status, argumentsAsJSON, keepCallback, debug];</span><br><span class="line">    [<span class="keyword">self</span> evalJsHelper:js];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CDVPlugin注册与初始化"><a href="#CDVPlugin注册与初始化" class="headerlink" title="CDVPlugin注册与初始化"></a>CDVPlugin注册与初始化</h2><p>我们先看看配置文件中插件的定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义插件名为HandleOpenUrl的插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">feature</span> <span class="attr">name</span>=<span class="string">"HandleOpenUrl"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对应的iOS类名是CDVHandleOpenURL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ios-package"</span> <span class="attr">value</span>=<span class="string">"CDVHandleOpenURL"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 需要默认加载的插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"onload"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">feature</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="加载默认插件"><a href="#加载默认插件" class="headerlink" title="加载默认插件"></a>加载默认插件</h3><p>在<code>CDVViewController</code>的<code>viewDidLoad</code>时，从Cordova的配置文件<code>config.xml</code>中，读取出需要默认加载的插件，遍历初始化。</p><p><code>CDVViewController</code>中初始化默认插件代码。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    <span class="comment">// Load settings</span></span><br><span class="line">    [<span class="keyword">self</span> loadSettings];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.startupPluginNames count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [CDVTimer start:<span class="string">@"TotalPluginStartup"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span>* pluginName <span class="keyword">in</span> <span class="keyword">self</span>.startupPluginNames) &#123;</span><br><span class="line">            [CDVTimer start:pluginName];</span><br><span class="line">            <span class="comment">// 初始化插件</span></span><br><span class="line">            [<span class="keyword">self</span> getCommandInstance:pluginName];</span><br><span class="line">            [CDVTimer stop:pluginName];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [CDVTimer stop:<span class="string">@"TotalPluginStartup"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插件初始化"><a href="#插件初始化" class="headerlink" title="插件初始化"></a>插件初始化</h3><p>插件初始化的过程：</p><ol><li>加载配置文件<code>config.xml</code></li><li>根据插件名获取对应类名</li><li>根据类名从缓存中查找，如果命中直接返回</li><li>没有缓存重新创建一个实例，并写入缓存</li></ol><p>插件初始化的入口是<code>getCommandInstance</code>，传入参数是插件名称，返回一个插件的实例对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)getCommandInstance:(<span class="built_in">NSString</span>*)pluginName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在pluginsMap中用插件名称获取类名（插件名不区分大小写）</span></span><br><span class="line">    <span class="built_in">NSString</span>* className = [<span class="keyword">self</span>.pluginsMap objectForKey:[pluginName lowercaseString]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有配置插件，初始化失败</span></span><br><span class="line">    <span class="keyword">if</span> (className == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从缓存中获取，如果命中直接返回缓存</span></span><br><span class="line">    <span class="keyword">id</span> obj = [<span class="keyword">self</span>.pluginObjects objectForKey:className];</span><br><span class="line">    <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">        <span class="comment">// 没有缓存，创建一个新的实例</span></span><br><span class="line">        obj = [[<span class="built_in">NSClassFromString</span>(className)alloc] initWithWebViewEngine:_webViewEngine];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">// 实例创建成功，注册插件</span></span><br><span class="line">            [<span class="keyword">self</span> registerPlugin:obj withClassName:className];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"CDVPlugin class %@ (pluginName: %@) does not exist."</span>, className, pluginName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册插件的关键方法<code>registerPlugin:withClassName:</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerPlugin:(CDVPlugin*)plugin withClassName:(<span class="built_in">NSString</span>*)className</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([plugin respondsToSelector:<span class="keyword">@selector</span>(setViewController:)]) &#123;</span><br><span class="line">        [plugin setViewController:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([plugin respondsToSelector:<span class="keyword">@selector</span>(setCommandDelegate:)]) &#123;</span><br><span class="line">        [plugin setCommandDelegate:_commandDelegate];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入缓存</span></span><br><span class="line">    [<span class="keyword">self</span>.pluginObjects setObject:plugin forKey:className];</span><br><span class="line">    [plugin pluginInitialize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cordova还提供了插件名注册插件的方式，使用函数<code>registerPlugin:withPluginName:</code>，实现方式差不多，就不赘述了。</p><p>注册插件步骤</p><ol><li>设置插件的<code>viewController</code>和<code>delegate</code></li><li>将插件以<code>className</code>为key放入<code>pluginObjects</code>中，<code>pluginObjects</code>是一个插件的缓存</li><li>调用插件的<code>pluginInitialize</code></li></ol><h3 id="插件销毁"><a href="#插件销毁" class="headerlink" title="插件销毁"></a>插件销毁</h3><p>插件销毁的时机是创建插件的<code>CDVViewController</code>释放的时候，因为插件实例被创建后被缓存map引用，对应的销毁代码。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVViewController.m</span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    [CDVUserAgentUtil releaseLock:&amp;_userAgentLockToken];</span><br><span class="line">    [_commandQueue dispose];</span><br><span class="line">    [[<span class="keyword">self</span>.pluginObjects allValues] makeObjectsPerformSelector:<span class="keyword">@selector</span>(dispose)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CDVPlugin.m</span></span><br><span class="line">- (<span class="keyword">void</span>)dispose</span><br><span class="line">&#123;</span><br><span class="line">    viewController = <span class="literal">nil</span>;</span><br><span class="line">    commandDelegate = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>在<code>config.xml</code>文件中配置插件，声明插件与类的映射关系，以及加载策略</li><li>插件的初始化时懒加载，除了<code>onload</code>配置为<code>YES</code>的插件会默认加载，其它插件都是使用时加载</li><li>插件使用了两个Map来缓存，<code>pluginObjects</code>建立了类名与插件实例对象的映射，<code>pluginsMap</code>建立了插件名与类名的映射。</li><li>在一个<code>CDVViewController</code>中，同一个插件同时只会存在一个实例</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文设计到的源码是基于Cordova 4.2.1版本，&lt;a href=&quot;https://cordova.apache.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cordova官网&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;CDVViewControll
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅析AutoreleasePool源码</title>
    <link href="http://crmo.github.io/2018/04/14/%E6%B5%85%E6%9E%90AutoreleasePool%E6%BA%90%E7%A0%81/"/>
    <id>http://crmo.github.io/2018/04/14/浅析AutoreleasePool源码/</id>
    <published>2018-04-14T07:31:00.000Z</published>
    <updated>2018-04-14T07:31:28.990Z</updated>
    
    <content type="html"><![CDATA[<p>最近在拜读Draveness大佬的一篇文章<a href="https://draveness.me/autoreleasepool" target="_blank" rel="noopener">自动释放池的前世今生 —- 深入解析 autoreleasepool</a>，看到文中给读者留了一个问题：</p><blockquote><p>我到现在也不是很清楚为什么要根据当前页的不同状态 kill 掉不同 child 的页面。</p></blockquote><p>关于<code>AutoreleasePool</code>是什么，强力推荐阅读原文，写的很好。这里就不说了，直接讨论问题。</p><p>首先是整个<code>pop</code>方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static inline void pop(void *token) </span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        // Popping the top-level placeholder pool.</span><br><span class="line">        if (hotPage()) &#123;</span><br><span class="line">            // Pool was used. Pop its contents normally.</span><br><span class="line">            // Pool pages remain allocated for re-use as usual.</span><br><span class="line">            pop(coldPage()-&gt;begin());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Pool was never used. Clear the placeholder.</span><br><span class="line">            setHotPage(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);</span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    if (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        if (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            // Start of coldest page may correctly not be POOL_BOUNDARY:</span><br><span class="line">            // 1. top-level pool is popped, leaving the cold page in place</span><br><span class="line">            // 2. an object is autoreleased with no pool</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Error. For bincompat purposes this is not </span><br><span class="line">            // fatal in executables built with old SDKs.</span><br><span class="line">            return badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (PrintPoolHiwat) printHiwat();</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    // memory: delete empty children</span><br><span class="line">    if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        // special case: delete everything during page-per-pool debugging</span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        // special case: delete everything for pop(top) </span><br><span class="line">        // when debugging missing autorelease pools</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    else if (page-&gt;child) &#123;</span><br><span class="line">        // hysteresis: keep one empty child if page is more than half fully</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先看看释放的函数<code>releaseUntil</code>，它在释放的时候其实会一直顺着<code>parent</code>往前释放，直到参数<code>stop</code>，也就是说可能一次性释放好几个<code>page</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 代码有所删减</span><br><span class="line">void releaseUntil(id *stop)</span><br><span class="line">&#123;</span><br><span class="line">    while (this-&gt;next != stop) &#123;</span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line">        </span><br><span class="line">        while (page-&gt;empty()) &#123;</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        id obj = *--page-&gt;next;</span><br><span class="line">        memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));</span><br><span class="line">        </span><br><span class="line">        if (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    setHotPage(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们来看看这段有疑问的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// memory: delete empty children</span><br><span class="line">if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;  // 分支1</span><br><span class="line">    // special case: delete everything during page-per-pool debugging</span><br><span class="line">    AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">    page-&gt;kill();</span><br><span class="line">    setHotPage(parent);</span><br><span class="line">&#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123; // 分支2</span><br><span class="line">    // special case: delete everything for pop(top) </span><br><span class="line">    // when debugging missing autorelease pools</span><br><span class="line">    page-&gt;kill();</span><br><span class="line">    setHotPage(nil);</span><br><span class="line">&#125; </span><br><span class="line">else if (page-&gt;child) &#123; // 分支3</span><br><span class="line">    // hysteresis: keep one empty child if page is more than half fully</span><br><span class="line">    if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">        page-&gt;child-&gt;kill();</span><br><span class="line">    &#125;</span><br><span class="line">    else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">        page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码的作用是删除空的子节点，释放内存。pop之后三种情况：</p><ol><li>当前<code>page</code>为空，直接kill掉当前<code>page</code>，然后把<code>parent</code>设置为<code>hotpage</code>；</li><li>当前<code>page</code>为空，而且没有<code>parent</code>，kill掉当前<code>page</code>，<code>hotpage</code>置为空；</li><li>当前<code>page</code>不为空，但是有<code>child</code>，如果当前<code>page</code>的空间占用不到一半，释放<code>child</code>，如果当前<code>page</code>的空间占用超过一半，且<code>child</code>还有<code>child</code>，直接释放这个孙子辈的<code>page</code>。（对于第三步注释中的解释是：keep one empty child if page is more than half fully）</li></ol><p>我们再看看<code>kill</code>的实现，可以发现他是会顺着<code>child</code>一直往后释放，保证释放节点的<code>child page</code>都被释放了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void kill()</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page = this;</span><br><span class="line">    while (page-&gt;child) page = page-&gt;child;</span><br><span class="line">    </span><br><span class="line">    AutoreleasePoolPage *deathptr;</span><br><span class="line">    do &#123;</span><br><span class="line">        deathptr = page;</span><br><span class="line">        page = page-&gt;parent;</span><br><span class="line">        if (page) &#123;</span><br><span class="line">            page-&gt;unprotect();</span><br><span class="line">            page-&gt;child = nil;</span><br><span class="line">            page-&gt;protect();</span><br><span class="line">        &#125;</span><br><span class="line">        delete deathptr;</span><br><span class="line">    &#125; while (deathptr != this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就可以得出结论了：</p><ol><li>pop之后，所有<code>child page</code>肯定都为空了，且当前<code>page</code>一定是<code>hotPage</code></li><li>系统为了节约内存，判断，如果当前<code>page</code>空间使用少于一半，就释放掉所有的<code>child page</code>，如果当前<code>page</code>空间使用大于一半，就从孙子<code>page</code>开始释放，预留一个<code>child page</code>。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在拜读Draveness大佬的一篇文章&lt;a href=&quot;https://draveness.me/autoreleasepool&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自动释放池的前世今生 —- 深入解析 autoreleasepool&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS用原生代码读写Webview的Local Storage</title>
    <link href="http://crmo.github.io/2018/04/03/iOS%E7%94%A8%E5%8E%9F%E7%94%9F%E4%BB%A3%E7%A0%81%E8%AF%BB%E5%86%99Webview%E7%9A%84Local%20Storage/"/>
    <id>http://crmo.github.io/2018/04/03/iOS用原生代码读写Webview的Local Storage/</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-04-03T12:41:51.225Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/15226724314775.jpg" alt=""></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司项目使用的<code>Cordova</code>混合开发的，有一个模块以前用H5实现的，新版本用原生来实现，于是需要迁移数据。H5使用的Local Storage存的数据，原生要拿到数据有两种方案：</p><ol><li>用<code>WebView</code>执行js方法来读取数据；</li><li>找到<code>Local Storage</code>存储路径，直接读取；</li></ol><p>方案一实现起来比较简单，但是会存在一些问题，需要多开一个Webview来迁移数据，而且这个过程不好控制，不是最优解，本文讨论的是方案二。</p><h2 id="直接读写Local-Storage"><a href="#直接读写Local-Storage" class="headerlink" title="直接读写Local Storage"></a>直接读写Local Storage</h2><p>先说结论，<code>Local Storage</code>的其实是一个Sqlite数据库，我们要读写数据只要找到这个数据库，然后就可以实现手动读写了。</p><h3 id="数据库存放路径"><a href="#数据库存放路径" class="headerlink" title="数据库存放路径"></a>数据库存放路径</h3><blockquote><p>iOS 5.1及之前使用UIWebView：Library/Caches/<br>iOS 5.1之后使用UIWebView：Library/WebKit/LocalStorage/<br>WKWebView：Library/WebKit/WebsiteData/LocalStorage/</p></blockquote><blockquote><p>// UIWebView可以从UserDefault取出LocalStorage的路径<br>[[NSUserDefaults standardUserDefaults] objectForKey:@”WebKitLocalStorageDatabasePathPreferenceKey”]</p></blockquote><p><img src="/images/15226716925888.jpg" alt=""></p><h3 id="数据存储方式"><a href="#数据存储方式" class="headerlink" title="数据存储方式"></a>数据存储方式</h3><p>数据存在<code>ItemTable</code>表，只有<code>key</code>和<code>value</code>两个字段，key直接用NSString可以取出来，value取出来是一个NSData，需要用<code>NSUTF16LittleEndianStringEncoding</code>解码。</p><p><img src="/images/15226719772136.jpg" alt=""></p><h3 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h3><p>写了个简易的Demo，用的<a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a>来操作数据库，这里就不介绍了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 取数据</span><br><span class="line">- (NSString *)valueWithKey:(NSString *)key &#123;</span><br><span class="line">    if ([NSString isNull:key]) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __block NSString *result;</span><br><span class="line">    [self.dataQueue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">        NSData *data = [db dataForQuery:@&quot;select value from ItemTable where key = ?&quot;, key];</span><br><span class="line">        result = [[NSString alloc] initWithData:data encoding:NSUTF16LittleEndianStringEncoding];</span><br><span class="line">    &#125;];</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 存数据</span><br><span class="line">- (BOOL)saveValue:(NSString *)value forKey:(NSString *)key &#123;</span><br><span class="line">    if ([NSString isNull:value] ||</span><br><span class="line">        [NSString isNull:key]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __block BOOL result;</span><br><span class="line">    [self.dataQueue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">        [db executeUpdate:@&quot;delete from ItemTable where key = ?&quot;, key];</span><br><span class="line">        NSData *data = [value dataUsingEncoding:NSUTF16LittleEndianStringEncoding];</span><br><span class="line">        result = [db executeUpdate:@&quot;insert into ItemTable (key, value) values (?, ?)&quot;, key, data];</span><br><span class="line">    &#125;];</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebKit源码分析"><a href="#WebKit源码分析" class="headerlink" title="WebKit源码分析"></a>WebKit源码分析</h2><p>为了找到<code>Local Storage</code>存放的路径，在网上找了很多资料，发现这方面的资料很少，也没有怕出现各种坑或者系统版本兼容，于是决定研究下WebKit源码，从源码里面找答案。</p><p>Webkit、WebCore<a href="https://opensource.apple.com/release/ios-110.html" target="_blank" rel="noopener">源码地址</a>。可以看到WebKit有两个版本，<code>WebKit-7604.1.38.0.7</code>和<code>WebKit2-7604.1.38.0.7</code>，前者是UIWebView的，后者是WKWebView的。</p><p><img src="/images/15226724314772.jpg" alt=""></p><p>解压<code>WebKit-7604.1.38.0.7</code>。用Xcode打开工程文件，工程名叫<code>WebKitLegacy</code>，这个命名太形象了，WebKit的遗产。苦于各种历史原因，公司项目还停留在UIWebView的阶段，心塞。<br>在WebStorageManager.m类中可以看到关于<code>Local Storage</code>保存路径的定义，路径是<code>Library/WebKit/LocalStorage/</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void initializeLocalStoragePath()</span><br><span class="line">&#123;</span><br><span class="line">    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">    sLocalStoragePath = [defaults objectForKey:WebStorageDirectoryDefaultsKey];</span><br><span class="line">    if (!sLocalStoragePath || ![sLocalStoragePath isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">        NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);</span><br><span class="line">        NSString *libraryDirectory = [paths objectAtIndex:0];</span><br><span class="line">        sLocalStoragePath = [libraryDirectory stringByAppendingPathComponent:@&quot;WebKit/LocalStorage&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    sLocalStoragePath = [[sLocalStoragePath stringByStandardizingPath] retain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解压<code>WebKit2-7604.1.38.0.7</code>，路径定义在<code>WKProcessPool.mm</code>类中，路径是<code>Library/WebKit/WebsiteData/LocalStorage/</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURL *)_websiteDataURLForContainerWithURL:(NSURL *)containerURL bundleIdentifierIfNotInContainer:(NSString *)bundleIdentifier</span><br><span class="line">&#123;</span><br><span class="line">    NSURL *url = [containerURL URLByAppendingPathComponent:@&quot;Library&quot; isDirectory:YES];</span><br><span class="line">    url = [url URLByAppendingPathComponent:@&quot;WebKit&quot; isDirectory:YES];</span><br><span class="line"></span><br><span class="line">    if (!WebKit::processHasContainer() &amp;&amp; bundleIdentifier)</span><br><span class="line">        url = [url URLByAppendingPathComponent:bundleIdentifier isDirectory:YES];</span><br><span class="line"></span><br><span class="line">    return [url URLByAppendingPathComponent:@&quot;WebsiteData&quot; isDirectory:YES];</span><br></pre></td></tr></table></figure><p>至此关于<code>UIWebView</code>和<code>WKWebView</code>的存放路径我们已经能够确定了，那么文件名是怎么定义的呢，这要看<code>WebCore</code>的源码了，在<code>SecurityOriginData.cpp</code>中定义了文件名命名规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String SecurityOriginData::databaseIdentifier() const</span><br><span class="line">&#123;</span><br><span class="line">    // Historically, we&apos;ve used the following (somewhat non-sensical) string</span><br><span class="line">    // for the databaseIdentifier of local files. We used to compute this</span><br><span class="line">    // string because of a bug in how we handled the scheme for file URLs.</span><br><span class="line">    // Now that we&apos;ve fixed that bug, we still need to produce this string</span><br><span class="line">    // to avoid breaking existing persistent state.</span><br><span class="line">    if (equalIgnoringASCIICase(protocol, &quot;file&quot;))</span><br><span class="line">        return ASCIILiteral(&quot;file__0&quot;);</span><br><span class="line">    </span><br><span class="line">    StringBuilder stringBuilder;</span><br><span class="line">    stringBuilder.append(protocol);</span><br><span class="line">    stringBuilder.append(separatorCharacter);</span><br><span class="line">    stringBuilder.append(encodeForFileName(host));</span><br><span class="line">    stringBuilder.append(separatorCharacter);</span><br><span class="line">    stringBuilder.appendNumber(port.value_or(0));</span><br><span class="line">    </span><br><span class="line">    return stringBuilder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码我们可以得出结论，如果是file协议的url，文件名定义为<code>file__0</code>，否则会根据它的url来生成一个文件名。</p><p>在跟代码的时候，发现<code>UIWebView</code>会把<code>Local Storage</code>的存储路径存在<code>UserDefault</code>里，存储的Key是<code>WebKitLocalStorageDatabasePathPreferenceKey</code>（定义在<code>WebPreferenceKeysPrivate.h</code>）。在文件<code>WebPrefences.mm</code>中可以找到相关代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)_localStorageDatabasePath</span><br><span class="line">&#123;</span><br><span class="line">    return [[self _stringValueForKey:WebKitLocalStorageDatabasePathPreferenceKey] stringByStandardizingPath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSString *)_stringValueForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    id s = [self _valueForKey:key];</span><br><span class="line">    return [s isKindOfClass:[NSString class]] ? (NSString *)s : nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)_valueForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_key = KEY(key);</span><br><span class="line">#if PLATFORM(IOS)</span><br><span class="line">    __block id o = nil;</span><br><span class="line">    dispatch_sync(_private-&gt;readWriteQueue, ^&#123;</span><br><span class="line">        o = [_private-&gt;values.get() objectForKey:_key];</span><br><span class="line">    &#125;);</span><br><span class="line">#else</span><br><span class="line">    id o = [_private-&gt;values.get() objectForKey:_key];</span><br><span class="line">#endif</span><br><span class="line">    if (o)</span><br><span class="line">        return o;</span><br><span class="line">    o = [[NSUserDefaults standardUserDefaults] objectForKey:_key];</span><br><span class="line">    if (!o &amp;&amp; key != _key)</span><br><span class="line">        o = [[NSUserDefaults standardUserDefaults] objectForKey:key];</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Local-Storage存在的问题"><a href="#Local-Storage存在的问题" class="headerlink" title="Local Storage存在的问题"></a>Local Storage存在的问题</h2><p>在查询资料的过程中，发现了很多Local Storage的缺陷，有一篇关于Local Storage的<a href="https://thinkmind.org/download.php?articleid=mobility_2017_2_10_90007" target="_blank" rel="noopener">论文</a>可以参考。有以下几点：</p><ol><li>不要用Local Storage来做持久化存储，在iOS中，出现存储空间紧张时，它会被系统清理掉；</li><li>不要用Local Storage来存大数据，它的读写效率很低下，因为它需要序列化/反序列化</li><li>它有5M的大小限制</li></ol><p>总结起来就一句话，不要滥用Local Storage。有很多替代方案，比如<a href="https://github.com/TheCocoaProject/cordova-plugin-nativestorage" target="_blank" rel="noopener">https://github.com/TheCocoaProject/cordova-plugin-nativestorage</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/wootwoot1234/react-native-webkit-localstorage-reader/issues/4" target="_blank" rel="noopener">https://github.com/wootwoot1234/react-native-webkit-localstorage-reader/issues/4</a><br><a href="https://blog.csdn.net/shuimuniao/article/details/8027276" target="_blank" rel="noopener">https://blog.csdn.net/shuimuniao/article/details/8027276</a><br><a href="https://stackoverflow.com/questions/26465409/restore-localstorage-data-from-old-cordova-app/49604587#49604587" target="_blank" rel="noopener">https://stackoverflow.com/questions/26465409/restore-localstorage-data-from-old-cordova-app/49604587#49604587</a><br><a href="https://stackoverflow.com/questions/9067249/how-do-i-access-html5-local-storage-created-by-phonegap-on-ios/49604541#49604541" target="_blank" rel="noopener">https://stackoverflow.com/questions/9067249/how-do-i-access-html5-local-storage-created-by-phonegap-on-ios/49604541#49604541</a><br><a href="https://issues.apache.org/jira/browse/CB-12509" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/CB-12509</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/15226724314775.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;公司项目使用的&lt;code&gt;Cord
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AFNetworking下载文件时文件名长度的坑</title>
    <link href="http://crmo.github.io/2018/03/29/AFNetworking%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%97%B6%E6%96%87%E4%BB%B6%E5%90%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E5%9D%91/"/>
    <id>http://crmo.github.io/2018/03/29/AFNetworking下载文件时文件名长度的坑/</id>
    <published>2018-03-29T14:23:00.000Z</published>
    <updated>2018-03-28T14:24:52.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近遇到一个Bug，在用AFNetworking下载文件的时候莫名其妙的失败了，跟了一下发现一个小坑，记录一下防止以后再掉进去。</p><blockquote><p>iOS和Linux的文件名的长度限制相同都是255个字符！！！</p></blockquote><p>问题根源是文件名超度超过了255个字符，AFNetworking下载文件是成功了（框架会把文件下载到一个临时文件，例如：<code>CFNetworkDownload_xxx.tmp</code>，这个文件名不会出现过长的问题），下载成功之后会copy到调用者指定路径，在这里指定的文件名超过了255个字符，导致创建文件失败，于是回调是成功了，但是在设置的路径找不到这个文件。</p><p>上代码！</p><p>下载代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 注意对文件名长度进行处理！！！</span><br><span class="line">NSString *destination = @&quot;下载地址（长度大于255）&quot;;</span><br><span class="line">NSURLSessionDownloadTask *aTask = [self.updownloadSessionManager downloadTaskWithRequest:mutableRequest progress:^(NSProgress * _Nonnull downloadProgress) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123;</span><br><span class="line">        return [NSURL fileURLWithPath:destination];</span><br><span class="line">    &#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) &#123;</span><br><span class="line">        // 下载成功后会回调该block，但是路径`destination`找不到这个文件</span><br><span class="line">    &#125;];</span><br><span class="line">    [aTask resume];</span><br></pre></td></tr></table></figure><p>出错的地方<strong>AFURLSessionManager.m</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">    self.downloadFileURL = nil;</span><br><span class="line"></span><br><span class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        if (self.downloadFileURL) &#123;</span><br><span class="line">            NSError *fileManagerError = nil;</span><br><span class="line"></span><br><span class="line">            // location是临时文件，是下载成功了</span><br><span class="line">            // self.downloadFileURL 是目标路径，文件名超过255</span><br><span class="line">            // 移动文件会报错</span><br><span class="line">            if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError]) &#123;</span><br><span class="line">            // 出错会发通知，可以监听处理</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看<code>AFURLSessionDownloadTaskDidFailToMoveFileNotification</code>的定义<br><strong>AFURLSessionManager.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> Posted when a session download task encountered an error when moving the temporary download file to a specified destination.</span><br><span class="line"> */</span><br><span class="line">FOUNDATION_EXPORT NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近遇到一个Bug，在用AFNetworking下载文件的时候莫名其妙的失败了，跟了一下发现一个小坑，记录一下防止以后再掉进去。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS用CallKit实现来电识别、来电拦截</title>
    <link href="http://crmo.github.io/2018/03/03/iOS%E7%94%A8CallKit%E5%AE%9E%E7%8E%B0%E6%9D%A5%E7%94%B5%E8%AF%86%E5%88%AB&amp;%E6%9D%A5%E7%94%B5%E6%8B%A6%E6%88%AA/"/>
    <id>http://crmo.github.io/2018/03/03/iOS用CallKit实现来电识别&amp;来电拦截/</id>
    <published>2018-03-03T09:33:54.000Z</published>
    <updated>2018-03-03T09:59:26.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近需要实现一个新需求，用iOS 10出的CallKit实现将APP的通讯录的信息同步到系统中，可以不把人员信息加到通讯录中，实现来电号码识别。这个功能在xx安全卫士、xx管家中很早就实现了，但是网上相关的资料较少，而且官方的文档写的太简单了，很多坑还要自己去摸索。于是记录一下和各位分享，如有错误之处请各位指出！</p></blockquote><p>PS: 先说个题外话吧，CallKit功能在iOS 10的时候还不太稳定，iOS 10刚出来的时候为了体验骚扰拦截功能，手贱装了两个不同的拦截APP，然后就悲剧了。盗一张网上的图：</p><p><img src="http://upload-images.jianshu.io/upload_images/2665383-e1a2d7ab18506810.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p><p>然后各种重启、重装APP都没有用，写的Demo也跑不起来，唯一的办法只有重置系统。说多了都是泪！</p><blockquote><p>本文涉及的<a href="https://github.com/crmo/CRCallDirectoryDemo" target="_blank" rel="noopener">Demo</a>。</p></blockquote><h2 id="一、Call-Directory-app-extension"><a href="#一、Call-Directory-app-extension" class="headerlink" title="一、Call Directory app extension"></a>一、Call Directory app extension</h2><p>实现来电识别、来电拦截功能需要使用CallKit当中的<code>Call Directory app extension</code>，首先，需要了解extension。关于extension网上有很多教程，这里就不细说了。推荐两篇文章，英文好的推荐看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html" target="_blank" rel="noopener">官方文档</a>，还有一篇<a href="http://foggry.com/blog/2014/06/23/wwdc2014zhi-app-extensionsxue-xi-bi-ji/" target="_blank" rel="noopener">中文博客</a>。</p><p>使用Call Directory Extension主要需要和3个类打交道，分别是<br><code>CXCallDirectoryProvider</code>、<code>CXCallDirectoryExtensionContext</code>、<code>CXCallDirectoryManager</code>。</p><p><img src="http://upload-images.jianshu.io/upload_images/2665383-c7c5d8e8809480bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p><h3 id="CXCallDirectoryProvider"><a href="#CXCallDirectoryProvider" class="headerlink" title="CXCallDirectoryProvider"></a>CXCallDirectoryProvider</h3><blockquote><p>官方文档：The principal object for a Call Directory app extension for a host app.</p></blockquote><p>正如官方文档所说，这是Call Directory app extension最重要的一个类。<br>用系统模板新建Call Directory Extension之后会自动生成一个类，继承自<code>CXCallDirectoryProvider</code>。入口方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有两种情况改方法会被调用</span></span><br><span class="line"><span class="comment">// 1.第一次打开设置-电话-来电阻止与身份识别开关时，系统自动调用</span></span><br><span class="line"><span class="comment">// 2.调用CXCallDirectoryManager的reloadExtensionWithIdentifier方法会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)beginRequestWithExtensionContext:(CXCallDirectoryExtensionContext *)context &#123;</span><br><span class="line">    context.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 添加号码识别信息与号码拦截列表</span></span><br><span class="line">    [<span class="keyword">self</span> addIdentificationPhoneNumbersToContext:context];</span><br><span class="line">    [context completeRequestWithCompletionHandler:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="CXCallDirectoryExtensionContext"><a href="#CXCallDirectoryExtensionContext" class="headerlink" title="CXCallDirectoryExtensionContext"></a>CXCallDirectoryExtensionContext</h3><blockquote><p>官方文档：A programmatic interface for adding identification and blocking entries to a Call Directory app extension.<br>CXCallDirectoryExtensionContext objects are not initialized directly, but are instead passed as arguments to the CXCallDirectoryProvider instance method beginRequestWithExtensionContext:.</p></blockquote><p>大致意思就是说，这是一个为Call Directory app extension添加号码识别、号码拦截的入口。<code>CXCallDirectoryExtensionContext</code>不需要自己初始化，它会作为<code>CXCallDirectoryProvider</code>的<code>beginRequestWithExtensionContext</code>函数的参数传递给使用者。<br>它的主要方法有两个：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置号码识别信息</span></span><br><span class="line">- (<span class="keyword">void</span>)addIdentificationEntryWithNextSequentialPhoneNumber:(CXCallDirectoryPhoneNumber)phoneNumber label:(<span class="built_in">NSString</span> *)label;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置号码拦截列表</span></span><br><span class="line">- (<span class="keyword">void</span>)addBlockingEntryWithNextSequentialPhoneNumber:(CXCallDirectoryPhoneNumber)phoneNumber;</span><br></pre></td></tr></table></figure><blockquote><p>在设置时候要注意：</p><ol><li>号码不能重复，不然会报错<code>CXErrorCodeCallDirectoryManagerErrorDuplicateEntries</code></li><li>号码必须按照升序写入，不然会报错<code>CXErrorCodeCallDirectoryManagerErrorEntriesOutOfOrder</code></li><li>号码必须格式化后传入，手机号码必须加上国家码，例如18012341234就不行，需要加上86，构造成8618012341234；固话需要格式为：国家码+区号（去掉第一个0）+号码，例如010-61001234格式化之后为，861061001234。如果号码格式错误，会导致识别不出来。</li><li>上限数据是200万（在其它文章里看到的，然后自己测试了下，构造了200万条数据写入的时候会报错<code>CXErrorCodeCallDirectoryManagerErrorMaximumEntriesExceeded</code>，150万条数据是OK的，所以这个数据上限一定要注意。实测安装了XX安全卫士、XX管家实现骚扰电话拦截用了3个extension，可能数据量太大就是一个原因。）</li><li>在用户第一次打开设置时，会调用<code>beginRequestWithExtensionContext</code>，这时候不宜写太多数据，不然会卡在设置那里转圈，用户体验很差。可以先写部分数据，然后回到主APP了调用<code>reloadExtensionWithIdentifier</code>去刷新。</li></ol></blockquote><h3 id="CXCallDirectoryManager"><a href="#CXCallDirectoryManager" class="headerlink" title="CXCallDirectoryManager"></a>CXCallDirectoryManager</h3><blockquote><p>官方文档：The programmatic interface to an object that manages a Call Directory app extension.</p></blockquote><p><code>CXCallDirectoryManager</code>主要作用是管理Call Directory app extension。<br>有两个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新设置号码识别、电话拦截列表</span></span><br><span class="line"><span class="comment">// 调用该方法后会重置之前设置的列表，然后调用beginRequestWithExtensionContext:</span></span><br><span class="line">- (<span class="keyword">void</span>)reloadExtensionWithIdentifier:(<span class="built_in">NSString</span> *)identifier completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *_Nullable error))completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取extension是否可用，需要在“设置-电话-来电阻止与身份识别"中开启权限</span></span><br><span class="line">- (<span class="keyword">void</span>)getEnabledStatusForExtensionWithIdentifier:(<span class="built_in">NSString</span> *)identifier completionHandler:(<span class="keyword">void</span> (^)(CXCallDirectoryEnabledStatus enabledStatus, <span class="built_in">NSError</span> *_Nullable error))completion;</span><br></pre></td></tr></table></figure><h2 id="二、实战"><a href="#二、实战" class="headerlink" title="二、实战"></a>二、实战</h2><blockquote><p>先上<a href="https://github.com/crmo/CRCallDirectoryDemo" target="_blank" rel="noopener">Demo地址</a>。下面会一步步讲解。</p></blockquote><h3 id="创建extension"><a href="#创建extension" class="headerlink" title="创建extension"></a>创建extension</h3><p>新建一个Target（File-New-Target）。</p><p><img src="http://upload-images.jianshu.io/upload_images/2665383-bb94a974d77e4e75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p><p>会自动建立一个目录，默认有三个文件。在.m文件中有系统给出的示例代码</p><p><img src="http://upload-images.jianshu.io/upload_images/2665383-6a832bc0e0f65e67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p><p>我们来看看系统的模板代码，首先是入口函数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)beginRequestWithExtensionContext:(CXCallDirectoryExtensionContext *)context &#123;</span><br><span class="line">    context.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">if</span> (context.isIncremental) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addOrRemoveIncrementalBlockingPhoneNumbersToContext:context];</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> addOrRemoveIncrementalIdentificationPhoneNumbersToContext:context];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> addAllBlockingPhoneNumbersToContext:context];</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> addAllIdentificationPhoneNumbersToContext:context];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [context completeRequestWithCompletionHandler:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CallDirectoryHandler"><a href="#CallDirectoryHandler" class="headerlink" title="CallDirectoryHandler"></a>CallDirectoryHandler</h3><p>我在Xcode 9生成的代码，<code>context.isIncremental</code>是iOS 11才增加的，还有所有的remove的方法也是iOS 11才有的，为了适配iOS 10，还是不推荐使用。<br>系统模板代码大致逻辑就是，先添加号码识别、号码拦截记录，添加完成后调用<code>completeRequestWithCompletionHandler:</code>完成整个过程。<br>由于号码拦截比较简单，只是写入一个号码的数组，本文就以号码识别为例，号码识别方法系统模板这么写的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addAllIdentificationPhoneNumbersToContext:(CXCallDirectoryExtensionContext *)context &#123;</span><br><span class="line">    CXCallDirectoryPhoneNumber allPhoneNumbers[] = &#123; <span class="number">8618788888888</span>, <span class="number">8618885555555</span> &#125;;</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *labels = @[ <span class="string">@"送餐电话"</span>, <span class="string">@"诈骗电话"</span> ];</span><br><span class="line">    <span class="built_in">NSUInteger</span> count = (<span class="keyword">sizeof</span>(allPhoneNumbers) / <span class="keyword">sizeof</span>(CXCallDirectoryPhoneNumber));</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; count; i += <span class="number">1</span>) &#123;</span><br><span class="line">        CXCallDirectoryPhoneNumber phoneNumber = allPhoneNumbers[i];</span><br><span class="line">        <span class="built_in">NSString</span> *label = labels[i];</span><br><span class="line">        [context addIdentificationEntryWithNextSequentialPhoneNumber:phoneNumber label:label];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这么多代码，核心就是一行<code>[context addIdentificationEntryWithNextSequentialPhoneNumber:phoneNumber label:label];</code>,注意phoneNumber是<code>CXCallDirectoryPhoneNumber</code>类型，其实就是<code>long long</code>类型。<br>在这个函数里，需要把需要识别的号码和识别信息，一条一条的写入</p><h3 id="检查授权"><a href="#检查授权" class="headerlink" title="检查授权"></a>检查授权</h3><p>开启extension功能需要在“设置-电话-来电阻止与身份识别”中开启，我们在写入数据时第一步是引导用户给我们的extension授权。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> CXCallDirectoryManager *manager = [CXCallDirectoryManager sharedInstance];</span><br><span class="line"> [manage</span><br><span class="line">  getEnabledStatusForExtensionWithIdentifier:<span class="keyword">self</span>.externsionIdentifier</span><br><span class="line">  completionHandler:^(CXCallDirectoryEnabledStatus enabledStatus, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">      <span class="comment">// 根据error，enabledStatus判断授权情况</span></span><br><span class="line"><span class="comment">// error == nil &amp;&amp; enabledStatus == CXCallDirectoryEnabledStatusEnabled 说明可用</span></span><br><span class="line"><span class="comment">// error 见 CXErrorCodeCallDirectoryManagerError</span></span><br><span class="line"><span class="comment">// enabledStatus 见 CXCallDirectoryEnabledStatus</span></span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure></p><h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><p>用户在设置开启后，调用<code>reloadExtensionWithIdentifier</code>即可触发<code>CallDirectoryHandler</code>更新数据逻辑。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CXCallDirectoryManager *manager = [CXCallDirectoryManager sharedInstance];</span><br><span class="line">[manager reloadExtensionWithIdentifier:<span class="keyword">self</span>.externsionIdentifier completionHandler:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">// error 见 CXErrorCodeCallDirectoryManagerError</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>接下来在真机下跑下（一定要在插了电话卡的iPhone上调试，模拟器不行！），写入成功后，打开电话，拨号18788888888，提示”送餐电话”。说明写入成功！</p><p><img src="http://upload-images.jianshu.io/upload_images/2665383-2261a7358b0a6964.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p><h2 id="三、extension和containing-app数据共享"><a href="#三、extension和containing-app数据共享" class="headerlink" title="三、extension和containing app数据共享"></a>三、extension和containing app数据共享</h2><p>上面的步骤中，号码信息是写死在代码中的，在实际应用中这些号码信息肯定不是写死的，一般需要从服务器获取。这就需要我们的APP与extension进行通信，需要用到APP Groups，怎么用网上有很多文章了，我就不多说了，<a href="http://foggry.com/blog/2014/06/23/wwdc2014zhi-app-extensionsxue-xi-bi-ji/" target="_blank" rel="noopener">推荐一篇</a>。<br>其实本质就是通过<code>APP Groups</code>，开辟一片空间，extension和containing app都可以访问，然后我们的APP就可以通过NSUserDefaults、文件、数据库等方式共享数据给extension了。前期我使用过NSUserDefaults，效率很低，大概在5万数据的时候就爆内存了，使用extension一定要注意内存，不然很容易被系统干掉，所以不推荐使用这种方式。<br>Demo中采用的是读写文件的方式，大致思路（<code>具体实现看Demo</code>）：</p><ol><li>在APP中把数据序列化之后写到一个文件中</li><li>在extension中读取这个文件，读取一行，调用一次<code>addIdentificationEntryWithNextSequentialPhoneNumber</code>，然后及时释放<br>这种方式理论上是可以达到最大限制200w条的（实际测试150万没有问题）。</li></ol><h3 id="获取APP-Groups文件路径"><a href="#获取APP-Groups文件路径" class="headerlink" title="获取APP Groups文件路径"></a>获取APP Groups文件路径</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSURL</span> *containerURL = [[<span class="built_in">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class="keyword">self</span>.groupIdentifier];</span><br><span class="line">    containerURL = [containerURL URLByAppendingPathComponent:<span class="string">@"CallDirectoryData"</span>];</span><br><span class="line">    <span class="built_in">NSString</span>* filePath = containerURL.path;</span><br></pre></td></tr></table></figure><h3 id="进度监控"><a href="#进度监控" class="headerlink" title="进度监控"></a>进度监控</h3><p>在xx安全卫士中，开启骚扰电话拦截功能有一个进度条，非常的直观。但是在extension中是没法更新UI的，有一种实现方式，可以用开源框架<a href="https://github.com/mutualmobile/MMWormhole" target="_blank" rel="noopener">MMWormhole</a>来实现APP与extension通信，然后把进度从extension传到APP中，在APP中更新进度条。理论上该方案是可行的，感兴趣的同学可以尝试下。</p><hr><ul><li>参考链接<br><a href="https://developer.apple.com/documentation/callkit" target="_blank" rel="noopener">https://developer.apple.com/documentation/callkit</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/230/" target="_blank" rel="noopener">https://developer.apple.com/videos/play/wwdc2016/230/</a><br><a href="https://colin1994.github.io/2016/06/17/Call-Directory-Extension-Study/" target="_blank" rel="noopener">https://colin1994.github.io/2016/06/17/Call-Directory-Extension-Study/</a><br><a href="https://yunissong.github.io/2017/03/29/CallKit/" target="_blank" rel="noopener">https://yunissong.github.io/2017/03/29/CallKit/</a><br><a href="http://www.jianshu.com/p/7f88cbe7948c" target="_blank" rel="noopener">http://www.jianshu.com/p/7f88cbe7948c</a><br><a href="https://www.raywenderlich.com/150015/callkit-tutorial-ios" target="_blank" rel="noopener">https://www.raywenderlich.com/150015/callkit-tutorial-ios</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近需要实现一个新需求，用iOS 10出的CallKit实现将APP的通讯录的信息同步到系统中，可以不把人员信息加
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS的Cookie管理</title>
    <link href="http://crmo.github.io/2018/03/01/iOS%E7%9A%84Cookie%E7%AE%A1%E7%90%86/"/>
    <id>http://crmo.github.io/2018/03/01/iOS的Cookie管理/</id>
    <published>2018-03-01T12:00:00.000Z</published>
    <updated>2018-03-03T10:14:03.915Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/1.jpeg" alt=""></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近有一个需求，需要手动的去缓存cookie，然后启动APP的时候设置缓存过的cookie，项目网络框架用的是Afnetworking。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>翻了下Afnetworking的issue，发现了作者对于cookie的解释</p><blockquote><p>Afnetworking没有对Cookie做过处理</p></blockquote><p><img src="/images/2.jpg" alt=""></p><p>使用<code>NSHTTPCookieStorage</code>即可实现cookie的管理。上代码！</p><p><strong>存cookie</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *cookies = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookiesForURL:[NSURL URLWithString:url]];</span><br><span class="line">NSData *data = [NSKeyedArchiver archivedDataWithRootObject:cookies];</span><br><span class="line">NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">[userDefaults setObject:data forKey:@&quot;cookie&quot;];</span><br></pre></td></tr></table></figure><p><strong>设置cookie</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSData *cookiesdata = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;m3cookie&quot;];</span><br><span class="line">    if([cookiesdata length]) &#123;</span><br><span class="line">        NSArray *cookies = [NSKeyedUnarchiver unarchiveObjectWithData:cookiesdata];</span><br><span class="line">        NSHTTPCookie *cookie;</span><br><span class="line">        for (cookie in cookies) &#123;</span><br><span class="line">            [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>清理cookie</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSHTTPCookie *cookie;</span><br><span class="line">NSHTTPCookieStorage *storage = [NSHTTPCookieStorage sharedHTTPCookieStorage];</span><br><span class="line">for (cookie in [storage cookies]) &#123;</span><br><span class="line">    [storage deleteCookie:cookie];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考文章：</p><blockquote><p><a href="https://developer.apple.com/documentation/foundation/nshttpcookiestorage" target="_blank" rel="noopener">NSHTTPCookieStorage官方文档</a><br><a href="https://stackoverflow.com/questions/4597763/persisting-cookies-in-an-ios-application/8713316#8713316" target="_blank" rel="noopener">Persisting Cookies In An iOS Application?</a><br><a href="https://stackoverflow.com/questions/21625313/clear-cookies-for-response-in-afnetworking-2" target="_blank" rel="noopener">Clear cookies for response in AFNetworking 2</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/1.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近有一个需求，需要手动的去缓存cookie，然后启动AP
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>imageNamed与imageWithContentsOfFile小结</title>
    <link href="http://crmo.github.io/2018/03/01/imageNamed%E4%B8%8EimageWithContentsOfFile%E5%B0%8F%E7%BB%93/"/>
    <id>http://crmo.github.io/2018/03/01/imageNamed与imageWithContentsOfFile小结/</id>
    <published>2018-03-01T11:30:00.000Z</published>
    <updated>2018-03-03T10:13:41.036Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/3.jpg" alt=""></p><blockquote><p>本文主要讲imageNamed与imageWithContentsOfFile的差异，需要注意的点，与实战中遇到的坑。</p></blockquote><p>好久没写过博客了，什么工作太忙，加班太晚我就不说了，都怪自己太懒😂，时间都是挤出来的。看着各位大牛写的文章，简直过瘾，希望有一天自己也能写出这么高质量、干货密集的文章，先从简单的做起吧。</p><h2 id="从差异说起"><a href="#从差异说起" class="headerlink" title="从差异说起"></a>从差异说起</h2><p>从磁盘加载图片，UIImage主要提供了两种方式：</p><blockquote><p>+(UIImage <em>)imageNamed:(NSString </em>)name;<br>+(UIImage <em>)imageWithContentsOfFile:(NSString </em>)path;</p></blockquote><p>关于这两种方法的使用时机，苹果官方文档描述如下：</p><blockquote><p>Use the imageNamed:inBundle:compatibleWithTraitCollection: method (or the imageNamed: method) to create an image from an image asset or image file located in your app’s main bundle (or some other known bundle). Because these methods cache the image data automatically, they are especially recommended for images that you use frequently.<br>Use the imageWithContentsOfFile: or initWithContentsOfFile: method to create an image object where the initial data is not in a bundle. These methods load the image data from disk each time, so you should not use them to load the same image repeatedly.</p></blockquote><p>也就是说，<code>imageNamed:</code>第一次加载图片时会缓存图片到内存，适合使用频繁的图片，<code>imageWithContentsOfFile:</code>不会把图片缓存到内存，每次调用都要重新从磁盘加载一次。<br>在实际使用中我们要根据业务来判断调用具体的方法，来最优化内存与性能。举个例子：</p><ol><li>登陆背景图，只会在用户登陆的时候使用，而且图片较大，就建议用<code>imageWithContentsOfFile:</code>加载；</li><li>底导航图标，图标较小，使用频繁，就建议使用<code>imageNamed:</code>加载；</li></ol><blockquote><p><code>imageNamed:</code>方法还有个限制，它是在main bundle里找图片，如果图片放在<code>Images.xcassets</code>或者直接把图片方在工程里，参数直接传图片名可以找到。像我司的图片是放在单独建立的bundle里，如果要用<code>imageNamed:</code>加载的话文件名前面就要加上bundle名，像这样<code>a.bundle/b.png</code>。</p></blockquote><h2 id="屏幕适配问题"><a href="#屏幕适配问题" class="headerlink" title="屏幕适配问题"></a>屏幕适配问题</h2><p>iOS的图片文件需要提供3种尺寸的1x、2x、3x，根据不同的屏幕尺寸我们需要加载不同的图片，关于不同屏幕的图片加载，苹果已经帮我们封装好了，我们只需要将3中尺寸的图片放到工程中，然后调用<code>imageNamed:</code>或者<code>imageWithContentsOfFile:</code>，它会自动根据屏幕尺寸来加载不同的图片。<br>关于<code>imageNamed:</code>，官方文档中有这么一段讨论：</p><blockquote><p>This method looks in the system caches for an image object with the specified name and returns the variant of that image that is best suited for the main screen. </p></blockquote><p><code>imageWithContentsOfFile:</code>还没找到官方文档的说明（如果各位知道，欢迎各位大牛在评论中提出），不过我测试过是可以的。</p><h2 id="使用imageWithContentsOfFile的一个坑"><a href="#使用imageWithContentsOfFile的一个坑" class="headerlink" title="使用imageWithContentsOfFile的一个坑"></a>使用imageWithContentsOfFile的一个坑</h2><p>在使用<code>imageWithContentsOfFile:</code>加载图片的时候遇到一个坑，先上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (UIImage *)imageWithName:(NSString *)name type:(NSString *)type inBundle:(NSString *)bundle &#123;</span><br><span class="line">    NSString *imageBundlePath = [[NSBundle mainBundle] pathForResource:bundle ofType:@&quot;bundle&quot;];</span><br><span class="line">    NSBundle *imageBundle = [NSBundle bundleWithPath:imageBundlePath];</span><br><span class="line">    NSString *imagePath = [imageBundle pathForResource:name ofType:type];</span><br><span class="line">    UIImage *image = [UIImage imageWithContentsOfFile:imagePath];</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的一个函数，就是获取bundle全路径，然后再获取到bundle里图片的全路径，然后调用<code>imageWithContentsOfFile:</code>加载图片。在使用的时候也很正常，但是有一天发现某张图加载不出来了。检查资源文件，只有2x的图（又是一个偷懒的程序员。。。很不建议这么玩，虽然只有2x的图，在所有屏幕都能显示，但是会造成图片的压缩与放大，每个细节都很重要！！！），如果加上1x的图就可以加载出来了。<br>经过调试发现问题就出在<code>pathForResource:ofType</code>上，这个函数是精确匹配调用者输入的文件名，不会自动识别文件名后面的<code>@2x</code>。修改后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (UIImage *)imageWithName:(NSString *)name type:(NSString *)type inBundle:(NSString *)bundle &#123;</span><br><span class="line">    NSString *imageBundlePath = [[NSBundle mainBundle] pathForResource:bundle ofType:@&quot;bundle&quot;];</span><br><span class="line">    NSBundle *imageBundle = [NSBundle bundleWithPath:imageBundlePath];</span><br><span class="line">    NSString *imageFullName = [name stringByAppendingPathExtension:type];</span><br><span class="line">    NSString *imagePath = [[imageBundle resourcePath] stringByAppendingPathComponent:imageFullName];</span><br><span class="line">    UIImage *image = [UIImage imageWithContentsOfFile:imagePath];</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要讲imageNamed与imageWithContentsOfFile的差异，需要注意的点，与实战中遇到的坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好久没
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正则表达式笔记</title>
    <link href="http://crmo.github.io/2016/11/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://crmo.github.io/2016/11/20/正则表达式笔记/</id>
    <published>2016-11-20T15:44:53.000Z</published>
    <updated>2018-03-03T10:12:48.914Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正则表达式（regular expression）描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的字串做替换或者从某个串中取出符合某个条件的字串等。</p></blockquote><p>正则表达式在线测试：<br><a href="http://www.regexpal.com/" target="_blank" rel="noopener">http://www.regexpal.com/</a></p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>常用元字符：</p><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">匹配除换行符以外的任意字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配字母或数字或下划线或汉字</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配数字</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配空格</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配单词的开始或结束</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符串的开始，如果是处理多行，意义变成行开始处</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符串的结束，如果是处理多行，意义变成行结束处</td></tr></tbody></table><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>常用限定符：</p><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">*前面的内容重复任意次</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">+前面的内容重复一次或者多次</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">重复零次或一次</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">重复n次</td></tr><tr><td style="text-align:center">{n, }</td><td style="text-align:center">重复次数大于等于n</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">重复次数大于等于n小于等于m</td></tr></tbody></table><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>[auiou] 匹配任何一个英文元音字母<br>[.?!] 匹配标点符号（.  ?   !）</p><h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">\W</td><td style="text-align:center">匹配任意不是字母、数字、下划线、汉字的字符</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">匹配任意不是空白符的字符</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">匹配任意非数字的字符</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:center">匹配不是单词开头或结束的位置</td></tr><tr><td style="text-align:center">[^x]</td><td style="text-align:center">匹配除了x以外的任意字符</td></tr><tr><td style="text-align:center">[^abcd]</td><td style="text-align:center">匹配除了abcd以外的任意字符</td></tr></tbody></table><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">说明　</th></tr></thead><tbody><tr><td style="text-align:center">(exp)</td><td style="text-align:center">匹配exp，并捕获文本到自动命名组中</td></tr><tr><td style="text-align:center"><code>(?&lt;name&gt;exp)</code></td><td style="text-align:center">匹配exp,并捕获文本到名称为name的组里，也可以写成(?`name`exp)</td></tr><tr><td style="text-align:center">(?:exp)</td><td style="text-align:center">匹配exp，不捕获匹配的文本，也不给次分组分配组号</td></tr><tr><td style="text-align:center">(?=exp)</td><td style="text-align:center">匹配exp前面的位置</td></tr><tr><td style="text-align:center">(?&lt;=exp)</td><td style="text-align:center">匹配exp后面的位置</td></tr><tr><td style="text-align:center">(?!exp)</td><td style="text-align:center">匹配后面跟的不是exp的位置</td></tr><tr><td style="text-align:center">(?&lt;!exp)</td><td style="text-align:center">匹配前面不是exp的位置</td></tr><tr><td style="text-align:center">(?#comment)</td><td style="text-align:center">注释</td></tr></tbody></table><h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>通常重复限定符的行为是<strong>匹配尽可能多</strong>的字符，在限定符后面加<code>?</code>使之成为惰性限定符，例如<code>*?</code>的含义为<strong>重复任意次数，但是尽可能少</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;正则表达式（regular expression）描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的字串做替换或者从某个串中取出符合某个条件的字串等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正则表达式在线测试：&lt;br&gt;&lt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Golang编码规范</title>
    <link href="http://crmo.github.io/2016/11/20/Golang%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://crmo.github.io/2016/11/20/Golang编码规范/</id>
    <published>2016-11-20T14:33:54.000Z</published>
    <updated>2018-03-04T07:54:21.743Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>gofmt</p><p>大部分的格式问题可以通过gofmt解决，gofmt自动格式化代码，保证所有的go代码与官方推荐的格式保持一致，于是所有格式有关问题，都以gofmt的结果为准。</p></li><li><p>行长</p></li></ul><p>一行最长不超过80个字符，超过的使用换行展示，尽量保持格式优雅。</p><ul><li><p>注释</p><p>在编码阶段应该同步写好变量、函数、包的注释，最后可以利用godoc导出文档。注释必须是完整的句子，句子的结尾应该用句号作为结尾（英文句号）。注释推荐用英文，可以在写代码过程中锻炼英文的阅读和书写能力。而且用英文不会出现各种编码的问题。<br>每个包都应该有一个包注释，一个位于package子句之前的块注释或行注释。包如果有多个go文件，只需要出现在一个go文件中即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ping包实现了常用的ping相关的函数</span><br><span class="line">package ping</span><br></pre></td></tr></table></figure></li></ul><p>导出函数注释，第一条语句应该为一条概括语句，并且使用被声明的名字作为开头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 求a和b的和，返回sum。</span><br><span class="line">func Myfunction(sum int) (a, b int) &#123;</span><br></pre></td></tr></table></figure><ul><li><p>命名</p><ul><li>需要注释来补充的命名就不算是好命名。<ul><li>使用可搜索的名称：单字母名称和数字常量很难从一大堆文字中搜索出来。单字母名称仅适用于短方法中的本地变量，名称长短应与其作用域相对应。若变量或常量可能在代码中多处使用，则应赋其以便于搜索的名称。</li><li>做有意义的区分：Product和ProductInfo和ProductData没有区别，NameString和Name没有区别，要区分名称，就要以读者能鉴别不同之处的方式来区分 。</li></ul></li><li>函数命名规则：驼峰式命名，名字可以长但是得把功能，必要的参数描述清楚，函数名名应当是动词或动词短语，如postPayment、deletePage、save。并依Javabean标准加上get、set、is前缀。例如：xxx + With + 需要的参数名 + And + 需要的参数名 + …..</li><li>结构体命名规则：结构体名应该是名词或名词短语，如Custome、WikiPage、Account、AddressParser，避免使用Manager、Processor、Data、Info、这样的类名，类名不应当是动词。<ul><li>包名命名规则：包名应该为小写单词，不要使用下划线或者混合大小写。</li><li>接口命名规则：单个函数的接口名以”er”作为后缀，如Reader,Writer。接口的实现则去掉“er”。</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">        Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个函数的接口名综合两个函数名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type WriteFlusher interface &#123;</span><br><span class="line">    Write([]byte) (int, error)</span><br><span class="line">    Flush() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 三个以上函数的接口名，抽象这个接口的功能，类似于结构体名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Car interface &#123;</span><br><span class="line">    Start([]byte)</span><br><span class="line">    Stop() error</span><br><span class="line">    Recover()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>常量</li></ul><p>常量均需使用全部大写字母组成，并使用下划线分词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const APP_VER = &quot;1.0&quot;</span><br></pre></td></tr></table></figure><p>如果是枚举类型的常量，需要先创建相应类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Scheme string</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    HTTP  Scheme = &quot;http&quot;</span><br><span class="line">    HTTPS Scheme = &quot;https&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果模块的功能较为复杂、常量名称容易混淆的情况下，为了更好地区分枚举类型，可以使用完整的前缀：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type PullRequestStatus int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    PULL_REQUEST_STATUS_CONFLICT PullRequestStatus = iota</span><br><span class="line">    PULL_REQUEST_STATUS_CHECKING</span><br><span class="line">    PULL_REQUEST_STATUS_MERGEABLE</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p>变量</p><p>变量命名基本上遵循相应的英文表达或简写,在相对简单的环境（对象数量少、针对性强）中，可以将一些名称由完整单词简写为单个字母，例如：</p><ul><li>user 可以简写为 u</li><li>userID 可以简写 uid<br>若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头：</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var isExist bool</span><br><span class="line">var hasConflict bool</span><br><span class="line">var canManage bool</span><br><span class="line">var allowGitHook bool</span><br></pre></td></tr></table></figure><ul><li><p>变量命名惯例</p><p>变量名称一般遵循驼峰法，但遇到特有名词时，需要遵循以下规则：</p><ul><li>如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient</li><li>其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID</li><li>错误示例：UrlArray，应该写成urlArray或者URLArray</li></ul><p>下面列举了一些常见的特有名词：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// A GonicMapper that contains a list of common initialisms taken from golang/lint</span><br><span class="line">var LintGonicMapper = GonicMapper&#123;</span><br><span class="line">    &quot;API&quot;:   true,</span><br><span class="line">    &quot;ASCII&quot;: true,</span><br><span class="line">    &quot;CPU&quot;:   true,</span><br><span class="line">    &quot;CSS&quot;:   true,</span><br><span class="line">    &quot;DNS&quot;:   true,</span><br><span class="line">    &quot;EOF&quot;:   true,</span><br><span class="line">    &quot;GUID&quot;:  true,</span><br><span class="line">    &quot;HTML&quot;:  true,</span><br><span class="line">    &quot;HTTP&quot;:  true,</span><br><span class="line">    &quot;HTTPS&quot;: true,</span><br><span class="line">    &quot;ID&quot;:    true,</span><br><span class="line">    &quot;IP&quot;:    true,</span><br><span class="line">    &quot;JSON&quot;:  true,</span><br><span class="line">    &quot;LHS&quot;:   true,</span><br><span class="line">    &quot;QPS&quot;:   true,</span><br><span class="line">    &quot;RAM&quot;:   true,</span><br><span class="line">    &quot;RHS&quot;:   true,</span><br><span class="line">    &quot;RPC&quot;:   true,</span><br><span class="line">    &quot;SLA&quot;:   true,</span><br><span class="line">    &quot;SMTP&quot;:  true,</span><br><span class="line">    &quot;SSH&quot;:   true,</span><br><span class="line">    &quot;TLS&quot;:   true,</span><br><span class="line">    &quot;TTL&quot;:   true,</span><br><span class="line">    &quot;UI&quot;:    true,</span><br><span class="line">    &quot;UID&quot;:   true,</span><br><span class="line">    &quot;UUID&quot;:  true,</span><br><span class="line">    &quot;URI&quot;:   true,</span><br><span class="line">    &quot;URL&quot;:   true,</span><br><span class="line">    &quot;UTF8&quot;:  true,</span><br><span class="line">    &quot;VM&quot;:    true,</span><br><span class="line">    &quot;XML&quot;:   true,</span><br><span class="line">    &quot;XSRF&quot;:  true,</span><br><span class="line">    &quot;XSS&quot;:   true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>struct规范</li></ul><p>struct申明和初始化格式采用多行：</p><p>定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type User struct&#123;</span><br><span class="line">    Username  string</span><br><span class="line">    Email     string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u := User&#123;</span><br><span class="line">    Username: &quot;test&quot;,</span><br><span class="line">    Email:    &quot;test@gmail.com&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>控制结构</p><p>if<br>if接受初始化语句，约定如下方式建立局部变量</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if err := file.Chmod(0664); err != nil &#123;</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> for<br>采用短声明建立局部变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := 0</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> return<br>尽早return：一旦有错误发生，马上返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line">d, err := f.Stat()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    f.Close()</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line">codeUsing(f, d)</span><br></pre></td></tr></table></figure><ul><li><p>错误处理</p><ul><li>error作为函数的值返回,必须对error进行处理</li><li>错误描述如果是英文必须为小写，不需要标点结尾</li><li>采用独立的错误流进行处理</li></ul><p>不要采用下面的处理错误写法</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if err != nil &#123;</span><br><span class="line">    // error handling</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // normal code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 采用下面的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if err != nil &#123;</span><br><span class="line">    // error handling</span><br><span class="line">    return // or continue, etc.</span><br><span class="line">&#125;</span><br><span class="line">// normal code</span><br></pre></td></tr></table></figure><p> 使用函数的返回值时，则采用下面的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x, err := f()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    // error handling</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">// use x</span><br></pre></td></tr></table></figure><ul><li>panic</li></ul><p>尽量不要使用panic，除非你知道你在做什么</p><ul><li>import</li></ul><p>对import的包进行分组管理，用换行符分割，而且标准库作为分组的第一组。如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line"></span><br><span class="line">    &quot;kmg/a&quot;</span><br><span class="line">    &quot;kmg/b&quot;</span><br><span class="line"></span><br><span class="line">    &quot;code.google.com/a&quot;</span><br><span class="line">    &quot;github.com/b&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> 在项目中不要使用相对路径引入包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误示例</span><br><span class="line">import “../net”</span><br><span class="line"></span><br><span class="line">// 正确的做法</span><br><span class="line">import “github.com/repo/proj/src/net”</span><br></pre></td></tr></table></figure><p>goimports会自动帮你格式化</p><ul><li><p>参数传递</p><ul><li>对于少量数据，不要传递指针</li><li>对于大量数据的struct可以考虑使用指针</li><li>传入参数是map，slice，chan不要传递指针，因为map，slice，chan是引用类型，不需要传递指针的指针</li></ul></li><li><p>单元测试</p></li></ul><p>单元测试文件名命名规范为 example_test.go<br>测试用例的函数名称必须以 Test 开头，例如：TestExample</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;gofmt&lt;/p&gt;
&lt;p&gt;大部分的格式问题可以通过gofmt解决，gofmt自动格式化代码，保证所有的go代码与官方推荐的格式保持一致，于是所有格式有关问题，都以gofmt的结果为准。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行长&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
