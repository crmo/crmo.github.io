<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CR.MO`s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://crmo.github.io/"/>
  <updated>2018-10-15T00:58:35.183Z</updated>
  <id>https://crmo.github.io/</id>
  
  <author>
    <name>CR.MO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>应对苹果隐私政策看我就够了</title>
    <link href="https://crmo.github.io/2018/10/13/%E5%BA%94%E5%AF%B9%E8%8B%B9%E6%9E%9C%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>https://crmo.github.io/2018/10/13/应对苹果隐私政策看我就够了/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2018-10-15T00:58:35.183Z</updated>
    
    <content type="html"><![CDATA[<p>国庆假期回来准备提交新版本到App Store，遇到苹果新政策，实测下来影响不大，应对还算比较简单，总结一下分享给大家。</p><h2 id="政策说明"><a href="#政策说明" class="headerlink" title="政策说明"></a>政策说明</h2><p><img src="/images/QQ20181012-090233.png" alt="QQ20181012-090233"></p><p>从2018年10月3号起，所有新提交的App都必须提供隐私条例，<a href="https://developer.apple.com/news/?id=08312018a" target="_blank" rel="noopener">官方连接</a>。</p><p>对于隐私条例，苹果审核条例是这么说明的。</p><p><img src="/images/QQ20181012-085839.png" alt="QQ20181012-085839"></p><p>需要在两个地方提供隐私条例：</p><ol><li>元数据</li><li>应用内有明显的入口</li></ol><h2 id="生成隐私条例"><a href="#生成隐私条例" class="headerlink" title="生成隐私条例"></a>生成隐私条例</h2><p>关于隐私条例，网上有各种模板，弄一个改改就行了，这里推荐一个<a href="https://www.freeprivacypolicy.com" target="_blank" rel="noopener">自动生成的网站</a>。<br>免费生成，还提供一个链接，挂在它们网站，就不用自己搞服务器了。例如<a href="https://www.freeprivacypolicy.com/privacy/view/cb2289ee81ec0d2f61ec1790bccf861d" target="_blank" rel="noopener">我给App生成的隐私条例</a></p><p><img src="/images/QQ20181012-090746.png" alt="QQ20181012-090746"></p><h2 id="集成隐私条例"><a href="#集成隐私条例" class="headerlink" title="集成隐私条例"></a>集成隐私条例</h2><p>第一步：把刚刚生成的URL填在元数据里</p><p><img src="/images/QQ20181012-091050.png" alt="QQ20181012-091050"></p><p>第二步：在应用内加一个页面，开一个WebView加载刚刚生成的URL，例如我就放在了“关于-隐私条例”</p><p>第三步：提交审核时，在备注里面说明，隐私条例的入口在哪里。（这一步可能不要也行，不过为了稳妥我加上了，给苹果审核团队讲清楚总是好的）</p><p>第二天就上架成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;国庆假期回来准备提交新版本到App Store，遇到苹果新政策，实测下来影响不大，应对还算比较简单，总结一下分享给大家。&lt;/p&gt;
&lt;h2 id=&quot;政策说明&quot;&gt;&lt;a href=&quot;#政策说明&quot; class=&quot;headerlink&quot; title=&quot;政策说明&quot;&gt;&lt;/a&gt;政策说明&lt;/
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>记“香蕉播放器”上架的辛酸历程</title>
    <link href="https://crmo.github.io/2018/10/07/%E8%AE%B0%E2%80%9C%E9%A6%99%E8%95%89%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%9D%E4%B8%8A%E6%9E%B6%E7%9A%84%E8%BE%9B%E9%85%B8%E5%8E%86%E7%A8%8B/"/>
    <id>https://crmo.github.io/2018/10/07/记“香蕉播放器”上架的辛酸历程/</id>
    <published>2018-10-06T16:00:00.000Z</published>
    <updated>2018-10-07T08:50:30.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>先说点废话，从事iOS开发以来，一直有一个目标，拥有一个自己的APP上架App Store，并且登上苹果推荐榜单，这可能是大多数iOSer的梦想。在脑子里产生了各种想法，但是发现自己能想到的别人都做了，并且做的很好，加上工作生活上的很多事情（主要是懒😝），一拖就是3年。<br>后来因为自己的真实需求，App Store找不到能满足需求的产品，就做了一个播放器自己用，在中秋假期狠下心来，买了开发者账号（688，心痛！！就当为了梦想充值吧。），把这个播放器上架了。</p><h2 id="购买开发者账号"><a href="#购买开发者账号" class="headerlink" title="购买开发者账号"></a>购买开发者账号</h2><p>关于怎么买个人开发者账号，网上的教程一抓一大把，整个购买流程也没啥好注意的，根据提示一步一步走就OK了。但是到了最后付款环节把我卡了一周（办了两张信用卡。。。），必须要<code>visa+银联</code>双标的信用卡，注意一定要双标，只有visa或者只有银联都不行。<br>付了款一天左右苹果就会发来邮件，提供身份证正反面照片就可以了。</p><h2 id="上架App-Store"><a href="#上架App-Store" class="headerlink" title="上架App Store"></a>上架App Store</h2><p>上架流程就轻车熟路了，打包上传、填写各种APP说明、上传图标、宣传图、提交审核。激动的我一晚上没睡好觉，第二天早上打开邮箱，等待我的居然是<code>2.1大礼包</code>（Guideline 2.1 - Information Needed）。</p><p><img src="/images/WechatIMG59.png" alt="WechatIMG59"></p><p>一看我就懵逼了，上架这么多次第一次遇到这么严厉的回复，感觉分分钟要被封号。经过多方咨询，发现这是苹果今年新推出的大礼包，很多人都遇到过，一般是机器审核回复的，遇到这种情况别慌（除非你是马甲包、或者抄袭的之类的APP），仔细检查条例，然后逐条答复（最好用英文）。<br>最后我还录制了一个视频，来演示我的APP的主要功能，上传到<code>youtube</code>，附在了备注。<br>分享下我的答复模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">尊敬的苹果审核团队：</span><br><span class="line">    感谢您的耐心审核，针对下面问题，我们做了详细的检查</span><br><span class="line">    </span><br><span class="line">关于 Guideline 2.1</span><br><span class="line"></span><br><span class="line">1.1.6 - “香蕉播放器”没有包含任何的虚假与误导信息，全部都是真实有效的</span><br><span class="line">2.3.0 - “香蕉播放器”没有在通过审核后修改任何概念和功能</span><br><span class="line">2.3.1 - “香蕉播放器”没有包含任何隐藏功能，没有包含赌博、彩票网站</span><br><span class="line">3.1.1 - “香蕉播放器”内没有任何内购、支付功能，所有功能都是免费提供给用户</span><br><span class="line">3.2.1 - “香蕉播放器”内部包含任何贷款等金融服务</span><br><span class="line">4.3.0 - “香蕉播放器”功能都是独立开发，不存在抄袭或者大量相似</span><br><span class="line">5.2.1 - “香蕉播放器”没有法人实体和版权风险</span><br><span class="line">5.2.3 - “香蕉播放器”没有提供文件共享服务，或者其它存在版权问题的音视频</span><br><span class="line">5.3.4 - “香蕉播放器”仅在中国区上架，没有违规内容</span><br><span class="line"></span><br><span class="line">关于 Guideline 2.3.7</span><br><span class="line"></span><br><span class="line">我已经按照说明，修改了元数据，请审核团队再次审核。</span><br><span class="line"></span><br><span class="line">最后再次感谢您辛苦的审核。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dear Apple Review Team:</span><br><span class="line">    Thank you for your patience review, we have done a detailed check on the following questions.</span><br><span class="line">    </span><br><span class="line">About Guideline 2.1</span><br><span class="line"></span><br><span class="line">1.1.6 - &quot;Banana Player&quot; does not contain any false and misleading information, all of which are true and effective</span><br><span class="line">2.3.0 - &quot;Banana Player&quot; does not modify any concepts and features after passing the review</span><br><span class="line">2.3.1 - &quot;Banana Player&quot; does not contain any hidden features, does not contain gambling, lottery sites</span><br><span class="line">3.1.1 - There is no in-app purchase and payment function in the “Banana Player”, all functions are provided to the user free of charge.</span><br><span class="line">3.2.1 - &quot;Banana Player&quot; contains any financial services such as loans</span><br><span class="line">4.3.0 - The &quot;Banana Player&quot; feature is developed independently, without plagiarism or a lot of similarity</span><br><span class="line">5.2.1 - &quot;Banana Player&quot; has no legal entity and copyright risk</span><br><span class="line">5.2.3 - &quot;Banana Player&quot; does not provide file sharing services, or other audio and video with copyright issues</span><br><span class="line">5.3.4 - &quot;Banana Player&quot; is only available in China, no illegal content</span><br><span class="line"></span><br><span class="line">About Guideline 2.3.7</span><br><span class="line"></span><br><span class="line">I have modified the metadata according to the instructions, please review the team again.</span><br><span class="line"></span><br><span class="line">Finally, thank you again for your hard review.</span><br></pre></td></tr></table></figure><p>第二天审核通过，成功上架！</p><h2 id="打个广告"><a href="#打个广告" class="headerlink" title="打个广告"></a>打个广告</h2><blockquote><p>下载🔗：<a href="https://dwz.cn/HvVix2hH" target="_blank" rel="noopener">https://dwz.cn/HvVix2hH</a></p></blockquote><p>“香蕉播放器”是我独立开发的第一款APP，免费无广告。主要功能在手机上播放从网盘、光盘、网站下载的音频资料、课程、音乐。无需数据线，用Wi-Fi就可以拷贝文件到手机，自动记录播放进度。<br>如果有需求可以支持一波，有什么问题欢迎联系我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;先说点废话，从事iOS开发以来，一直有一个目标，拥有一个自己的APP上架App Store，并且登上苹果推荐榜单，这可能是大
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>记一个行结束符引发的JS报错</title>
    <link href="https://crmo.github.io/2018/09/05/%E8%AE%B0%E4%B8%80%E4%B8%AA%E8%A1%8C%E7%BB%93%E6%9D%9F%E7%AC%A6%E5%BC%95%E5%8F%91%E7%9A%84JS%E6%8A%A5%E9%94%99/"/>
    <id>https://crmo.github.io/2018/09/05/记一个行结束符引发的JS报错/</id>
    <published>2018-09-04T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近遇到一个神奇的Bug，通过<code>UIWebView</code>的<code>stringByEvaluatingJavaScriptFromString:</code>方法执行一段<code>JavaScript</code>代码时，<code>JavaScript</code>报错:</p><blockquote><p>SyntaxError: Unexpected EOF</p></blockquote><p>经过仔细的排查，发现待执行的<code>JavaScript</code>代码里面包含<code>U+2028</code>字符。还找到了<a href="https://stackoverflow.com/questions/2965293/javascript-parse-error-on-u2028-unicode-character" target="_blank" rel="noopener">Stack Overflow相关讨论</a>。<br><code>JavaScript</code>解析器会把行分隔符<code>U+2028</code>和段落分隔符<code>U+2029</code>解析成一行的结束，代码里要是包含这两个字符相当于换行，例如：</p><blockquote><p>alert(“\u2028”)</p></blockquote><p>就会被解析为</p><blockquote><p>alert(“<br>“)</p></blockquote><p>于是就产生了语法错误。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我用的方法比较简单、粗暴，在执行<code>JavaScript</code>代码前，直接过滤掉这两个字符。代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line">    javaScriptString = [javaScriptString stringByReplacingOccurrencesOfString:<span class="string">@"\u2028"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    javaScriptString = [javaScriptString stringByReplacingOccurrencesOfString:<span class="string">@"\u2029"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    <span class="built_in">NSString</span>* ret = [(<span class="built_in">UIWebView</span>*)_engineWebView stringByEvaluatingJavaScriptFromString:javaScriptString];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最近遇到一个神奇的Bug，通过&lt;code&gt;UIWebView&lt;/code&gt;的&lt;code&gt;stringByEvaluating
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>从一个AFNetworking循环引用说起</title>
    <link href="https://crmo.github.io/2018/08/28/%E4%BB%8E%E4%B8%80%E4%B8%AAAFNetworking%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E8%AF%B4%E8%B5%B7/"/>
    <id>https://crmo.github.io/2018/08/28/从一个AFNetworking循环引用说起/</id>
    <published>2018-08-27T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文分析使用代码是<a href="https://github.com/AFNetworking/AFNetworking/releases" target="_blank" rel="noopener">AFNetworking 3.2.1</a></p></blockquote><p>最近使用<code>Instruments</code>中的<code>Leaks</code>分析项目内存泄露，发现了一个AFNetworking的循环引用。如下图所示：</p><p><img src="/images/15354171666142.jpg" alt="15354171666142"></p><p>通过调用栈发现产生泄露的代码在这里：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AFURLSessionManager.m</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="comment">// ... 初始化代码，省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导致循环引用的方法</span></span><br><span class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其它初始化代码，省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致原因就是AFURLSessionManager引用NSURLSession，同时设置NSURLSession的delegate为自己，NSURLSession会强引用delegate，于是产生了循环引用。</p><blockquote><p>关于NSURLSession的delegate官方说明：<br>This delegate object is responsible for handling authentication challenges, for making caching decisions, and for handling other session-related events. The session object keeps a strong reference to this delegate until your app exits or explicitly invalidates the session. If you do not invalidate the session, your app leaks memory until it exits.</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在AFNetworking官方issues找到了相关的问题<a href="https://github.com/AFNetworking/AFNetworking/issues/1528" target="_blank" rel="noopener">Possible memory leak in AFURLSessionManager</a>。作者的回答如下：</p><p><img src="/images/15353328585634.jpg" alt="15353328585634"></p><p>解决方案有两种：</p><ol><li>这是最常见也是作者推荐的方法，只创建一个AFURLSessionManager，整个APP共享，虽然还是有循环引用，但是就没有内存泄露的问题了。</li><li>如果要使用多个AFURLSessionManager，在使用完成后手动调用<code>invalidateSessionCancelingTasks:</code>来断开循环引用。（这种方案不推荐，具体原因看下一小节）</li></ol><h2 id="AFURLSessionManager复用"><a href="#AFURLSessionManager复用" class="headerlink" title="AFURLSessionManager复用"></a>AFURLSessionManager复用</h2><p>关于AFURLSessionManager是否使用单例这个问题，官方demo使用的是单例，在苹果官方文档找到这么一段话</p><blockquote><p>With the NSURLSession API, your app creates one or more sessions, each of which coordinates a group of related data transfer tasks. For example, if you’re creating a web browser, your app might create one session per tab or window, or one session for interactive use and another for background downloads. Within each session, your app adds a series of tasks, each of which represents a request for a specific URL (following HTTP redirects, if necessary).</p></blockquote><p>我的理解是这样的，根据使用场景的不同，这个问题有不同的答案，在大多数场景下APP都是在和同一服务器打交道，一个<code>session</code>就够了，如果有连接多个服务器、或者后台下载等功能需求，可以给每个服务器、后台下载任务创建单独的<code>session</code>（但是也不能每个请求都单独创建session）。</p><p>在查找资料的时候，我发现有博客提到单例seesion可以减少TCP三次握手，动手验证下：</p><p>多个网络请求复用一个<code>AFURLSessionManager</code>，连续发两个网络请求，用<code>Wireshark</code>抓包可以看到，第二次网络请求复用了第一次的TCP连接，没有做三次握手。</p><p><img src="/images/15354191775340.jpg" alt="15354191775340"></p><p>下图是每次网络请求都新建一个<code>AFURLSessionManager</code>的抓包，可以看到每个网络请求都进行了TCP三次握手。</p><p><img src="/images/15354193039698.jpg" alt="15354193039698"></p><p>实验结果的确如网上所说，复用<code>AFURLSessionManager</code>可以减少三次握手，提升效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文分析使用代码是&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AFNetworking 3.2.1&lt;/
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS模拟器安装debug包</title>
    <link href="https://crmo.github.io/2018/08/21/iOS%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AE%89%E8%A3%85debug%E5%8C%85/"/>
    <id>https://crmo.github.io/2018/08/21/iOS模拟器安装debug包/</id>
    <published>2018-08-20T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.803Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目是Hybrid的平台，有第三方人员需要在上面开发H5应用，但是release包不能调试H5，只有debug报可以调试，但是项目源码不能交给第三方，在google搜索了下，发现一篇霜神的<a href="https://juejin.im/post/57b01f298ac247005f0acb0a" target="_blank" rel="noopener">文章</a>，讲的是debug包可以拷贝到其它机器运行，于是实践了一波。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>Xcode</li><li>Command Line Tools</li><li>ios-sim</li></ul><blockquote><p>ios-sim安装命令：npm install ios-sim -g</p></blockquote><h2 id="拷贝本地的debug包"><a href="#拷贝本地的debug包" class="headerlink" title="拷贝本地的debug包"></a>拷贝本地的debug包</h2><ol><li>run一次需要拷贝的项目，安装到模拟器上</li></ol><ol><li>执行下面命令行，需要注意的是<code>目标路径/xxx.zip</code>就是拷贝出来的debug应用包，需要替换为自己的路径，例如<code>/Users/crmo/Desktop/debug/debug.zip</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ditto -ck --sequesterRsrc --keepParent `ls -1 -d -t ~/Library/Developer/Xcode/DerivedData/*/Build/Products/*-iphonesimulator/*.app | head -n 1` 目标路径/xxx.zip</span><br></pre></td></tr></table></figure><h2 id="拷贝debug包到其它模拟器"><a href="#拷贝debug包到其它模拟器" class="headerlink" title="拷贝debug包到其它模拟器"></a>拷贝debug包到其它模拟器</h2><h3 id="1-获取模拟器列表"><a href="#1-获取模拟器列表" class="headerlink" title="1. 获取模拟器列表"></a>1. 获取模拟器列表</h3><blockquote><p>ios-sim showdevicetypes</p></blockquote><p>可以看到类似于下面的输出，就是本机可用的模拟器，选择一个需要运行的模拟器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">~ ios-sim showdevicetypes</span><br><span class="line">Apple-Watch-38mm, watchOS 4.3</span><br><span class="line">Apple-Watch-42mm, watchOS 4.3</span><br><span class="line">Apple-Watch-Series-2-38mm, watchOS 4.3</span><br><span class="line">Apple-Watch-Series-2-42mm, watchOS 4.3</span><br><span class="line">iPhone-7-Plus, 10.3</span><br><span class="line">iPhone-7-Plus, 11.4</span><br><span class="line">Apple-Watch-Series-3-38mm, watchOS 4.3</span><br><span class="line">Apple-Watch-Series-3-42mm, watchOS 4.3</span><br><span class="line">iPhone-5s, 11.4</span><br><span class="line">iPhone-6, 11.4</span><br><span class="line">iPhone-6-Plus, 11.4</span><br><span class="line">iPhone-6s, 11.4</span><br><span class="line">iPhone-6s-Plus, 11.4</span><br><span class="line">iPhone-7, 11.4</span><br><span class="line">iPhone-SE, 11.4</span><br><span class="line">iPad-Air, 11.4</span><br><span class="line">iPad-Air-2, 11.4</span><br><span class="line">iPhone-8, 11.4</span><br><span class="line">iPhone-8-Plus, 11.4</span><br><span class="line">iPhone-X, 11.4</span><br></pre></td></tr></table></figure><h3 id="2-在模拟器上启动debug包"><a href="#2-在模拟器上启动debug包" class="headerlink" title="2. 在模拟器上启动debug包"></a>2. 在模拟器上启动debug包</h3><blockquote><p>ios-sim launch 应用包路径/xxx.app –devicetypeid 模拟器</p></blockquote><p>需要说明的是，debug.zip解压后就可以得到对应应用的.app文件，例如我的debug包放在<code>/Users/crmo/Desktop/debug/debug.app</code>，模拟器选择iPhone-8，最终的命令是</p><blockquote><p>ios-sim launch /Users/crmo/Desktop/debug/debug.app –devicetypeid iPhone-8</p></blockquote><h2 id="simctl-was-not-found错误解决"><a href="#simctl-was-not-found错误解决" class="headerlink" title="simctl was not found错误解决"></a>simctl was not found错误解决</h2><p>在实践时测试机的<code>Command Line Tools</code>没有配置好，出现报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">simctl was not found.</span><br><span class="line">Check that you have Xcode 8.x installed:</span><br><span class="line">xcodebuild --versionCheck that you have Xcode 8.x selected:</span><br><span class="line">xcode-select --print-path</span><br></pre></td></tr></table></figure><p><strong>解决办法：</strong></p><p>1.首先确保正确安装了Command Line Tools，</p><blockquote><p>卸载Command Line Tools:rm -rf /Library/Developer/CommandLineTools<br>安装Command Line Tools:xcode-select –install</p></blockquote><p>2.在xcode配置一下Command Line Tools，如下图所示</p><p><img src="/images/15348328228775.jpg" alt="15348328228775"></p><hr><p>参考博客：</p><ul><li><a href="http://www.hudongdong.com/bug/772.html" target="_blank" rel="noopener">unable to find utility “simctl”的解决方案</a></li><li><a href="https://juejin.im/post/57b01f298ac247005f0acb0a" target="_blank" rel="noopener">给 iOS 模拟器 “安装”app 文件</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于项目是Hybrid的平台，有第三方人员需要在上面开发H5应用，但是release包不能调试H5，只有debug报可以调试，但是项目源码不能交给第三方，在google搜索了下，发现一篇霜神的&lt;a href=&quot;https://juejin.im/post/57b01f298
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>dispatch_sync死锁问题</title>
    <link href="https://crmo.github.io/2018/08/03/dispatch_sync%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <id>https://crmo.github.io/2018/08/03/dispatch_sync死锁问题/</id>
    <published>2018-08-02T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>使用<code>dispatch_sync</code>的时候要小心谨慎，稍不注意就会导致死锁问题，先看两个典型的案例：</p><p>案例一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)deadlock1 &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)deadlock2 &#123;</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_sync(queue1, ^&#123;</span><br><span class="line">        dispatch_sync(queue2, ^&#123;</span><br><span class="line">            dispatch_sync(queue1, ^&#123;</span><br><span class="line">                NSLog(@&quot;&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个案例死锁的原因都是同一个串行队列的任务相互等待。 当然实际工程中遇到的死锁问题会更加复杂，难以分析。</p><h2 id="典型误区"><a href="#典型误区" class="headerlink" title="典型误区"></a>典型误区</h2><p>在阅读相关书籍、博客都提到了一个方法<code>dispatch_get_current_queue()</code>，通过这个方法可以获取到当前队列，于是有人就用它来解决死锁问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)safeSync:(void(^)())block &#123;</span><br><span class="line">    if (!block) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dispatch_get_current_queue() == queue) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            block();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一眼看起来天衣无缝，对于案例一的确可以完美解决，但是对于案例二这种对队列的情况就判断不了。难怪苹果在iOS6就注释了这个方法。</p><hr><p>推荐阅读：</p><p><a href="https://www.objc.io/issues/2-concurrency/thread-safe-class-design/#pitfalls-of-gcd" target="_blank" rel="noopener">Thread-Safe Class Design</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;dispatch_sync&lt;/code&gt;的时候要小心谨慎，稍不注意就会导致死锁问题，先看两个典型的案例：&lt;/
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UIWebView获取详细浏览记录</title>
    <link href="https://crmo.github.io/2018/08/01/UIWebView%E8%8E%B7%E5%8F%96history/"/>
    <id>https://crmo.github.io/2018/08/01/UIWebView获取history/</id>
    <published>2018-07-31T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.824Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所用方法会使用到苹果私有API，上架APP Store请谨慎使用。</p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>获取<code>UIWebView</code>的前进后退的浏览记录，举个例子，比如从A-&gt;B-&gt;C-&gt;B，此时B上一页是A，下一页是C，需要获取A、C的URL信息。</p><blockquote><p>WKWebView暴露了这个属性，<code>WKBackForwardList *backForwardList</code>。可以很容易的取到，无奈项目还是使用的<code>UIWebView</code>，于是有了后面的探索。</p></blockquote><p>首先在<code>UIWebView</code>提供的API里找，相关的API只有<code>canGoBack</code>和<code>canGoForward</code>，命名很直观，是否可以后退和前进，这条路走不通。<br>想到是否可以通过JS的Window.history获取到，查了下API，唯一一个有点像的<code>length</code>属性，智能取到浏览记录中的所有URL的数量，不区分前后，比如在上面提到的例子中，在B页面取到的<code>length</code>是3，而且不能取出具体的URL。</p><p><img src="/images/15325235986699.jpg" alt="15325235986699"></p><p>无奈只有上源码了，我下载的是<a href="https://opensource.apple.com/release/ios-110.html" target="_blank" rel="noopener">“WebKit-7604.1.38.0.7”和“WebCore-7604.1.38.0.7”</a>。</p><h2 id="Window-History-length实现本质"><a href="#Window-History-length实现本质" class="headerlink" title="Window.History.length实现本质"></a>Window.History.length实现本质</h2><p>在WebCore里面找到了JS方法<code>Window.History.length</code>实现的本质，上代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebCore History.cpp</span></span><br><span class="line"><span class="keyword">unsigned</span> History::length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_frame)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span>* page = m_frame-&gt;page();</span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> page-&gt;backForward().count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebCore BackForwardController.cpp</span></span><br><span class="line"><span class="keyword">int</span> BackForwardController::count() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// count = 当前页之前的页面总数 + 当前页之后的页面总数 + 1</span></span><br><span class="line">    <span class="keyword">return</span> m_client-&gt;backListCount() + <span class="number">1</span> + m_client-&gt;forwardListCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>WebCore</code>里面<code>backListCount()</code>、<code>forwardListCount()</code>定义是虚函数，具体实现在<code>WebKit</code>可以找到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebKit BackForwardList.mm</span></span><br><span class="line"><span class="keyword">int</span> BackForwardList::backListCount()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_current == NoCurrentItemIndex ? <span class="number">0</span> : m_current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BackForwardList::forwardListCount()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_current == NoCurrentItemIndex ? <span class="number">0</span> : (<span class="keyword">int</span>)m_entries.size() - (m_current + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个方法我们需要关注一下，后面会用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebKit BackForwardList.mm</span></span><br><span class="line"><span class="comment">// 获取之前最多几条历史记录</span></span><br><span class="line"><span class="keyword">void</span> BackForwardList::backListWithLimit(<span class="keyword">int</span> limit, Vector&lt;Ref&lt;HistoryItem&gt;&gt;&amp; <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span>.clear();</span><br><span class="line">    <span class="keyword">if</span> (m_current != NoCurrentItemIndex) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> first = <span class="built_in">std</span>::max(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(m_current) - limit, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (; first &lt; m_current; ++first)</span><br><span class="line">            <span class="built_in">list</span>.append(m_entries[first].get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取History"><a href="#获取History" class="headerlink" title="获取History"></a>获取History</h2><p>在<code>WebView</code>的中，我们可以找到<code>WebBackForwardList</code>的定义。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    @property backForwardList</span></span><br><span class="line"><span class="comment">    @abstract The backforward list for this WebView.</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) WebBackForwardList *backForwardList;</span><br></pre></td></tr></table></figure><p><code>WebBackForwardList</code>是对<code>BackForwardList</code>的一层封装，阅读一下它的.h文件，不难找到获取浏览记录的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">    @method backListWithLimit:</span><br><span class="line">    @abstract Returns a portion of the list before the current entry.</span><br><span class="line">    @param limit A cap on the size of the array returned.</span><br><span class="line">    @result An array of items before the current entry, or nil if there are none.  The entries are in the order that they were originally visited.</span><br><span class="line">*/</span><br><span class="line">- (NSArray *)backListWithLimit:(int)limit;</span><br></pre></td></tr></table></figure><p>上面的方法可以获取到一个<code>WebHistoryItem</code>数组，<code>WebHistoryItem</code>保存了浏览记录的详细信息。</p><h2 id="获取WebBackForwardList"><a href="#获取WebBackForwardList" class="headerlink" title="获取WebBackForwardList"></a>获取WebBackForwardList</h2><p><code>UIWebView</code>没有暴露获取<code>WebView</code>或者<code>WebBackForwardList</code>的方法，但是我们可以用KVO曲线救国，于是我们需要找到<code>WebView</code>的私有变量名。用runtime可以做到，为了简化这个过程，我写了一个工具类来辅助搜索，具体可以看<a href="https://crmo.github.io/2018/07/31/runtime实现私有变量搜索/">这篇文章-runtime实现私有变量搜索</a>。简单来说就是用runtime获取类成员变量列表，然后用BFS来搜索我们要找的类。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以UIWebView为根节点，BFS搜索WebView</span></span><br><span class="line">[BFSSearchClass searchClass:<span class="string">@"WebView"</span> inClass:<span class="string">@"UIWebView"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索结果如下</span></span><br><span class="line"><span class="comment">// Class Name：类名，Ivar Name：变量名，Super Class：父类</span></span><br><span class="line">Class Name:【WebView】,Ivar Name:【_webView】</span><br><span class="line">Class Name:【<span class="built_in">UIWebDocumentView</span>】,Ivar Name:【Super Class】</span><br><span class="line">Class Name:【<span class="built_in">UIWebBrowserView</span>】,Ivar Name:【browserView】</span><br><span class="line">Class Name:【<span class="built_in">UIWebViewInternal</span>】,Ivar Name:【_internal】</span><br><span class="line">Root Class:<span class="built_in">UIWebView</span></span><br></pre></td></tr></table></figure><p>有了上面的结论，我们就可以用KVC来获取到浏览记录了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printWebViewHistory:(<span class="built_in">UIWebView</span> *)aWebView &#123;</span><br><span class="line">    <span class="keyword">id</span> webviewInternal = [aWebView valueForKey:<span class="string">@"_internal"</span>];</span><br><span class="line">    <span class="keyword">id</span> browserView = [webviewInternal valueForKey:<span class="string">@"browserView"</span>];</span><br><span class="line">    <span class="keyword">id</span> webView = [browserView valueForKey:<span class="string">@"_webView"</span>];</span><br><span class="line">    <span class="keyword">id</span> backForwardList = [webView performSelector:<span class="keyword">@selector</span>(backForwardList)];</span><br><span class="line">    <span class="comment">// WebHistoryItem存储的具体某条浏览记录信息</span></span><br><span class="line">    <span class="built_in">NSArray</span> *historyItems = [backForwardList performSelector:<span class="keyword">@selector</span>(backListWithLimit:) withObject:@<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> item <span class="keyword">in</span> historyItems) &#123;</span><br><span class="line">        <span class="comment">// 获取浏览记录的url </span></span><br><span class="line">        <span class="built_in">NSString</span> *url = [item performSelector:<span class="keyword">@selector</span>(URLString)];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文所用方法会使用到苹果私有API，上架APP Store请谨慎使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>runtime实现私有变量搜索</title>
    <link href="https://crmo.github.io/2018/07/31/runtime%E5%AE%9E%E7%8E%B0%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E6%90%9C%E7%B4%A2/"/>
    <id>https://crmo.github.io/2018/07/31/runtime实现私有变量搜索/</id>
    <published>2018-07-30T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.834Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文Demo(<a href="https://github.com/crmo/BFSSearchClass)地址" target="_blank" rel="noopener">https://github.com/crmo/BFSSearchClass)地址</a></p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在开发功能时，为了满足产品变态的需求，难免有系统类提供的API不够用的时候，这时候私有变量就可以发挥它光和热了。怎么通过一个类，一层一层的找到特定类型的私有成员变量？<br>受益于Objective-C的动态语言特性，就算苹果<code>UIKit</code>不开源，但是在runtime面前，类的结构还是暴露无遗。我的思路是逐层手动打印成员变量信息，如果是UI控件可以用Reveal来加快进度，配合KVC机制，获取私有变量就如同探囊取物一般。<br>在多次遇到这个问题后，我决定实现一个工具类来简化这个过程，毕竟能自动化的就尽量不要手动。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>搜索范围：成员变量、属性</p></blockquote><p>关键步骤如下：</p><ol><li>runtime中的方法<code>class_copyIvarList()</code>，可以取出类的所有成员变量结构体<code>Ivar</code>。</li><li>从Ivar中可以取出成员变量类型<code>Type Encodings</code></li><li>用<code>Type Encodings</code>获取到类名</li><li>遍历类的所有<code>Ivar</code>，获取到类的所有成员变量的类信息</li></ol><p>但是问题没这么简单，比如ClassA是ClassB的成员变量，ClassB是ClassC的成员变量，想通过ClassC找到ClassA，需要向下找两层才能找到，还要考虑父类的情况。<br>整个搜索过程就是一颗以待搜索类为根的树，可以用BFS来搜索，步骤如下（如图，数字是搜索顺序）：</p><ol><li>从根节点开始搜索</li><li>首先遍历当前节点的父类，加入搜索队列</li><li>再取出当前节点的所有成员变量，加入搜索队列</li></ol><p><img src="/images/QQ20180731-202956@2x.png" alt="QQ20180731-202956@2x"></p><h2 id="如何从Ivar中获取Class"><a href="#如何从Ivar中获取Class" class="headerlink" title="如何从Ivar中获取Class"></a>如何从Ivar中获取Class</h2><p>Ivar中不能直接取出对应类名，只能取出<code>Type Encodings</code>，间接可以得到类名。从<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">官方文档</a>截了张图，可以清晰的看到Code的定义。</p><p><img src="/images/15329163411347.jpg" alt="15329163411347"></p><p>基本数据类型、id类型、集合类型、结构体等类型就不需要搜索了，可以过滤掉。我们只搜索两种类型</p><ol><li>类，例如<code>@&quot;UIWebViewInternal&quot;</code></li><li>代理，例如<code>@&quot;&lt;UIViewControllerTransitioningDelegate&gt;&quot;</code></li></ol><h2 id="优化及存在问题"><a href="#优化及存在问题" class="headerlink" title="优化及存在问题"></a>优化及存在问题</h2><ol><li>可以用一个<code>NSMutableSet</code>存储已经搜索过的类，每次搜索前判断一下是否已经搜索过</li><li>记录搜索次数，可以限制搜索次数。</li><li>对于定义为id类型、集合类的成员变量没有做处理，可以继续深入遍历</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文Demo(&lt;a href=&quot;https://github.com/crmo/BFSSearchClass)地址&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/crmo/BFSSearchC
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS横竖屏总结</title>
    <link href="https://crmo.github.io/2018/07/23/iOS%E6%A8%AA%E7%AB%96%E5%B1%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://crmo.github.io/2018/07/23/iOS横竖屏总结/</id>
    <published>2018-07-22T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.843Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>Auto Layout</code>来进行布局就不用自己去监听横竖屏事件了，只需要绘制多套布局即可。但是项目有很多页面是自己手动计算的，于是只有想办法再旋转屏幕时重新布局。</p><h2 id="相关枚举"><a href="#相关枚举" class="headerlink" title="相关枚举"></a>相关枚举</h2><p>屏幕方向有3个相关枚举，界面方向<code>UIInterfaceOrientation</code>，设备方向<code>UIDeviceOrientation</code>，支持旋转方向<code>UIInterfaceOrientationMask</code>。</p><blockquote><p>注意UIInterfaceOrientation与UIDeviceOrientation左右方向是相反的</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIInterfaceOrientation</span>) &#123;</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationUnknown</span>            = <span class="built_in">UIDeviceOrientationUnknown</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationPortrait</span>           = <span class="built_in">UIDeviceOrientationPortrait</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationPortraitUpsideDown</span> = <span class="built_in">UIDeviceOrientationPortraitUpsideDown</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationLandscapeLeft</span>      = <span class="built_in">UIDeviceOrientationLandscapeRight</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationLandscapeRight</span>     = <span class="built_in">UIDeviceOrientationLandscapeLeft</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIInterfaceOrientationMask</span>) &#123;</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskPortrait</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationPortrait</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationLandscapeLeft</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationLandscapeRight</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskPortraitUpsideDown</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationPortraitUpsideDown</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscape</span> = (<span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskAll</span> = (<span class="built_in">UIInterfaceOrientationMaskPortrait</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span> | <span class="built_in">UIInterfaceOrientationMaskPortraitUpsideDown</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskAllButUpsideDown</span> = (<span class="built_in">UIInterfaceOrientationMaskPortrait</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="横竖屏控制"><a href="#横竖屏控制" class="headerlink" title="横竖屏控制"></a>横竖屏控制</h2><p>控制界面横竖屏切换有3个重要的点，最终结果以这三个地方的值取交集。</p><p><strong>1.info.plist全局控制</strong></p><p>可以在<code>General-&gt;Deplyment Info</code>界面上勾选</p><p><img src="/images/15320065885480.jpg" alt="15320065885480"></p><p> info.plist文件中配置也是一样的，两边会同步变更</p><p><img src="/images/15320512384395.jpg" alt="15320512384395"></p><p><strong>2.AppDelegate中根据不同Window控制</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppDelegate</span></span><br><span class="line">- (<span class="built_in">UIInterfaceOrientationMask</span>)application:(<span class="built_in">UIApplication</span> *)application supportedInterfaceOrientationsForWindow:(<span class="built_in">UIWindow</span> *)window &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskPortrait</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.在ViewController中控制当前页面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// UIViewController</span><br><span class="line">- (BOOL)shouldAutorotate &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</span><br><span class="line">    return UIInterfaceOrientationMaskLandscapeLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，交集不能为空，否则会导致crash</p></blockquote><p>*** Terminating app due to uncaught exception ‘UIApplicationInvalidInterfaceOrientation’, reason: ‘Supported orientations has no common orientation with the application, and [ViewController<br>shouldAutorotate] is returning YES’</p><p><img src="/images/15320548897266-1.jpg" alt="15320548897266"></p><h2 id="旋转事件监听"><a href="#旋转事件监听" class="headerlink" title="旋转事件监听"></a>旋转事件监听</h2><h3 id="旋转事件传递过程"><a href="#旋转事件传递过程" class="headerlink" title="旋转事件传递过程"></a>旋转事件传递过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">op0=&gt;operation: __CFRunLoopDoSources0</span><br><span class="line">op1=&gt;operation: UIDevice</span><br><span class="line">op2=&gt;operation: UIWindow</span><br><span class="line">op3=&gt;operation: UIViewController</span><br><span class="line">op4=&gt;operation: UIView</span><br><span class="line"></span><br><span class="line">op1-&gt;op2-&gt;op3-&gt;op4</span><br></pre></td></tr></table></figure><h3 id="屏幕旋转相关事件"><a href="#屏幕旋转相关事件" class="headerlink" title="屏幕旋转相关事件"></a>屏幕旋转相关事件</h3><p>viewWillTransitionToSize:withTransitionCoordinator:</p><ul><li>ViewController被父容器变更size时调用（例如window旋转时调用root view controller的该方法）</li><li>如果重载该方法，需要调用super传递事件给子ViewController</li><li>这个方法是最关键的，可以在该方法中对界面进行重新布局</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator</span><br><span class="line">&#123;</span><br><span class="line">    // coordinator用来处理转换动画</span><br><span class="line">    [coordinator animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context)</span><br><span class="line">     &#123;</span><br><span class="line">         // 开始旋转</span><br><span class="line">     &#125; completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context)</span><br><span class="line">     &#123;</span><br><span class="line">         // 旋转结束</span><br><span class="line">     &#125;];</span><br><span class="line">     // 记得调用super</span><br><span class="line">    [super viewWillTransitionToSize:size withTransitionCoordinator:coordinator];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UIApplicationWillChangeStatusBarOrientationNotification </p><ul><li>状态栏将要旋转，这个时候取view的frame还是旋转之前的</li><li>NSNotification中用key <code>UIApplicationStatusBarOrientationUserInfoKey</code>可以取到将要旋转到的方向。</li></ul><p>UIApplicationDidChangeStatusBarOrientationNotification </p><ul><li>状态栏已经旋转，这个时候取view的frame是旋转之后的</li><li>NSNotification中用key <code>UIApplicationStatusBarOrientationUserInfoKey</code>可以取到旋转之前的方向。</li></ul><p>UIDeviceOrientationDidChangeNotification </p><ul><li>设备方向变更，在收到通知时取view的frame是旋转之后的。</li><li>在手机上将旋转屏幕锁定之后，设备方向变更之后收不到该通知</li><li>在代码里面限制设备旋转方向，设备方向变更后依然能收到该通知</li></ul><p>调用顺序如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 旋转屏幕</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op1=&gt;operation: viewWillTransitionToSize:withTransitionCoordinator:</span><br><span class="line">op2=&gt;operation: UIApplicationWillChangeStatusBarOrientationNotification</span><br><span class="line">op3=&gt;operation: UIApplicationDidChangeStatusBarOrientationNotification</span><br><span class="line">op4=&gt;operation: viewWillLayoutSubviews</span><br><span class="line">op5=&gt;operation: viewDidLayoutSubviews</span><br><span class="line">op6=&gt;operation: UIDeviceOrientationDidChangeNotification</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;e</span><br></pre></td></tr></table></figure><h2 id="自定义Window的旋转事件"><a href="#自定义Window的旋转事件" class="headerlink" title="自定义Window的旋转事件"></a>自定义Window的旋转事件</h2><p>如果想要在自定义Window的子View收到屏幕旋转通知，要设置UIWindow的rootViewController，然后把所有子view都加到rootViewController，系统会处理横竖屏事件。这里我还遇到一个坑<a href="https://crmo.github.io/2018/07/19/记一个实现UIWindow子类的小坑/">记一个实现UIWindow子类的小坑</a>。</p><hr><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://satanwoo.github.io/2016/09/17/uiwindow-iOS/" target="_blank" rel="noopener">https://satanwoo.github.io/2016/09/17/uiwindow-iOS/</a><br><a href="https://tbd.ink/2017/07/05/iOS/17070501.iOS屏幕旋转知识点以及实现/index/" target="_blank" rel="noopener">iOS屏幕旋转知识点以及实现</a><br><a href="https://imtangqi.com/2017/03/08/handle-orientation-changes-one/" target="_blank" rel="noopener">iOS 屏幕旋转的那些事（一）</a><br><a href="https://satanwoo.github.io/2016/09/17/uiwindow-iOS/" target="_blank" rel="noopener">浅谈iOS的多Window处理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用&lt;code&gt;Auto Layout&lt;/code&gt;来进行布局就不用自己去监听横竖屏事件了，只需要绘制多套布局即可。但是项目有很多页面是自己手动计算的，于是只有想办法再旋转屏幕时重新布局。&lt;/p&gt;
&lt;h2 id=&quot;相关枚举&quot;&gt;&lt;a href=&quot;#相关枚举&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>记一个实现UIWindow子类的小坑</title>
    <link href="https://crmo.github.io/2018/07/19/%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0UIWindow%E5%AD%90%E7%B1%BB%E7%9A%84%E5%B0%8F%E5%9D%91/"/>
    <id>https://crmo.github.io/2018/07/19/记一个实现UIWindow子类的小坑/</id>
    <published>2018-07-18T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>项目中为了实现一个全局遮罩界面，使用了一个UIWindow的子类<code>MyWindow</code>，<code>MyWindow</code>为了实现回调定义了代理<code>MyWindowDelegate</code>。代码大致如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MyWindowDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyWindow</span> : <span class="title">UIWindow</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>)<span class="keyword">id</span>&lt;MyWindowDelegate&gt; delegate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyWindow</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.windowLevel = <span class="built_in">UIWindowLevelNormal</span>;</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        <span class="built_in">UIViewController</span> *vc = [[ViewController2 alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.rootViewController = vc;</span><br><span class="line">        <span class="keyword">self</span>.hidden = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后在实现界面横屏时，发现整个UIWindow不响应横竖屏事件。刚开始以为横竖屏设置被关闭了，查了各种资料，发现这种写法是没有问题的。设置UIWindow的rootViewController，然后把所有子view都加到rootViewController，系统会处理横竖屏问题。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>用Runtime把UIWindow的私有变量打出来，就发现问题了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printUIWindowIvars &#123;</span><br><span class="line">    Ivar *ivars = class_copyIvarList([<span class="built_in">UIWindow</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, ivar_getName(ivar));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看输出，发现有个私有变量<code>_delegate</code>。</p><p><img src="/images/15319834677166.jpg" alt="15319834677166"></p><p><code>MyWindow</code>的属性<code>delegate</code>覆盖了父类<code>UIWindow</code>的变量，导致横竖屏切换事件失效。在代理命名的时候一定要注意啊，<code>delegate</code>看来不是一个好的实践，应该加前缀区分避免覆盖父类的实现，特别是这种私有的变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;项目中为了实现一个全局遮罩界面，使用了一个UIWindow的子类&lt;code&gt;MyWindow&lt;/code&gt;，&lt;code&gt;My
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>一个autoreleasepool的使用场景</title>
    <link href="https://crmo.github.io/2018/07/18/%E4%B8%80%E4%B8%AAautoreleasepool%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://crmo.github.io/2018/07/18/一个autoreleasepool的使用场景/</id>
    <published>2018-07-17T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.861Z</updated>
    
    <content type="html"><![CDATA[<p>今天在学习大佬博客的时候看到一个问题，下面代码会有什么问题？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// largeNumber是一个很大的数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; largeNumber; i++) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"hello -%04d"</span>, i];</span><br><span class="line">    str = [str stringByAppendingString:<span class="string">@" - world"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始没看出什么问题，就是普通的循环，每次循环创建一个局部变量<code>NSString</code>。于是写了个Demo验证了下，在观察内存的时候发现了端倪，在循环过程中，内存不断飙升。</p><p><img src="/images/15318782609811.jpg" alt="15318782609811"></p><p>顿时明白了，原来问题的关键就是这个<code>largeNumber</code>，当循环此时很大时，就会创建大量的局部变量，而且得不到释放，于是内存就爆了。这时候就该<code>@autoreleasepool</code>上场了，优化后代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; largeNumber; i++) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"hello -%04d"</span>, i];</span><br><span class="line">        str = [str stringByAppendingString:<span class="string">@" - world"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看运行内存，可以看到非常平稳。</p><p><img src="/images/15318784002251.jpg" alt="15318784002251"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在学习大佬博客的时候看到一个问题，下面代码会有什么问题？&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UITabbar自定义Badge</title>
    <link href="https://crmo.github.io/2018/07/10/UITabbar%E8%87%AA%E5%AE%9A%E4%B9%89Badge/"/>
    <id>https://crmo.github.io/2018/07/10/UITabbar自定义Badge/</id>
    <published>2018-07-09T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.882Z</updated>
    
    <content type="html"><![CDATA[<p>tabBarItem的Badge默认样式是带数字的，但是产品要求只要一个小红点，不需要数字，这就需要我们自定义Badge了。</p><p>用Reveal分析UITabBar，发现每个按钮是一个<code>UITabBarButton</code>，层级如下：</p><blockquote><p>-UITabBarButton<br>–UITabBarSwappableImageView // 图标<br>–UITabBarButtonLabel // 文字</p></blockquote><p>如何从<code>UITabBar</code>中找到对应index的<code>UITabBarButton</code>呢？我们断点调试下，可以看到可以直接从<code>UITabBar</code>中用KVC取出。</p><p><img src="/images/QQ20180711-174329.png" alt="QQ20180711-174329"></p><p>实现方案如下：</p><ul><li>用KVC找到UITabBarSwappableImageView，关键函数<code>__iconViewWithIndex</code></li><li>新建Badge，加到UITabBarSwappableImageView上</li><li>新建Badge的时候设置Tag，通过Tag来移除Badge</li></ul><p>上代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kBadgeViewTagBase = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITabBar</span> (<span class="title">badge</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示Badge</span></span><br><span class="line">- (<span class="keyword">void</span>)showBadgeOnItemIndex:(<span class="keyword">int</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="keyword">self</span>.items.count) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果之前添加过，直接设置hidden为NO</span></span><br><span class="line">    <span class="built_in">UIView</span> *icon = [<span class="keyword">self</span> __iconViewWithIndex:index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subView <span class="keyword">in</span> icon.subviews) &#123;</span><br><span class="line">        <span class="keyword">if</span> (subView.tag == kBadgeViewTagBase) &#123;</span><br><span class="line">            subView.hidden = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *badgeView = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    badgeView.tag = kBadgeViewTagBase;</span><br><span class="line">    badgeView.layer.cornerRadius = <span class="number">5</span>;</span><br><span class="line">    badgeView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    badgeView.frame = <span class="built_in">CGRectMake</span>(icon.frame.size.width - <span class="number">5</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">9</span>);</span><br><span class="line">    [icon addSubview:badgeView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏Badge</span></span><br><span class="line">- (<span class="keyword">void</span>)hideBadgeOnItemIndex:(<span class="keyword">int</span>)index &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *icon = [<span class="keyword">self</span> __iconViewWithIndex:index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subView <span class="keyword">in</span> icon.subviews) &#123;</span><br><span class="line">        <span class="keyword">if</span> (subView.tag == kBadgeViewTagBase) &#123;</span><br><span class="line">            subView.hidden = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取图标所在View</span></span><br><span class="line">- (<span class="built_in">UIView</span> *)__iconViewWithIndex:(<span class="keyword">int</span>)index &#123;</span><br><span class="line">    <span class="built_in">UITabBarItem</span> *item = <span class="keyword">self</span>.items[index];</span><br><span class="line">    <span class="built_in">UIView</span> *tabBarButton = [item valueForKey:<span class="string">@"_view"</span>];</span><br><span class="line">    <span class="built_in">UIView</span> *icon = [tabBarButton valueForKey:<span class="string">@"_info"</span>];</span><br><span class="line">    <span class="keyword">return</span> icon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tabBarItem的Badge默认样式是带数字的，但是产品要求只要一个小红点，不需要数字，这就需要我们自定义Badge了。&lt;/p&gt;
&lt;p&gt;用Reveal分析UITabBar，发现每个按钮是一个&lt;code&gt;UITabBarButton&lt;/code&gt;，层级如下：&lt;/p&gt;
&lt;b
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>计算文字长度</title>
    <link href="https://crmo.github.io/2018/07/09/%E8%AE%A1%E7%AE%97%E6%96%87%E5%AD%97%E9%95%BF%E5%BA%A6/"/>
    <id>https://crmo.github.io/2018/07/09/计算文字长度/</id>
    <published>2018-07-08T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.871Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://developer.apple.com/documentation/foundation/nsstring/1524729-boundingrectwithsize?language=occ" target="_blank" rel="noopener">官方文档</a></p></blockquote><h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSRect</span>)boundingRectWithSize:(<span class="built_in">NSSize</span>)size </span><br><span class="line">                       options:(<span class="built_in">NSStringDrawingOptions</span>)options </span><br><span class="line">                    attributes:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSAttributedStringKey</span>, <span class="keyword">id</span>&gt; *)attributes </span><br><span class="line">                       context:(<span class="built_in">NSStringDrawingContext</span> *)context;</span><br></pre></td></tr></table></figure><h2 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h2><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>绘制的限制size，计算出来的值不会超过这个大小。</p><h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><p>一些配置项。定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSStringDrawingOptions</span>) &#123;</span><br><span class="line">    <span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">// The specified origin is the line fragment origin, not the base line origin</span></span><br><span class="line">    <span class="built_in">NSStringDrawingUsesFontLeading</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">// Uses the font leading for calculating line heights</span></span><br><span class="line">    <span class="built_in">NSStringDrawingUsesDeviceMetrics</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">// Uses image glyph bounds instead of typographic bounds</span></span><br><span class="line">    <span class="built_in">NSStringDrawingTruncatesLastVisibleLine</span> <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">6</span>_0) = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">// Truncates and adds the ellipsis character to the last visible line if the text doesn't fit into the bounds specified. Ignored if NSStringDrawingUsesLineFragmentOrigin is not also set.</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">6</span>_0);</span><br></pre></td></tr></table></figure><p>实际测试使用<code>NSStringDrawingUsesLineFragmentOrigin|NSStringDrawingUsesFontLeading</code>可以满足需求，<code>NSStringDrawingUsesLineFragmentOrigin</code>是必须的，<code>NSStringDrawingUsesFontLeading</code>加不加在测试的时候没发现区别，但是在<a href="https://stackoverflow.com/questions/13621084/boundingrectwithsize-for-nsattributedstring-returning-wrong-size/15399767#15399767" target="_blank" rel="noopener">stackoverflow相关讨论</a>里加上了，留个坑，后面知道为什么了来补充吧。</p><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><p>字体</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>上下文</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>如果是多行文字，options要加上<code>NSStringDrawingUsesLineFragmentOrigin</code></li><li>返回的值是小数，需要调用<code>ceil</code>向上取整</li><li>得到的宽度可能比实际宽</li></ol><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">CGSize</span>)getTextLabelSize:(<span class="built_in">NSString</span> *)message &#123;</span><br><span class="line">    <span class="keyword">if</span> ([message length] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 文本框的最大宽度</span></span><br><span class="line">        <span class="keyword">float</span> maxWidth = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">CGRect</span> textRect = [message</span><br><span class="line">                           boundingRectWithSize:<span class="built_in">CGSizeMake</span>(maxWidth, <span class="built_in">CGFLOAT_MAX</span>)</span><br><span class="line">                           options:(<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> |</span><br><span class="line">                                    <span class="built_in">NSStringDrawingUsesFontLeading</span>)</span><br><span class="line">                           attributes:@&#123;</span><br><span class="line">                                        <span class="built_in">NSFontAttributeName</span> :</span><br><span class="line">                                            [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">16</span>]</span><br><span class="line">                                        &#125;</span><br><span class="line">                           context:<span class="literal">nil</span>];</span><br><span class="line">        textRect.size.height = ceilf(textRect.size.height);</span><br><span class="line">        textRect.size.width = ceilf(textRect.size.width);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGSizeMake</span>(textRect.size.width, textRect.size.height);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGSizeZero</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring/1524729-boundingrectwithsize?language=occ&quot; target=&quot;_b
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UITextField控制输入长度</title>
    <link href="https://crmo.github.io/2018/07/06/UITextField%E6%8E%A7%E5%88%B6%E8%BE%93%E5%85%A5%E9%95%BF%E5%BA%A6/"/>
    <id>https://crmo.github.io/2018/07/06/UITextField控制输入长度/</id>
    <published>2018-07-05T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.894Z</updated>
    
    <content type="html"><![CDATA[<p>有些时候会有控制输入框文字长度的需求，记录一个简单的思路。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)textField:(<span class="built_in">UITextField</span> *)textField shouldChangeCharactersInRange:(<span class="built_in">NSRange</span>)range replacementString:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    <span class="keyword">if</span> (string.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> limit = <span class="number">15</span>; <span class="comment">// 文本的最大长度</span></span><br><span class="line">    <span class="built_in">NSString</span> *newStr = [textField.text stringByAppendingString:string]; <span class="comment">// 修改之后的新字符串</span></span><br><span class="line">    <span class="built_in">NSInteger</span> newStrLength = newStr.length;</span><br><span class="line">    newStrLength -= [textField textInRange:[textField markedTextRange]].length; <span class="comment">// 去掉高亮内容，输入中文拼音的情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newStrLength &gt; limit) &#123;</span><br><span class="line">        <span class="comment">// 处理composed character, 比如emoji</span></span><br><span class="line">        <span class="built_in">NSString</span> *tempStr = [newStr substringWithRange:[newStr rangeOfComposedCharacterSequencesForRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, limit)]];</span><br><span class="line">        textField.text = tempStr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个坑注意下：</p><ol><li>emoji是<code>composed character</code>，它是由多个字符组合，长度不是1。最开始用的<code>substringToIndex</code>会导致最后一个emoji乱码。</li><li>计算长度的时候要去掉中文输入的时候高亮部分</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有些时候会有控制输入框文字长度的需求，记录一个简单的思路。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>property or synthsize</title>
    <link href="https://crmo.github.io/2018/07/05/property%20or%20synthsize/"/>
    <id>https://crmo.github.io/2018/07/05/property or synthsize/</id>
    <published>2018-07-04T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.910Z</updated>
    
    <content type="html"><![CDATA[<p>@property (nonatomic, retain) NSObject *var;</p><ul><li>生成var的set、get方法的方法声明</li><li>生成var的set、get方法的实现（<strong>早期版本编译器不生成</strong>）</li><li>生成成员变量_var（<strong>早期版本编译器不生成</strong>）</li></ul><p>@synthsize var = _var</p><ul><li>生成var的set、get方法的实现</li><li>生成var对应的成员变量_var</li></ul><blockquote><p>mrc年代的get、set方法的写法</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setVar:(<span class="built_in">NSObject</span> *)var &#123;</span><br><span class="line">    <span class="keyword">if</span> (_var != var) &#123; <span class="comment">// 如果多次set同一个对象，如果不判断会导致对象被释放</span></span><br><span class="line">        <span class="comment">// 释放之前的var</span></span><br><span class="line">        [_var release];</span><br><span class="line">        _var = [var <span class="keyword">retain</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSObject</span> *)var &#123;</span><br><span class="line">    <span class="keyword">return</span> _var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@property (nonatomic, retain) NSObject *var;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成var的set、get方法的方法声明&lt;/li&gt;
&lt;li&gt;生成var的set、get方法的实现（&lt;strong&gt;早期版本编译器不生成&lt;/strong&gt;）&lt;/
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Tagged Pointer小记</title>
    <link href="https://crmo.github.io/2018/07/04/Tagged%20Pointer%E5%B0%8F%E8%AE%B0/"/>
    <id>https://crmo.github.io/2018/07/04/Tagged Pointer小记/</id>
    <published>2018-07-03T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.998Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文使用的测试环境是arm64架构真机</p></blockquote><p>为了探究Tagged Pointer本质，可以查看runtime源码，主要看文件<code>objc-internal.h</code>。</p><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>可以看到以下宏定义，只有在64位系统才支持<code>Tagged Pointer</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJC_HAVE_TAGGED_POINTERS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>64-bit的mac，tag存储在LSB（Least Significant Bit 最低位）。其它情况比如64位的真机和模拟器，tag存储在MSB（Most Significant Bit 最高位）。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if TARGET_OS_OSX &amp;&amp; __x86_64__</span></span><br><span class="line">    <span class="comment">// 64-bit Mac - tag bit is LSB</span></span><br><span class="line"><span class="meta">#   define OBJC_MSB_TAGGED_POINTERS 0</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="comment">// Everything else - tag bit is MSB</span></span><br><span class="line"><span class="meta">#   define OBJC_MSB_TAGGED_POINTERS 1</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if OBJC_MSB_TAGGED_POINTERS</span></span><br><span class="line"><span class="meta">#   define _OBJC_TAG_MASK (1UL<span class="meta-string">&lt;&lt;63)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_INDEX_SHIFT 60</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_SLOT_SHIFT 60</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_PAYLOAD_LSHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_PAYLOAD_RSHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_MASK (0xfUL&lt;&lt;60)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_INDEX_SHIFT 52</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_SLOT_SHIFT 52</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 12</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#else</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_MASK 1UL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_INDEX_SHIFT 1</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_SLOT_SHIFT 0</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_PAYLOAD_LSHIFT 0</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_PAYLOAD_RSHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_MASK 0xfUL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_INDEX_SHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_SLOT_SHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 0</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#endif</span></span></span><br></pre></td></tr></table></figure><p>接下来是一个枚举定义，定义了默认的使用<code>Tagged Pointer</code>的类。例如NSString、NSNumber、NSIndexPath、NSDate（OBJC_TAG_NSAtom、OBJC_TAG_1、OBJC_TAG_NSManagedObjectID不知道是啥意思，还请知道的同学告诉我）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">objc_tag_index_t</span> : <span class="keyword">uint16_t</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    OBJC_TAG_NSAtom            = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_1                 = <span class="number">1</span>, </span><br><span class="line">    OBJC_TAG_NSString          = <span class="number">2</span>, </span><br><span class="line">    OBJC_TAG_NSNumber          = <span class="number">3</span>, </span><br><span class="line">    OBJC_TAG_NSIndexPath       = <span class="number">4</span>, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID = <span class="number">5</span>, </span><br><span class="line">    OBJC_TAG_NSDate            = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_RESERVED_7        = <span class="number">7</span>, </span><br><span class="line"></span><br><span class="line">    OBJC_TAG_First60BitPayload = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_Last60BitPayload  = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_First52BitPayload = <span class="number">8</span>, </span><br><span class="line">    OBJC_TAG_Last52BitPayload  = <span class="number">263</span>, </span><br><span class="line"></span><br><span class="line">    OBJC_TAG_RESERVED_264      = <span class="number">264</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><p>判断是不是<code>Tagged Pointer</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_objc_isTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成一个<code>Tagged Pointer</code>，最高的4位是tagged，剩下的是数据</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> * _Nonnull</span><br><span class="line">_objc_makeTaggedPointer(objc_tag_index_t tag, uintptr_t value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag &lt;= OBJC_TAG_Last60BitPayload) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)</span><br><span class="line">            (_OBJC_TAG_MASK | </span><br><span class="line">             ((uintptr_t)tag &lt;&lt; _OBJC_TAG_INDEX_SHIFT) | </span><br><span class="line">             ((value &lt;&lt; _OBJC_TAG_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_LSHIFT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)</span><br><span class="line">            (_OBJC_TAG_EXT_MASK |</span><br><span class="line">             ((uintptr_t)(tag - OBJC_TAG_First52BitPayload) &lt;&lt; _OBJC_TAG_EXT_INDEX_SHIFT) |</span><br><span class="line">             ((value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>Tagged Pointer</code>中取出值</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uintptr_t</span><br><span class="line">_objc_getTaggedPointerValue(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class="line">    uintptr_t basicTag = ((uintptr_t)ptr &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class="line">    <span class="keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((uintptr_t)ptr &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((uintptr_t)ptr &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NSNumber应用举例"><a href="#NSNumber应用举例" class="headerlink" title="NSNumber应用举例"></a>NSNumber应用举例</h2><p>可以使用下面代码来验证NSNumber如何使用<code>Tagged Pointer</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *charNumber = [<span class="built_in">NSNumber</span> numberWithChar:<span class="string">'1'</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *shortNumber = [<span class="built_in">NSNumber</span> numberWithShort:<span class="number">1</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *intNumber = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *floatNumber = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.0</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *longNumber = [<span class="built_in">NSNumber</span> numberWithLong:<span class="number">1</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *doubleNumber = [<span class="built_in">NSNumber</span> numberWithDouble:<span class="number">1.0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出变量的指针地址：</span></span><br><span class="line"><span class="comment">// charNumber 0xb000000000000310</span></span><br><span class="line"><span class="comment">// shortNumber 0xb000000000000011</span></span><br><span class="line"><span class="comment">// intNumber 0xb000000000000012</span></span><br><span class="line"><span class="comment">// floatNumber 0xb000000000000014</span></span><br><span class="line"><span class="comment">// longNumber 0xb000000000000013</span></span><br><span class="line"><span class="comment">// doubleNumber 0xb000000000000015</span></span><br></pre></td></tr></table></figure><p>不难发现规律，都是以b(1011)开头</p><ul><li>最高位是1，说明这个指针是一个<code>Tagged Pointer</code></li><li>第61-63位是11（十进制是3），也就是<code>OBJC_TAG_NSNumber</code>（查上面的枚举）</li><li>第1-4位是NSNumber的类型：比如，char是0、short是1、int是2、float是4</li><li>剩下的56位就是真正的值了</li></ul><h2 id="NSString应用举例"><a href="#NSString应用举例" class="headerlink" title="NSString应用举例"></a>NSString应用举例</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str1 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"a"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"ab"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出变量的指针地址：</span></span><br><span class="line"><span class="comment">// str1: 0xa000000000000611</span></span><br><span class="line"><span class="comment">// str2: 0xa000000000062612</span></span><br></pre></td></tr></table></figure><p>与NSNumber类似</p><ul><li>最高位是1，说明这个指针是一个<code>Tagged Pointer</code></li><li>第61-63位是11（十进制是2），也就是<code>OBJC_TAG_NSString</code></li><li>第1-4位是字符串长度</li><li>剩下的56位就是真正的值了</li></ul><blockquote><p>更多细节推荐这篇文章<a href="http://www.cocoachina.com/ios/20150918/13449.html" target="_blank" rel="noopener">采用Tagged Pointer的字符串</a></p></blockquote><hr><p>参考文章</p><ul><li><a href="https://www.jianshu.com/p/e354f9137ba8" target="_blank" rel="noopener">iOS Tagged Pointer</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" target="_blank" rel="noopener">wiki</a></li><li><a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer" target="_blank" rel="noopener">深入理解Tagged Pointer</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文使用的测试环境是arm64架构真机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了探究Tagged Pointer本质，可以查看runtime源码，主要看文件&lt;code&gt;objc-internal.h&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;宏
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>URLWithString return nil</title>
    <link href="https://crmo.github.io/2018/07/03/URLWithString%20return%20nil/"/>
    <id>https://crmo.github.io/2018/07/03/URLWithString return nil/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:38.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在使用<code>URLWithString</code>生成NSURL时，如果出现中文，会导致返回的NSURL为nil。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSURL *aUrl = [NSURL URLWithString:@&quot;http://中文域名&quot;];</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/1981390/urlwithstring-returns-nil" target="_blank" rel="noopener">stackoverflow相关讨论</a></p><p>查询了<a href="https://developer.apple.com/documentation/foundation/nsurl/1572047-urlwithstring?changes=_1&amp;language=objc" target="_blank" rel="noopener">URLWithString的官方文档</a>，其中有一段话解决了我的疑惑。</p><blockquote><p>This method expects URLString to contain only characters that are allowed in a properly formed URL. All other characters must be properly percent escaped. Any percent-escaped characters are interpreted using UTF-8 encoding.</p></blockquote><p>意思就是该方法的输入参数<code>URLString</code>只能包含URL的合法字符，包含非法字符的URL需要进行百分号编码(percent escaped)</p><h2 id="百分号编码（percent-escaped）"><a href="#百分号编码（percent-escaped）" class="headerlink" title="百分号编码（percent escaped）"></a>百分号编码（percent escaped）</h2><p><a href="https://zh.wikipedia.org/wiki/百分号编码" target="_blank" rel="noopener">wiki相关词条</a></p><p>有两种情况必须使用百分号编码</p><ol><li>参数中出现保留字符</li></ol><p>URL所允许的字符分作保留与未保留，保留字符是那些具有特殊含义的字符</p><p><img src="/images/15305867541997.jpg" alt=""></p><ol><li>URL中出现非ASCII字符</li></ol><p>对于非ASCII字符, 需要转换为UTF-8字节序，再进行百分号编码</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用方法<code>stringByAddingPercentEscapesUsingEncoding</code>对URL字符串百分号编码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *encodeUrl = [url stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    NSURL *aUrl = [NSURL URLWithString:encodeUrl];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在使用&lt;code&gt;URLWithString&lt;/code&gt;生成NSURL时，如果出现中文，会导致返回的NSURL为nil。代
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS消息转发小记</title>
    <link href="https://crmo.github.io/2018/05/31/iOS%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E5%B0%8F%E8%AE%B0/"/>
    <id>https://crmo.github.io/2018/05/31/iOS消息转发小记/</id>
    <published>2018-05-30T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:38.021Z</updated>
    
    <content type="html"><![CDATA[<p>消息转发流程图</p><p><img src="/images/15277558865032.jpg" alt=""></p><p>如果类接收到无法处理的消息，会触发消息转发机制，一共有三个步骤，接受者在每一步中均有机会处理消息。步骤越往后，处理消息的代价就越大，所以最好再第一步就处理完。</p><h2 id="第一道防线"><a href="#第一道防线" class="headerlink" title="第一道防线"></a>第一道防线</h2><p>在类里面实现两个方法来处理未知消息。执行动态方法解析之前，先会判断是否曾经有动态解析。</p><ul><li><code>resolveInstanceMethod</code>：处理实例方法</li><li><code>resolveClassMethod</code>：处理类方法</li></ul><p>我们来看个Demo，先看调用方代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TestA *testA = [[TestA alloc] init];</span><br><span class="line">[testA instanceMethod];</span><br><span class="line">[TestA classMethod];</span><br></pre></td></tr></table></figure><p>再来看看TestA的定义。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestA.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestA</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)instanceMethod;</span><br><span class="line">+ (<span class="keyword">void</span>)classMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestA.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestA</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)newInstanceMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"newInstanceMethod"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)newClassMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"newClassMethod"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(instanceMethod)) &#123;</span><br><span class="line">        <span class="comment">// 动态添加方法newInstanceMethod</span></span><br><span class="line">        Method method = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(newInstanceMethod));</span><br><span class="line">        IMP imp = method_getImplementation(method);</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, imp, method_getTypeEncoding(method));</span><br><span class="line">        <span class="comment">// 成功处理，消息转发机制结束，调用newInstanceMethod</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能处理，进入第二步</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(classMethod)) &#123;</span><br><span class="line">        <span class="comment">// 动态添加方法newClassMethod</span></span><br><span class="line">        Method method = class_getInstanceMethod(object_getClass(<span class="keyword">self</span>), <span class="keyword">@selector</span>(newClassMethod));</span><br><span class="line">        IMP imp = method_getImplementation(method);</span><br><span class="line">        class_addMethod(object_getClass(<span class="keyword">self</span>), sel, imp, method_getTypeEncoding(method));</span><br><span class="line">        <span class="comment">// 成功处理，消息转发机制结束，调用newClassMethod</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能处理，进入第二步</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>TestA中头文件定义了两个方法，但是没有实现，如果不用消息转发机制处理异常，会导致crash，log想必大家应该很熟悉</p><blockquote><p>*** Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[TestA funcA]: unrecognized selector sent to instance 0x6040000125c0’</p></blockquote><p>实例方法存储在类对象，类方法存储在元类对象，在调用<code>class_addMethod</code>时，第一个参数需要注意。</p><h2 id="第二道防线"><a href="#第二道防线" class="headerlink" title="第二道防线"></a>第二道防线</h2><p>第二道防线依赖一个函数<code>forwardingTargetForSelector</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类方法</span></span><br><span class="line"><span class="comment">//+ (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(instanceMethod)) &#123;</span><br><span class="line">        <span class="comment">// 消息转发给TestB实例</span></span><br><span class="line">        <span class="keyword">return</span> [TestB new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消息转发失败，进入下一步</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestB.m</span></span><br><span class="line">- (<span class="keyword">void</span>)instanceMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"instanceMethod"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三道防线"><a href="#第三道防线" class="headerlink" title="第三道防线"></a>第三道防线</h2><p>第三道防线有两步</p><ol><li>调用<code>methodSignatureForSelector</code>，获取新的方法签名（返回值类型，参数类型）</li><li>调用<code>forwardInvocation</code>，转发消息，</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法签名（返回值类型，参数类型）</span></span><br><span class="line"><span class="comment">// 类方法减号改为加号</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [TestB instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSInvocation封装了方法调用，包括：方法调用者、方法名、方法参数</span></span><br><span class="line"><span class="comment">// anInvocation.target 消息接受者</span></span><br><span class="line"><span class="comment">// anInvocation.selector 函数名</span></span><br><span class="line"><span class="comment">// [anInvocation getArgument:NULL atIndex:0]; 获取参数</span></span><br><span class="line"><span class="comment">// 类方法减号改为加号</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[TestB new]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;消息转发流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/15277558865032.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果类接收到无法处理的消息，会触发消息转发机制，一共有三个步骤，接受者在每一步中均有机会处理消息。步骤越往后，处理消息的代价就越大，所以最
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>探寻Objective-C引用计数本质</title>
    <link href="https://crmo.github.io/2018/05/26/%E6%8E%A2%E5%AF%BBObjective-C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    <id>https://crmo.github.io/2018/05/26/探寻Objective-C引用计数本质/</id>
    <published>2018-05-25T16:00:00.000Z</published>
    <updated>2018-10-07T08:16:32.324Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文涉及到的CPU架构为arm64，其它架构大同小异。<br>源码来自<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">苹果开源-runtime</a>。</p></blockquote><p>Objective-C中采用引用计数机制来管理内存，在MRC时代，需要我们手动<code>retain</code>和<code>release</code>，在苹果引入ARC后大部分时间我们不用再关心引用计数问题。但是为了深入Objective-C本质，引用计数究竟是怎么实现的还是值得我们去探寻的。</p><h2 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h2><p>OC中的对象的实质其实是结构体，其中大部分对象都有isa，指向类对象（有一种神奇的存在叫做<code>Tagged Pointer</code>），源码中关于对象结构体<code>objc_object</code>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-private.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">id <span class="title">retain</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">id <span class="title">autorelease</span><span class="params">()</span></span>;</span><br><span class="line">    ... <span class="comment">//省略了其它方法，感兴趣可以直接看源码</span></span><br></pre></td></tr></table></figure><h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p>除了有一种特殊的对象<code>Tagged Pointer</code>，这种类型的对象值就存在指针当中，存取性能高。可以用来存储少量数据的对象，例如NSNumber、NSDate、NSString。(更多Tagged Pointer知识，具体看这篇<a href="https://crmo.github.io/2018/07/04/Tagged%20Pointer小记/">Tagged Pointer小记</a>)。也就没有引用计数、内存释放的问题。</p><h3 id="NONPOINTER-ISA"><a href="#NONPOINTER-ISA" class="headerlink" title="NONPOINTER ISA"></a>NONPOINTER ISA</h3><p>arm64架构isa占64位，苹果为了优化性能，存储类对象地址只用了33位，剩下的位用来存储一些其它信息，比如本文讨论的引用计数。</p><p>NONPOINTER ISA存储的字段定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">    struct &#123;</span><br><span class="line">        uintptr_t nonpointer        : 1;</span><br><span class="line">        uintptr_t has_assoc         : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">        uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000</span><br><span class="line">        uintptr_t magic             : 6;</span><br><span class="line">        uintptr_t weakly_referenced : 1;</span><br><span class="line">        uintptr_t deallocating      : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">        uintptr_t extra_rc          : 19;</span><br><span class="line">#       define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#       define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="extra-rc"><a href="#extra-rc" class="headerlink" title="extra_rc"></a>extra_rc</h2><p>那引用计数存在哪里呢？秘密就在<code>extra_rc</code>中。</p><blockquote><p>extra_rc只是存储了额外的引用计数，实际的引用计数计算公式：<code>引用计数=extra_rc+1</code>。</p></blockquote><p><code>extra_rc</code>占了19位，可以存储的最大引用计数：$2^{19}-1+1=524288$，超过它就需要进位到<code>SideTables</code>。SideTables是一个Hash表，根据对象地址可以找到对应的<code>SideTable</code>，<code>SideTable</code>内包含一个<code>RefcountMap</code>，根据对象地址取出其引用计数，类型是<code>size_t</code>。<br>它是一个<code>unsigned long</code>，最低两位是标志位，剩下的62位用来存储引用计数。我们可以计算出引用计数的理论最大值：$2^{62+19}=2.417851639229258e24$。</p><blockquote><p>其实isa能存储的524288在日常开发已经完全够用了，为什么还要搞个Side Table？我猜测是因为历史问题，以前cpu是32位的，isa中能存储的引用计数就只有$2^{7}=128$。因此在arm64下，引用计数通常是存储在isa中的。</p></blockquote><h2 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h2><p>有了前面的铺垫，我们知道引用计数怎么存储的了，那引用计数又是怎么改变的呢？通过剖析<code>retain</code>源码我们就可以得出结论了。<br>objc_object的方法全部定义在objc-object.h文件中，全是内联函数，应该是为了性能的考虑。</p><p>我们来看看<code>retain</code>的函数定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> id </span><br><span class="line">objc_object::retain()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        <span class="keyword">return</span> rootRetain();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((id(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_retain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这层比较简单，做了三件事情：</p><ol><li>判断指针是不是<code>Tagged Pointer</code></li><li>判断是否有自定义<code>retain</code>，如果有调用自定义的。</li><li>最后调用<code>rootRetain</code></li></ol><p>我们来看看关键函数<code>rootRetain</code>的实现（为了便于阅读，代码有所删减）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain(<span class="keyword">bool</span> tryRetain, <span class="keyword">bool</span> handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">isa_t</span> oldisa;</span><br><span class="line">    <span class="keyword">isa_t</span> newisa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁，用汇编指令ldxr来保证原子性</span></span><br><span class="line">    oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    newisa = oldisa;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newisa.nonpointer = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// newisa.nonpointer = 0说明所有位数都是地址值</span></span><br><span class="line">        <span class="comment">// 释放锁，使用汇编指令clrex</span></span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 由于所有位数都是地址值，直接使用sidetable来存储引用计数</span></span><br><span class="line">        <span class="keyword">return</span> sidetable_retain();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储extra_rc++后的结果</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> carry;</span><br><span class="line">    <span class="comment">// extra_rc++</span></span><br><span class="line">    newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// extra_rc++后溢出，进位到side table</span></span><br><span class="line">        newisa.extra_rc = RC_HALF;</span><br><span class="line">        newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 将newisa写入isa</span></span><br><span class="line">    StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)</span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个细节可以了解下，如何用汇编来实现原子性操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE</span><br><span class="line"><span class="keyword">uintptr_t</span> </span><br><span class="line">LoadExclusive(<span class="keyword">uintptr_t</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> result;</span><br><span class="line">    <span class="comment">// 在多核CPU下，对一个地址的访问可能引起冲突，ldxr解决了冲突，保证原子性。</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"ldxr %x0, [%x1]"</span> </span><br><span class="line">        : <span class="string">"=r"</span> (result) </span><br><span class="line">        : <span class="string">"r"</span> (src), <span class="string">"m"</span> (*src));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><p><code>release</code>代码逻辑基本上就是<code>retain</code>反过来走一遍，有点不同的是在引用计数减到0时，会调用对象的dealloc方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE bool</span><br><span class="line">objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line">    </span><br><span class="line">retry:</span><br><span class="line">    oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    newisa = oldisa;</span><br><span class="line">    if (newisa.nonpointer == 0) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        if (sideTableLocked) sidetable_unlock();</span><br><span class="line">        return sidetable_release(performDealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    uintptr_t carry;</span><br><span class="line">    // extra_rc--</span><br><span class="line">    newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);</span><br><span class="line">    if (carry == 0) &#123;</span><br><span class="line">        // 需要从SideTable借位，或者引用计数为0</span><br><span class="line">        goto underflow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 存储引用计数到isa</span><br><span class="line">    StoreReleaseExclusive(&amp;isa.bits,</span><br><span class="line">                          oldisa.bits, newisa.bits)</span><br><span class="line">    return false;</span><br><span class="line">    </span><br><span class="line">underflow:</span><br><span class="line">    // 从SideTable借位</span><br><span class="line">    // 或引用计数为0，调用delloc</span><br><span class="line">    </span><br><span class="line">    // 此处省略N多代码</span><br><span class="line">    // 总结一下:修改Side Table与extra_rc，</span><br><span class="line">    </span><br><span class="line">    // 引用计数减为0时，调用dealloc</span><br><span class="line">    if (performDealloc) &#123;</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>引用计数存在哪？</p></blockquote><ol><li><code>Tagged Pointer</code>不需要引用计数</li><li><code>NONPOINTER ISA</code>(isa的第一位为1)的引用计数优先存在isa中，大于524288了进位到<code>Side Tables</code></li><li>非<code>NONPOINTER ISA</code>引用计数存在<code>Side Tables</code></li></ol><blockquote><p>retain/release的实质</p></blockquote><ul><li>找到引用计数存储区域，然后+1/-1</li><li>如果是<code>NONPOINTER ISA</code>，还要处理进位/借位的情况</li><li>release在引用计数减为0时，调用<code>dealloc</code></li></ul><hr><p>参考</p><ul><li><a href="https://github.com/Draveness/analyze/blob/master/contents/objc/黑箱中的%20retain%20和%20release.md" target="_blank" rel="noopener">黑箱中的 retain 和 release</a></li><li><a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer" target="_blank" rel="noopener">深入理解Tagged Pointer</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文涉及到的CPU架构为arm64，其它架构大同小异。&lt;br&gt;源码来自&lt;a href=&quot;https://opensource.apple.com/tarballs/objc4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;苹果开
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Cordova源码解析（二）- 自定义UserAgent</title>
    <link href="https://crmo.github.io/2018/05/15/Cordova%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-%20%E8%87%AA%E5%AE%9A%E4%B9%89UserAgent/"/>
    <id>https://crmo.github.io/2018/05/15/Cordova源码解析（二）- 自定义UserAgent/</id>
    <published>2018-05-14T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.929Z</updated>
    
    <content type="html"><![CDATA[<p>本文分析的源码是基于Cordova 4.2.1版本，<a href="https://cordova.apache.org" target="_blank" rel="noopener">Cordova官网</a>。</p><h1 id="Cordova源码解析（二）-自定义UserAgent"><a href="#Cordova源码解析（二）-自定义UserAgent" class="headerlink" title="Cordova源码解析（二）- 自定义UserAgent"></a>Cordova源码解析（二）- 自定义UserAgent</h1><p><code>UIWebView</code>没有提供设置UserAgent的接口，但是有一个办法可以间接的设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary* dict = [[NSDictionary alloc] initWithObjectsAndKeys:value, @&quot;UserAgent&quot;, nil];</span><br><span class="line">[[NSUserDefaults standardUserDefaults] registerDefaults:dict];</span><br></pre></td></tr></table></figure><p>通过设置<code>NSUserDefaults</code>中<code>UserAgent</code>的值来修改，但是这种设置方法有一个限制，需要在<code>UIWebView</code>的<code>loadRequest</code>之前调用才能生效(加载PDF比较特殊)。这是Cordova源码中关于这个问题的描述</p><blockquote><p>Setting the UserAgent must occur before a UIWebView is instantiated.<br>It is read per instantiation, so it does not affect previously created views.<br>Except! When a PDF is loaded, all currently active UIWebViews reload their<br>User-Agent from the NSUserDefaults some time after the DidFinishLoad of the PDF bah!</p></blockquote><h2 id="CDVUserAgentUtil"><a href="#CDVUserAgentUtil" class="headerlink" title="CDVUserAgentUtil"></a>CDVUserAgentUtil</h2><p>在多WebView的情况下，如果每个WebView都有不同的<code>UserAgent</code>，就会产生数据竞争的问题，大家都要修改<code>NSUserDefaults</code>中<code>UserAgent</code>的值，于是需要对资源加锁来保证每个WebView都设置预期的<code>UserAgent</code>。在Cordova中，专门有一个类<code>CDVUserAgentUtil</code>来实现这个功能。</p><p><code>CDVUserAgentUtil.h</code>文件中定义了四个方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取UIWebView默认的UserAgent</span></span><br><span class="line">+ (<span class="built_in">NSString</span>*)originalUserAgent;</span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">+ (<span class="keyword">void</span>)acquireLock:(<span class="keyword">void</span> (^)(<span class="built_in">NSInteger</span> lockToken))block;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">+ (<span class="keyword">void</span>)releaseLock:(<span class="built_in">NSInteger</span>*)lockToken;</span><br><span class="line"><span class="comment">// 设置UIWebView的UserAgent</span></span><br><span class="line">+ (<span class="keyword">void</span>)setUserAgent:(<span class="built_in">NSString</span>*)value lockToken:(<span class="built_in">NSInteger</span>)lockToken;</span><br></pre></td></tr></table></figure><h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><p>每次加锁成功会返回一个NSInteger类型的token，在释放锁的时候需要把token传入。token会不断递增，保证每次加锁返回的token都不回重复。加锁的实现代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVUserAgentUtil.m</span></span><br><span class="line">+ (<span class="keyword">void</span>)acquireLock:(<span class="keyword">void</span> (^)(<span class="built_in">NSInteger</span> lockToken))block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gCurrentLockToken == <span class="number">0</span>) &#123;</span><br><span class="line">        gCurrentLockToken = ++gNextLockToken;</span><br><span class="line">        VerboseLog(<span class="string">@"Gave lock %d"</span>, gCurrentLockToken);</span><br><span class="line">        block(gCurrentLockToken);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (gPendingSetUserAgentBlocks == <span class="literal">nil</span>) &#123;</span><br><span class="line">            gPendingSetUserAgentBlocks = [[<span class="built_in">NSMutableArray</span> alloc] initWithCapacity:<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        VerboseLog(<span class="string">@"Waiting for lock"</span>);</span><br><span class="line">        [gPendingSetUserAgentBlocks addObject:block];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>acquireLock:</code>，首先会判断<code>gCurrentLockToken</code>是否等于0</p><ul><li>如果是0说明没有模块正在修改<code>UserAgent</code>，能够成功获取到锁，<code>gCurrentLockToken</code>递增，标致当前有模块正在修改<code>UserAgent</code>，并回调<code>block</code>，返回<code>gCurrentLockToken</code></li><li>如果不为0说明当前有模块正在修改<code>UserAgent</code>，将<code>block</code>回调存在一个队列<code>gPendingSetUserAgentBlocks</code>中</li></ul><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>释放锁需要传入token，释放锁代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)releaseLock:(<span class="built_in">NSInteger</span>*)lockToken</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*lockToken == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSAssert</span>(gCurrentLockToken == *lockToken, <span class="string">@"Got token %ld, expected %ld"</span>, (<span class="keyword">long</span>)*lockToken, (<span class="keyword">long</span>)gCurrentLockToken);</span><br><span class="line"></span><br><span class="line">    VerboseLog(<span class="string">@"Released lock %d"</span>, *lockToken);</span><br><span class="line">    <span class="keyword">if</span> ([gPendingSetUserAgentBlocks count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> (^block)() = [gPendingSetUserAgentBlocks objectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [gPendingSetUserAgentBlocks removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        gCurrentLockToken = ++gNextLockToken;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Gave lock %ld"</span>, (<span class="keyword">long</span>)gCurrentLockToken);</span><br><span class="line">        block(gCurrentLockToken);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        gCurrentLockToken = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *lockToken = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果要释放的<code>lockToken</code>为0，说明还没加过锁，就调用释放了，直接返回</li><li>从队列<code>gPendingSetUserAgentBlocks</code>中取出最早加入的<code>block</code>，从队列中移除</li><li><code>gCurrentLockToken</code>递增生成新token，回调<code>block</code></li><li>如果队列<code>gPendingSetUserAgentBlocks</code>释放完成，说明释放锁的调用次数&gt;加锁的次数，不做操作，然后把<code>gCurrentLockToken</code>置为0</li></ul><h2 id="设置UserAgent"><a href="#设置UserAgent" class="headerlink" title="设置UserAgent"></a>设置UserAgent</h2><p>在Cordova实际运用中，操作锁的时机：<br>加锁时机：<code>CDVViewController</code>加载完毕，在<code>viewDidLoad</code>里调用<br>释放锁时机：</p><ul><li><code>UIWebView</code>的<code>webViewDidFinishLoad:</code>回调</li><li><code>UIWebView</code>的<code>webView:didFailLoadWithError:</code>回调</li><li><code>CDVViewController</code>的<code>dealloc</code></li><li><code>CDVViewController</code>的<code>viewDidUnload</code></li></ul><p>加锁代码，省略了不相关代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVViewController.m</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [CDVUserAgentUtil acquireLock:^(<span class="built_in">NSInteger</span> lockToken) &#123;</span><br><span class="line">        _userAgentLockToken = lockToken;</span><br><span class="line">        [CDVUserAgentUtil setUserAgent:<span class="keyword">self</span>.userAgent lockToken:lockToken];</span><br><span class="line">        <span class="built_in">NSURLRequest</span>* appReq = [<span class="built_in">NSURLRequest</span> requestWithURL:appURL cachePolicy:<span class="built_in">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class="number">20.0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.webViewEngine loadRequest:appReq];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放锁代码，这里只看正常逻辑，在网页加载完成回调<code>webViewDidFinishLoad:</code>中释放逻辑。不考虑异常情况，省略了不相关代码。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDVUIWebViewNavigationDelegate.m</span></span><br><span class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span>*)theWebView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Finished load of: %@"</span>, theWebView.request.URL);</span><br><span class="line">    CDVViewController* vc = (CDVViewController*)<span class="keyword">self</span>.enginePlugin.viewController;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It's safe to release the lock even if this is just a sub-frame that's finished loading.</span></span><br><span class="line">    [CDVUserAgentUtil releaseLock:vc.userAgentLockToken];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>webViewDidFinishLoad:</code>回调时，UserAgent已经设置成功，所以可以释放锁，让其它WebView操作UserDefault了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文分析的源码是基于Cordova 4.2.1版本，&lt;a href=&quot;https://cordova.apache.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cordova官网&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;Cordova源码解析（二）-自
      
    
    </summary>
    
    
      <category term="源码学习" scheme="https://crmo.github.io/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
