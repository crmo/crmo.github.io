<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CR.MO`s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://crmo.github.io/"/>
  <updated>2018-12-02T08:21:32.062Z</updated>
  <id>https://crmo.github.io/</id>
  
  <author>
    <name>CR.MO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Core Animation学习笔记（一）</title>
    <link href="https://crmo.github.io/2018/12/02/Core%20Animation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://crmo.github.io/2018/12/02/Core Animation学习笔记（一）/</id>
    <published>2018-12-01T16:00:00.000Z</published>
    <updated>2018-12-02T08:21:32.062Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是我阅读书籍《iOS CORE ANIMATION ADVANCED TECHNIQUES》的读书笔记，感谢原书作者及译者的分享！<br>推荐大家有时间可以读读原书，写的很精彩。<a href="https://zsisme.gitbooks.io/ios-/content/index.html" target="_blank" rel="noopener">中文版</a></p></blockquote><h2 id="一、Core-Animation定义"><a href="#一、Core-Animation定义" class="headerlink" title="一、Core Animation定义"></a>一、Core Animation定义</h2><p>什么是<code>Core Animation</code>，相信很多同学对于它既熟悉又陌生，从名字上来看它应该是一个做动画的框架，其实动画只是它的一部分，它曾经叫做<code>Layer Kit</code>。</p><p>引用书中的定义：</p><blockquote><p>Core Animation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的<code>Layer</code>，并存储在<code>Layer Tree</code>中。于是这个树形成了UIKit以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。</p></blockquote><p>看完还是一脸懵逼？没关系，在这一系列文章中，我将抽丝剥茧，带领大家揭开<code>Core Animation</code>的神秘面纱。</p><h2 id="二、UIView与CALayer"><a href="#二、UIView与CALayer" class="headerlink" title="二、UIView与CALayer"></a>二、UIView与CALayer</h2><p>我们平时开发中，接触最多的就是<code>UIView</code>，UIView可以处理触摸事件，可以支持基于<code>Core Graphics</code>绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p><p>每个<code>UIView</code>都包含一个<code>CALayer</code>实例，也就是所谓的<code>backing layer</code>。<code>CALayer</code>与<code>UIView</code>最大的区别是它不处理用户的交互，它的职责是负责屏幕上的显示和动画。<code>UIView</code>负责处理用户交互，并管理<code>CALayer</code>。</p><p><code>UIView</code>其实就是对<code>CALayer</code>的高级封装，为什么苹果不直接用一个简单层级来处理所有事情？原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有<code>UIKit</code>和<code>UIView</code>，但是Mac OS有<code>AppKit</code>和<code>NSView</code>的原因。他们功能上很相似，但是在实现上有着显著的区别。</p><h3 id="CALayer独有功能"><a href="#CALayer独有功能" class="headerlink" title="CALayer独有功能"></a>CALayer独有功能</h3><p>有一些UIView没有暴露出来的CALayer的功能：</p><ul><li>阴影，圆角，带颜色的边框</li><li>3D变换</li><li>非矩形范围</li><li>透明遮罩</li><li>多级非线性动画</li></ul><h2 id="三、backing-image"><a href="#三、backing-image" class="headerlink" title="三、backing image"></a>三、backing image</h2><p><code>backing image</code>是<code>CALayer</code>的重要部分，通过它可以实现各种复杂的UI。有两种设置<code>backing image</code>的方法:</p><ol><li>设置CALayer的<code>contents</code>属性</li><li>直接用<code>Core Graphics</code>绘制</li></ol><h3 id="contents"><a href="#contents" class="headerlink" title="contents"></a>contents</h3><p>CALayer有一个属性叫做<code>contents</code>，这个属性的类型被定义为id，但是，如果你给<code>contents</code>赋的不是CGImage，那么你得到的图层将是空白的。</p><blockquote><p><code>contents</code>这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。</p></blockquote><p>我们先来看一个Demo，在<code>CALayer</code>中加载了一张图片：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    view.center = <span class="keyword">self</span>.view.center;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:view];</span><br><span class="line">    <span class="built_in">CALayer</span> *layer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    [view.layer addSublayer:layer];</span><br><span class="line">    layer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [UIImage imageNamed:@"test"]会根据不同机型取不同倍图</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"test"</span>];</span><br><span class="line">    <span class="comment">// UIImage转CGImageRef时scale属性丢失</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = image.CGImage;</span><br><span class="line">    layer.contents = (__bridge <span class="keyword">id</span>)imageRef;</span><br><span class="line">    <span class="comment">// 设置图片缩放</span></span><br><span class="line">    <span class="comment">// 如果contentsGravity设置为自动缩放，可以不用设置这个属性</span></span><br><span class="line">    layer.contentsScale = image.scale;</span><br><span class="line">    <span class="comment">// 设置图片居中不缩放</span></span><br><span class="line">    layer.contentsGravity = kCAGravityCenter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="contentsGravity"><a href="#contentsGravity" class="headerlink" title="contentsGravity"></a>contentsGravity</h4><p><code>UIImageView</code>中通过设置<code>contentMode</code>来设置图片拉伸方式，在<code>CALayer</code>中有一个对应属性<code>contentsGravity</code>，它是一个NSString类型，默认值是<code>kCAGravityResize</code>。<br>它的可选的值有：</p><ul><li>kCAGravityCenter</li><li>kCAGravityTop</li><li>kCAGravityBottom</li><li>kCAGravityLeft</li><li>kCAGravityRight</li><li>kCAGravityTopLeft</li><li>kCAGravityTopRight</li><li>kCAGravityBottomLeft</li><li>kCAGravityBottomRight</li><li>kCAGravityResize</li><li>kCAGravityResizeAspect</li><li>kCAGravityResizeAspectFill</li></ul><h4 id="UIImage转CGImage拉伸丢失问题"><a href="#UIImage转CGImage拉伸丢失问题" class="headerlink" title="UIImage转CGImage拉伸丢失问题"></a>UIImage转CGImage拉伸丢失问题</h4><p>和UIImage不同，CGImage没有拉伸的概念。使用UIImage类去读取图片的时候，它会读取了屏幕（1x、2x、3x）对应尺寸的图片。但是用CGImage来设置<code>layer.contents</code>时，拉伸这个因素在转换的时候就丢失了，不过我们可以通过手动设置<code>contentsScale</code>来修复这个问题。</p><h4 id="contentsScale"><a href="#contentsScale" class="headerlink" title="contentsScale"></a>contentsScale</h4><p>如果<code>contentsScale</code>设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片。<code>UIView</code>中对应<code>contentScaleFactor</code>属性。</p><h4 id="contentsCenter"><a href="#contentsCenter" class="headerlink" title="contentsCenter"></a>contentsCenter</h4><p>contentsCenter是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。类似于<code>UIImage</code>里的<code>resizableImageWithCapInsets</code> 方法，只是它可以运用到任何<code>backing image</code>，甚至包括<code>Core Graphics</code>绘制的图形。</p><p><img src="images/15436482245238.jpg" alt=""></p><h3 id="Custom-Drawing"><a href="#Custom-Drawing" class="headerlink" title="Custom Drawing"></a>Custom Drawing</h3><p>第二种方案是直接用<code>Core Graphics</code>绘制<code>backing image</code>，具体实现方式是通过继承<code>UIView</code>并实现<code>drawRect</code>来自定义绘制。</p><h4 id="CALayerDelegate"><a href="#CALayerDelegate" class="headerlink" title="CALayerDelegate"></a>CALayerDelegate</h4><p>要理解<code>drawRect</code>的工作原理，首先我们来看看<code>CALayerDelegate</code>。<br><code>CALayer</code>有一个可选的delegate，通过实现<code>CALayerDelegate</code>，就可以自定义<code>CALayer</code>的<code>backing image</code>。<br><code>CALayerDelegate</code>中有两个值得关注的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由-display方法的默认实现调用，你应该实现整个显示过程（通常通过设置'contents'属性）</span></span><br><span class="line"><span class="comment">// 如果实现了该方法，就不会调用drawLayer:inContext:了</span></span><br><span class="line">- (<span class="keyword">void</span>)displayLayer:(<span class="built_in">CALayer</span> *)layer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由-drawInContext方法的默认实现调用</span></span><br><span class="line"><span class="comment">// 如果没有实现displayLayer:，就会调用该方法</span></span><br><span class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx;</span><br></pre></td></tr></table></figure><p>给个简单的Demo：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    view.center = <span class="keyword">self</span>.view.center;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:view];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CALayer</span> *layer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    [view.layer addSublayer:layer];</span><br><span class="line">    layer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 设置代理</span></span><br><span class="line">    layer.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// display方法必须手动调用，不然不会执行绘制</span></span><br><span class="line">    [layer display]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx &#123;</span><br><span class="line">    <span class="comment">// 画一个圆环</span></span><br><span class="line">    <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="built_in">UIColor</span> redColor].CGColor);</span><br><span class="line">    <span class="built_in">CGContextStrokeEllipseInRect</span>(ctx, layer.bounds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，<code>[layer display]</code>需要手动调用，<code>CALayer</code>不会自动重绘它的内容，而是把重绘决定权交给了开发者。</p></blockquote><h4 id="drawRect"><a href="#drawRect" class="headerlink" title="drawRect"></a>drawRect</h4><p>理解了<code>CALayerDelegate</code>再来看<code>drawRect</code>就简单很多了，<code>UIView</code>把<code>CALayerDelegate</code>设置为自己，并实现了<code>displayLayer:</code>，我们不再需要关心这些细节，只需要重写<code>drawRect</code>，在方法内绘制<code>backing image</code>即可。</p><p><strong>drawRect调用时机</strong></p><p>当<code>UIView</code>在屏幕上出现的时候，<code>drawRect</code>方法就会被自动调用。然后内容就会被缓存起来直到它需要被更新，通常是因为手动调用了<code>setNeedsDisplay</code>，或影响到表现效果的属性值被更改时，如bounds属性。</p><p>需要注意的是，调用<code>setNeedsDisplay</code>后，不会马上触发<code>drawRect</code>，而是要等到接收到RunLoop的<code>kCFRunLoopBeforeWaiting</code>通知后触发<code>drawRect</code>，如下图所示。</p><p><img src="images/15436511549803.jpg" alt="drawRect调用栈"></p><p><strong>如非必须，勿重写drawRect</strong></p><p><code>drawRect</code>方法没有默认的实现，因为对UIView来说，<code>backing image</code>并不是必须的。如果<code>UIView</code>检测到<code>drawRect</code>方法被调用了，它就会为视图分配一个<code>backing image</code>，这个<code>backing image</code>的像素尺寸等于<code>视图大小 * contentsScale</code>；反之则不会创建<code>backing image</code>，因此如果没有自定义绘制的任务就不要在重写一个空的<code>drawRect</code>。</p><blockquote><p>在做实验的时候发现了一个有趣现象，在同一个RunLoop循环里，先调用<code>setNeedsDisplay</code>，再设置<code>view.layer</code>的<code>contents</code>，系统就不会调用<code>drawRect</code>方法了(难道是因为设置<code>contents</code>会把<code>needsDisplay</code>设置为NO？？)。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果我们只是写一个简单的登录界面，其实用<code>UIView</code>这种高级接口就够了。但是为了实现复杂UI与丝滑体验，使用<code>Core Animation</code>就是一个很好的选择（缺点是门槛高点，编码复杂度要高些）。<br>本文要点总结如下：</p><ol><li><code>Core Animation</code>是一个负责处理图层、屏幕绘制、动画等的复合引擎</li><li><code>UIView</code>是对<code>CALayer</code>的高级封装，每个<code>UIView</code>包含一个<code>CALayer</code>实例。</li><li>在<code>CALayer</code>上绘制内容，需要设置它的<code>backing image</code>，有两种方式：<ul><li>设置CALayer的<code>contents</code>属性</li><li>直接用<code>Core Graphics</code>绘制</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文是我阅读书籍《iOS CORE ANIMATION ADVANCED TECHNIQUES》的读书笔记，感谢原书作者及译者的分享！&lt;br&gt;推荐大家有时间可以读读原书，写的很精彩。&lt;a href=&quot;https://zsisme.gitbooks.
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>App Store上架漫谈</title>
    <link href="https://crmo.github.io/2018/11/15/App%20Store%E4%B8%8A%E6%9E%B6%E6%BC%AB%E8%B0%88/"/>
    <id>https://crmo.github.io/2018/11/15/App Store上架漫谈/</id>
    <published>2018-11-14T16:00:00.000Z</published>
    <updated>2018-12-02T07:46:38.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近忙着写Bug😂，好久没有写文章了。今天和大家分享下我最近上架第二个独立开发的APP“识之”的上架经验（其实就是为了做一波广告）。</p><blockquote><p>重点来了！！！<br>识之，人工智能AI识别，动物、植物、Logo、汽车车型、菜品、通用（识别各种东西）统统可以识别。只需用相机拍一张照片，或者从相册中选择要识别的图片，即可得到答案。使用完全免费使用，解决您的知识焦虑！<br>下载链接：<a href="http://t.cn/EAs5ubq" target="_blank" rel="noopener">http://t.cn/EAs5ubq</a><br>五星好评截图返现💕</p></blockquote><p>好了，重点结束了，接下来聊点闲话😏。</p><h2 id="聊聊审核"><a href="#聊聊审核" class="headerlink" title="聊聊审核"></a>聊聊审核</h2><p>“识之”是我上架的第二个独立开发APP，2天搞定审核成功上架（第一个APP是3天），有些心得和大家分享下。<br>不得不说苹果审核团队现在的效率很高，一般一天就可以审核完成，我记得我刚开始做iOS那会，审核一次要一周，真的太漫长了。<br>每次提交新版本之后，第二天早上起床第一件事情就是收邮件。经常会看到这样的标题的邮件，心态瞬间蹦了。</p><p><img src="/images/WechatIMG82.jpeg" alt="WechatIMG82"></p><p>但是不要慌，这只是苹果怀疑你存在一些问题，并不代表真的有问题。先静下心来，读读这篇<a href="https://developer.apple.com/cn/app-store/review/guidelines" target="_blank" rel="noopener">上架过审秘籍</a>。</p><p>然后<code>仔细阅读</code>苹果的答复，仔细揣摩审核团队的用意。把审核团队当做小白用户，站在他们的角度来思考他们提出的问题，然后对照<a href="https://developer.apple.com/cn/app-store/review/guidelines" target="_blank" rel="noopener">苹果审核条例</a>仔细检查。如果确认自己不存在问题，就直接回复邮件说明，针对审核团队提出的问题详细解释（不需要重新提交二进制文件），一般隔天就能收到审核团队的答复。</p><blockquote><p>这里有个技巧我屡试不爽，提交审核时，可以附上一个演示视频。因为APP的业务逻辑一般比较复杂，单靠文字描述难以表述清楚（想想产品经理当面交代的功能都经常被做偏，别说短短一封邮件了），而且长文本会让人看着很抓狂，审核团队一天密集的审核，看着长篇大论心情自然不好。这时候附上一个精心录制的演示视频，一眼就可以看懂你的APP是干嘛的。<br>视频推荐上传到Youtube方便国外观看。</p></blockquote><p>如果确认APP真的存在问题，那就乖乖的修改吧，修改之后重新提交审核（额。。。马甲包什么的不在本文的讨论范围）。</p><blockquote><p>今年10月后上架的APP都需要提供隐私政策，<a href="http://crmo.github.io/2018/10/13/应对苹果隐私政策看我就够了/">这篇文章</a>教你轻松应对。</p></blockquote><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><p>这里和大家分享下“识之”的上架过程，”香蕉播放器“的上架过程看<a href="http://crmo.github.io/2018/10/07/记“香蕉播放器”上架的辛酸历程/">这篇文章</a>。<br>提交的第二天就收到拒信，涉及到的条款：<code>3.1.4</code>、<code>4.2</code>（这次终于没有刺激的2.1大礼包了）。下面是审核团队的回复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Guideline 3.1.4 - Business - Payments - Content Codes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Your app enables additional features or functionality when used with augmented reality markers or QR codes. However, those features are not available in the app to users without the necessary markers.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">To resolve this issue, please provide a means to access these features from within the app, such as through achievements or in-app purchase. If they can be freely obtained, such as through a link to a website, please revise your app to include clear instructions for obtaining the necessary markers or codes.</span><br><span class="line"></span><br><span class="line">Please note that apps cannot require users to purchase unrelated products or engage in advertising or marketing activities to unlock app functionality.</span><br><span class="line"></span><br><span class="line">Guideline 4.2 - Design - Minimum Functionality</span><br><span class="line"></span><br><span class="line">We noticed that your app includes an AR or QR scanner but does not include any additional content or functionality unless the user has access to the AR marker or QR code. While we understand that your app displays additional content when an AR marker or QR code is scanned, to users who do not have access to the AR markers or QR codes, your app only appears to display a camera view.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">We encourage you to provide your users with additional content in your app, including directions on how to use your app and information on how to obtain any necessary AR markers or QR codes.</span><br><span class="line"></span><br><span class="line">To ensure users have the best experience, apps should provide valuable utility or entertainment, draw people in by offering compelling capabilities or content, or enable people to do something they couldn&apos;t do before or in a way they couldn&apos;t do it before.</span><br></pre></td></tr></table></figure><p>阅读理解时间开始了，第一遍看完我是一脸懵逼的，回复中提到了两个关键词<code>AR markers</code>和<code>QR codes</code>，可是我根本没有用到这些东西。于是我冷静下来，查了下审核指南。</p><p><img src="/images/15422845505208.jpg" alt="15422845505208"></p><p><img src="/images/15422846190717.jpg" alt="15422846190717"></p><p>结合审核指南就能理解审核团队的用意了，他们没有理解我的APP的功能，我的APP主要页面是一个相机，拍一张照片，然后识别图片中的物体是啥。<br>审核团队的理解是APP需要配合特殊的实体物体或者二维码才能正常使用，否则APP就没有任何用途。这显然是误解我了，于是我录制了一个视频，详细的演示了APP的功能，配上文字说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dear Apple Review Team:</span><br><span class="line">    Thank you for your patience review, we have done a detailed check on the following questions.</span><br><span class="line">    Our app does not depend on specific markers or QR codes,users can use our app recognize anything,such as cars,plants,animals,dishes,logos.</span><br><span class="line">    We made this app to help users identify objects around them.For example, if the user sees a beautiful plant and wants to know what it is,he can open our app，then take a photo use camera,our app will tell him what is this in the photo.</span><br><span class="line">    We recorded a detailed demo video to illustrate our features:https://youtu.be/1okyq-ZJGzU</span><br><span class="line">    Finally, thank you again for your hard review.</span><br></pre></td></tr></table></figure><p>第二天上架成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近忙着写Bug😂，好久没有写文章了。今天和大家分享下我最近上架第二个独立开发的APP“识之”的上架经验（其实就是为了做一波广告）。&lt;/p
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>聊聊iOS开发中的JSBridge</title>
    <link href="https://crmo.github.io/2018/10/22/%E8%81%8A%E8%81%8AiOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84JSBridge/"/>
    <id>https://crmo.github.io/2018/10/22/聊聊iOS开发中的JSBridge/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-22T13:40:18.102Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/tower-bridge-2324875_1280.jpg" alt="tower-bridge-2324875_1280"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hybrid App（混合模式移动应用）是指介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。谈到Hybrid App，JS与Native code的交互就是一个绕不开的话题，这时就需要“一座桥”来连接两端。<br><code>JSBridge</code>架起了一座连接<code>JavaScript</code>与<code>Native Code</code>的桥梁，让两端可以相互调用。</p><p><img src="/images/JSBridge.png" alt="JSBridge"></p><p>本文基于<code>UIWebView</code>，将会分别介绍3种方案。通过<code>Iframe</code>、<code>Ajax</code>、<code>JSCore</code>来实现JSBridge，涉及到的<a href="https://github.com/crmo/CRJSBridgeDemo" target="_blank" rel="noopener">Demo地址</a>，顺手给个Star呗😏。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h3><p>废话不多说，直入主题，首先讲的这种方案比较常见。<code>WebViewJavascriptBridge</code>与<code>Cordava</code>都是采用的该方案（推荐看看我之前的文章<a href="http://crmo.github.io/2018/05/09/Cordova源码解析/">Cordova源码解析</a>）。<br>核心思路就是在UIWebView拦截Iframe的src，双方提前约定好协议，例如<code>https://__jsbridge__</code>就是一次调用开始。<br>可以学习<code>Cordova</code>的策略，将并发的多次调用打包合并为一次处理，可以优化性能。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>1.JS暴露一个方法给Native，接收执行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">responseFromObjC</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!callback) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    callback(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Native实现<code>UIWebView</code>的代理，在<code>webView:shouldStartLoadWithRequest:navigationType:</code>方法拦截请求，识别到特定URL，开始一次调用流程。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截JS调用原生核心方法</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = request.URL;</span><br><span class="line">    <span class="comment">// 判断url是否是JSBridge调用</span></span><br><span class="line">    <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@"__jsbridge__"</span>]) &#123;</span><br><span class="line">       <span class="comment">// 处理JS调用Native</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.JS开启一个Iframe，加载一个特定的URL，开始一次调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.style.display = <span class="string">'none'</span>;</span><br><span class="line">iframe.src = <span class="string">'https://__jsbridge__?action='</span>+ action + <span class="string">'&amp;data='</span> + data;</span><br><span class="line"><span class="built_in">document</span>.documentElement.appendChild(iframe);</span><br></pre></td></tr></table></figure><p>4.Native方法执行完成后，调用JS方法<code>responseFromObjC</code>将结果回传给JS。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 获取调用参数，demo的调用方式是：'https://__jsbridge__?action=action&amp;data='</span></span><br><span class="line"><span class="comment">// 参数直接放在query里面的，更好的方案是js暴露一个方法给原生，原生调用方法获取数据</span></span><br><span class="line"><span class="built_in">NSURLComponents</span> *urlComponents = [<span class="built_in">NSURLComponents</span> componentsWithURL:url resolvingAgainstBaseURL:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *queryItems = urlComponents.queryItems;</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *params = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURLQueryItem</span> *queryItem <span class="keyword">in</span> queryItems) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = queryItem.name;</span><br><span class="line">    <span class="built_in">NSString</span> *value = queryItem.value;</span><br><span class="line">    [params setObject:value forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSString</span> *action = params[<span class="string">@"action"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *data = params[<span class="string">@"data"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([action isEqualToString:<span class="string">@"alertMessage"</span>]) &#123;</span><br><span class="line">    <span class="comment">// 调用原生方法，获取数据</span></span><br><span class="line">    <span class="comment">// js暴露方法`responseFromObjC`给原生，原生通过该方法回调</span></span><br><span class="line">    <span class="comment">// 在实际项目中，为了实现实现js并发原生方法，最好带一个callBackID，来区分不同的调用</span></span><br><span class="line">    [webView stringByEvaluatingJavaScriptFromString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"responseFromObjC('%@')"</span>, data]];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [webView stringByEvaluatingJavaScriptFromString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"responseFromObjC('Unkown action'"</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:demo代码为了简化，直接将参数放在URL的query里，如果只传输一些简单数据是没有问题的，更好的方案是JS先将参数存放起来，通过URL传递一个key给Native，再暴露一个通过key取数据的方法，Native主动调用这个方法取。</p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>第二种方案是JS使用<code>XMLHttpRequest</code>发起请求，在Native拦截达到调用的目的。通过自定义<code>NSURLProtocol</code>可以拦截到Ajax请求。Demo里有详细的代码和注释，建议结合Demo一起看。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>1.新建类继承自<code>NSURLProtocol</code>，并注册。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSURLProtocol</span> registerClass:[CRURLProtocol <span class="keyword">class</span>]];</span><br></pre></td></tr></table></figure><p>2.实现自定义<code>NSURLProtocol</code>，在<code>startLoading</code>方法拦截Ajax请求</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startLoading &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [[<span class="keyword">self</span> request] URL];</span><br><span class="line">    <span class="comment">// 拦截“http://__jsbridge__”请求</span></span><br><span class="line">    <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@"__jsbridge__"</span>]) &#123;</span><br><span class="line">       <span class="comment">// 处理JS调用Native</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.JS发起Ajax请求，URL为提前约定的特殊值，例如：http://<strong>jsbridge</strong>。请求参数放在<code>Request Body</code>里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用原生</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callNative</span>(<span class="params">action, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="built_in">window</span>.XMLHttpRequest(),</span><br><span class="line">        url = <span class="string">'http://__jsbridge__'</span>;</span><br><span class="line">        xhr.open(<span class="string">'POST'</span>, url, <span class="literal">false</span>);</span><br><span class="line">        xhr.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                    action: action,</span><br><span class="line">                    data: data</span><br><span class="line">                    &#125;));</span><br><span class="line">        <span class="keyword">return</span> xhr.responseText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.Naive拦截到请求，获取参数，执行Native方法，最后通过Ajax的<code>Response</code>把结果返回给JS。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 2. 从HTTPBody中取出调用参数</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dic = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:<span class="keyword">self</span>.request.HTTPBody options:<span class="built_in">NSJSONReadingAllowFragments</span> error:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSString</span> *action = dic[<span class="string">@"action"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *data = dic[<span class="string">@"data"</span>];</span><br><span class="line"><span class="built_in">NSData</span> *responseData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 根据action转发到不同方法处理，param携带参数</span></span><br><span class="line"><span class="keyword">if</span> ([action isEqualToString:<span class="string">@"alertMessage"</span>]) &#123;</span><br><span class="line">    responseData = [data dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    responseData = [<span class="string">@"Unknown action"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 处理完成，将结果返回给js</span></span><br><span class="line">[<span class="keyword">self</span> sendResponseWithResponseCode:<span class="number">200</span> data:responseData mimeType:<span class="string">@"text/html"</span>];</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendResponseWithResponseCode:(<span class="built_in">NSInteger</span>)statusCode data:(<span class="built_in">NSData</span>*)data mimeType:(<span class="built_in">NSString</span>*)mimeType &#123;</span><br><span class="line">    <span class="built_in">NSHTTPURLResponse</span>* response = [[<span class="built_in">NSHTTPURLResponse</span> alloc] initWithURL:[[<span class="keyword">self</span> request] URL] statusCode:statusCode HTTPVersion:<span class="string">@"HTTP/1.1"</span> headerFields:@&#123;<span class="string">@"Content-Type"</span> : mimeType&#125;];</span><br><span class="line">    </span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">    &#125;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSCore"><a href="#JSCore" class="headerlink" title="JSCore"></a>JSCore</h3><p>前两种方案虽然实现方法不一致，但是思路都是类似的，由于JS不能直接调用Native方法，通过曲线救国的方式，找到一个载体来传递信息。<br>第三种方案就比较直接了，使用iOS7推出的黑科技<code>JavaScriptCore</code>，将Native方法直接暴露给JS，打通两端的数据通道。谈到<code>JavaScriptCore</code>不得不说的是bang590的<code>JSPatch</code>，还有ReactNative、Weex等都是利用<code>JavaScriptCore</code>来实现各种炫酷的功能。(强力推荐一本Lefe_x的书<a href="https://github.com/awesome-tips/iOS-Tips/blob/master/resources/一份走心的JS-Native交互电子书.pdf" target="_blank" rel="noopener">《一份走心的JS-Native交互电子书》</a>，非常精彩)。<br>不过这种方案有个缺陷，<code>UIWebView</code>没有暴露<code>JSContext</code>，虽然可以通过KVC拿到，但是毕竟不是一种完美的解决方案，不知道上架会不会有风险（求知道的同学指教一下）。</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>实现流程就不细说了，流程比较简单，Demo里面有。说说关键实现代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)injectJSBridge &#123;</span><br><span class="line">    <span class="comment">// 获取JSContext</span></span><br><span class="line">    JSContext *context = [_webView valueForKeyPath:<span class="string">@"documentView.webView.mainFrame.javaScriptContext"</span>];</span><br><span class="line">    <span class="comment">// 给JS注入方法callNative</span></span><br><span class="line">    context[<span class="string">@"callNative"</span>] = ^(JSValue *action, JSValue *data) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *actionStr = [action toString];</span><br><span class="line">        <span class="built_in">NSString</span> *dataStr = [data toString];</span><br><span class="line">        <span class="keyword">if</span> ([actionStr isEqualToString:<span class="string">@"alertMessage"</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> dataStr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"Unkown action"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS调用非常简单，一句话搞定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callNative(<span class="string">"alertMessage"</span>, <span class="string">"Hello world!"</span>)</span><br></pre></td></tr></table></figure><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>为了验证三种方案的性能，设计了个简单的实验，分别执行了100、1000、10000次调用，测试手机iPhone X，系统iOS 12，时间对比如下图所示。<br>先说结论，JSCore的性能是最优的，<code>JSCore&gt;Ajax&gt;Iframe</code>。在低并发的时候三种方案差距不大，执行次数10000次时Iframe效率就很低了，Ajax次之，JSCore性能很稳定。当然实际使用的时候不会出现调用10000次这种极限情况。<br><code>Cordova</code>对于并发有个优化策略，很值得参考，将并发的多次调用打包合并为一次处理。</p><p><img src="/images/15401284999756.jpg" alt="15401284999756"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/tower-bridge-2324875_1280.jpg&quot; alt=&quot;tower-bridge-2324875_1280&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS定义长字符串的实用宏</title>
    <link href="https://crmo.github.io/2018/10/16/iOS%E5%AE%9A%E4%B9%89%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%94%A8%E5%AE%8F/"/>
    <id>https://crmo.github.io/2018/10/16/iOS定义长字符串的实用宏/</id>
    <published>2018-10-15T16:00:00.000Z</published>
    <updated>2018-10-17T00:58:11.756Z</updated>
    
    <content type="html"><![CDATA[<p>今天在看<code>WebViewJavascriptBridge</code>源码的时候发现一个神奇的宏，在定义较长字符串时很实用。<br>举个例子，将一段js代码存到一个变量，为了便于阅读需要加入换行，需要在每行结束加上<code>\</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"function() &#123; \</span></span><br><span class="line"><span class="string">if (window.WebViewJavascriptBridge) &#123; \</span></span><br><span class="line"><span class="string">return; \</span></span><br><span class="line"><span class="string">&#125; \</span></span><br><span class="line"><span class="string">&#125;)(); \</span></span><br><span class="line"><span class="string">"</span>;</span><br></pre></td></tr></table></figure><p>这时，可以用宏来优化。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define LONG_STRING_DEFINE(x) #x</span></span><br><span class="line"><span class="built_in">NSString</span> *str = @LONG_STRING_DEFINE(function() &#123;</span><br><span class="line"><span class="keyword">if</span> (window.WebViewJavascriptBridge) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>宏展开后代码如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@";(function() &#123; if (window.WebViewJavascriptBridge) &#123; return; &#125;)();"</span>;</span><br></pre></td></tr></table></figure><h2 id="用Xcode看宏展开"><a href="#用Xcode看宏展开" class="headerlink" title="用Xcode看宏展开"></a>用Xcode看宏展开</h2><p>打开<code>Assistant Editor</code>，选择<code>Preproces</code>，就可以看到展开的宏。</p><p><img src="/images/15396963641371.jpg" alt="15396963641371"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在看&lt;code&gt;WebViewJavascriptBridge&lt;/code&gt;源码的时候发现一个神奇的宏，在定义较长字符串时很实用。&lt;br&gt;举个例子，将一段js代码存到一个变量，为了便于阅读需要加入换行，需要在每行结束加上&lt;code&gt;\&lt;/code&gt;。&lt;/p&gt;
&lt;figu
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>应对iOS隐私政策三步曲</title>
    <link href="https://crmo.github.io/2018/10/13/%E5%BA%94%E5%AF%B9%E8%8B%B9%E6%9E%9C%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>https://crmo.github.io/2018/10/13/应对苹果隐私政策看我就够了/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2018-10-21T15:32:19.907Z</updated>
    
    <content type="html"><![CDATA[<p>国庆假期回来准备提交新版本到App Store，遇到苹果新政策，实测下来影响不大，应对还算比较简单，总结一下分享给大家。</p><h2 id="政策说明"><a href="#政策说明" class="headerlink" title="政策说明"></a>政策说明</h2><p><img src="/images/QQ20181012-090233.png" alt="QQ20181012-090233"></p><p>从2018年10月3号起，所有新提交的App都必须提供隐私条例，<a href="https://developer.apple.com/news/?id=08312018a" target="_blank" rel="noopener">官方连接</a>。</p><p>对于隐私条例，苹果审核条例是这么说明的。</p><p><img src="/images/QQ20181012-085839.png" alt="QQ20181012-085839"></p><p>需要在两个地方提供隐私条例：</p><ol><li>元数据</li><li>应用内有明显的入口</li></ol><h2 id="生成隐私条例"><a href="#生成隐私条例" class="headerlink" title="生成隐私条例"></a>生成隐私条例</h2><p>关于隐私条例，网上有各种模板，弄一个改改就行了，这里推荐一个<a href="https://www.freeprivacypolicy.com" target="_blank" rel="noopener">自动生成的网站</a>。<br>免费生成，还提供一个链接，挂在它们网站，就不用自己搞服务器了。例如<a href="https://www.freeprivacypolicy.com/privacy/view/cb2289ee81ec0d2f61ec1790bccf861d" target="_blank" rel="noopener">我给App生成的隐私条例</a></p><p><img src="/images/QQ20181012-090746.png" alt="QQ20181012-090746"></p><h2 id="集成隐私条例"><a href="#集成隐私条例" class="headerlink" title="集成隐私条例"></a>集成隐私条例</h2><p>第一步：把刚刚生成的URL填在元数据里</p><p><img src="/images/QQ20181012-091050.png" alt="QQ20181012-091050"></p><p>第二步：在应用内加一个页面，开一个WebView加载刚刚生成的URL，例如我就放在了“关于-隐私条例”</p><p>第三步：提交审核时，在备注里面说明，隐私条例的入口在哪里。（这一步可能不要也行，不过为了稳妥我加上了，给苹果审核团队讲清楚总是好的）</p><p>第二天就上架成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;国庆假期回来准备提交新版本到App Store，遇到苹果新政策，实测下来影响不大，应对还算比较简单，总结一下分享给大家。&lt;/p&gt;
&lt;h2 id=&quot;政策说明&quot;&gt;&lt;a href=&quot;#政策说明&quot; class=&quot;headerlink&quot; title=&quot;政策说明&quot;&gt;&lt;/a&gt;政策说明&lt;/
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>记“香蕉播放器”上架的辛酸历程</title>
    <link href="https://crmo.github.io/2018/10/07/%E8%AE%B0%E2%80%9C%E9%A6%99%E8%95%89%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%9D%E4%B8%8A%E6%9E%B6%E7%9A%84%E8%BE%9B%E9%85%B8%E5%8E%86%E7%A8%8B/"/>
    <id>https://crmo.github.io/2018/10/07/记“香蕉播放器”上架的辛酸历程/</id>
    <published>2018-10-06T16:00:00.000Z</published>
    <updated>2018-10-07T08:50:30.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>先说点废话，从事iOS开发以来，一直有一个目标，拥有一个自己的APP上架App Store，并且登上苹果推荐榜单，这可能是大多数iOSer的梦想。在脑子里产生了各种想法，但是发现自己能想到的别人都做了，并且做的很好，加上工作生活上的很多事情（主要是懒😝），一拖就是3年。<br>后来因为自己的真实需求，App Store找不到能满足需求的产品，就做了一个播放器自己用，在中秋假期狠下心来，买了开发者账号（688，心痛！！就当为了梦想充值吧。），把这个播放器上架了。</p><h2 id="购买开发者账号"><a href="#购买开发者账号" class="headerlink" title="购买开发者账号"></a>购买开发者账号</h2><p>关于怎么买个人开发者账号，网上的教程一抓一大把，整个购买流程也没啥好注意的，根据提示一步一步走就OK了。但是到了最后付款环节把我卡了一周（办了两张信用卡。。。），必须要<code>visa+银联</code>双标的信用卡，注意一定要双标，只有visa或者只有银联都不行。<br>付了款一天左右苹果就会发来邮件，提供身份证正反面照片就可以了。</p><h2 id="上架App-Store"><a href="#上架App-Store" class="headerlink" title="上架App Store"></a>上架App Store</h2><p>上架流程就轻车熟路了，打包上传、填写各种APP说明、上传图标、宣传图、提交审核。激动的我一晚上没睡好觉，第二天早上打开邮箱，等待我的居然是<code>2.1大礼包</code>（Guideline 2.1 - Information Needed）。</p><p><img src="/images/WechatIMG59.png" alt="WechatIMG59"></p><p>一看我就懵逼了，上架这么多次第一次遇到这么严厉的回复，感觉分分钟要被封号。经过多方咨询，发现这是苹果今年新推出的大礼包，很多人都遇到过，一般是机器审核回复的，遇到这种情况别慌（除非你是马甲包、或者抄袭的之类的APP），仔细检查条例，然后逐条答复（最好用英文）。<br>最后我还录制了一个视频，来演示我的APP的主要功能，上传到<code>youtube</code>，附在了备注。<br>分享下我的答复模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">尊敬的苹果审核团队：</span><br><span class="line">    感谢您的耐心审核，针对下面问题，我们做了详细的检查</span><br><span class="line">    </span><br><span class="line">关于 Guideline 2.1</span><br><span class="line"></span><br><span class="line">1.1.6 - “香蕉播放器”没有包含任何的虚假与误导信息，全部都是真实有效的</span><br><span class="line">2.3.0 - “香蕉播放器”没有在通过审核后修改任何概念和功能</span><br><span class="line">2.3.1 - “香蕉播放器”没有包含任何隐藏功能，没有包含赌博、彩票网站</span><br><span class="line">3.1.1 - “香蕉播放器”内没有任何内购、支付功能，所有功能都是免费提供给用户</span><br><span class="line">3.2.1 - “香蕉播放器”内部包含任何贷款等金融服务</span><br><span class="line">4.3.0 - “香蕉播放器”功能都是独立开发，不存在抄袭或者大量相似</span><br><span class="line">5.2.1 - “香蕉播放器”没有法人实体和版权风险</span><br><span class="line">5.2.3 - “香蕉播放器”没有提供文件共享服务，或者其它存在版权问题的音视频</span><br><span class="line">5.3.4 - “香蕉播放器”仅在中国区上架，没有违规内容</span><br><span class="line"></span><br><span class="line">关于 Guideline 2.3.7</span><br><span class="line"></span><br><span class="line">我已经按照说明，修改了元数据，请审核团队再次审核。</span><br><span class="line"></span><br><span class="line">最后再次感谢您辛苦的审核。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dear Apple Review Team:</span><br><span class="line">    Thank you for your patience review, we have done a detailed check on the following questions.</span><br><span class="line">    </span><br><span class="line">About Guideline 2.1</span><br><span class="line"></span><br><span class="line">1.1.6 - &quot;Banana Player&quot; does not contain any false and misleading information, all of which are true and effective</span><br><span class="line">2.3.0 - &quot;Banana Player&quot; does not modify any concepts and features after passing the review</span><br><span class="line">2.3.1 - &quot;Banana Player&quot; does not contain any hidden features, does not contain gambling, lottery sites</span><br><span class="line">3.1.1 - There is no in-app purchase and payment function in the “Banana Player”, all functions are provided to the user free of charge.</span><br><span class="line">3.2.1 - &quot;Banana Player&quot; contains any financial services such as loans</span><br><span class="line">4.3.0 - The &quot;Banana Player&quot; feature is developed independently, without plagiarism or a lot of similarity</span><br><span class="line">5.2.1 - &quot;Banana Player&quot; has no legal entity and copyright risk</span><br><span class="line">5.2.3 - &quot;Banana Player&quot; does not provide file sharing services, or other audio and video with copyright issues</span><br><span class="line">5.3.4 - &quot;Banana Player&quot; is only available in China, no illegal content</span><br><span class="line"></span><br><span class="line">About Guideline 2.3.7</span><br><span class="line"></span><br><span class="line">I have modified the metadata according to the instructions, please review the team again.</span><br><span class="line"></span><br><span class="line">Finally, thank you again for your hard review.</span><br></pre></td></tr></table></figure><p>第二天审核通过，成功上架！</p><h2 id="打个广告"><a href="#打个广告" class="headerlink" title="打个广告"></a>打个广告</h2><blockquote><p>下载🔗：<a href="https://dwz.cn/HvVix2hH" target="_blank" rel="noopener">https://dwz.cn/HvVix2hH</a></p></blockquote><p>“香蕉播放器”是我独立开发的第一款APP，免费无广告。主要功能在手机上播放从网盘、光盘、网站下载的音频资料、课程、音乐。无需数据线，用Wi-Fi就可以拷贝文件到手机，自动记录播放进度。<br>如果有需求可以支持一波，有什么问题欢迎联系我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;先说点废话，从事iOS开发以来，一直有一个目标，拥有一个自己的APP上架App Store，并且登上苹果推荐榜单，这可能是大
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>记一个行结束符引发的JS报错</title>
    <link href="https://crmo.github.io/2018/09/05/%E8%AE%B0%E4%B8%80%E4%B8%AA%E8%A1%8C%E7%BB%93%E6%9D%9F%E7%AC%A6%E5%BC%95%E5%8F%91%E7%9A%84JS%E6%8A%A5%E9%94%99/"/>
    <id>https://crmo.github.io/2018/09/05/记一个行结束符引发的JS报错/</id>
    <published>2018-09-04T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近遇到一个神奇的Bug，通过<code>UIWebView</code>的<code>stringByEvaluatingJavaScriptFromString:</code>方法执行一段<code>JavaScript</code>代码时，<code>JavaScript</code>报错:</p><blockquote><p>SyntaxError: Unexpected EOF</p></blockquote><p>经过仔细的排查，发现待执行的<code>JavaScript</code>代码里面包含<code>U+2028</code>字符。还找到了<a href="https://stackoverflow.com/questions/2965293/javascript-parse-error-on-u2028-unicode-character" target="_blank" rel="noopener">Stack Overflow相关讨论</a>。<br><code>JavaScript</code>解析器会把行分隔符<code>U+2028</code>和段落分隔符<code>U+2029</code>解析成一行的结束，代码里要是包含这两个字符相当于换行，例如：</p><blockquote><p>alert(“\u2028”)</p></blockquote><p>就会被解析为</p><blockquote><p>alert(“<br>“)</p></blockquote><p>于是就产生了语法错误。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我用的方法比较简单、粗暴，在执行<code>JavaScript</code>代码前，直接过滤掉这两个字符。代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line">    javaScriptString = [javaScriptString stringByReplacingOccurrencesOfString:<span class="string">@"\u2028"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    javaScriptString = [javaScriptString stringByReplacingOccurrencesOfString:<span class="string">@"\u2029"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    <span class="built_in">NSString</span>* ret = [(<span class="built_in">UIWebView</span>*)_engineWebView stringByEvaluatingJavaScriptFromString:javaScriptString];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最近遇到一个神奇的Bug，通过&lt;code&gt;UIWebView&lt;/code&gt;的&lt;code&gt;stringByEvaluating
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>从一个AFNetworking循环引用说起</title>
    <link href="https://crmo.github.io/2018/08/28/%E4%BB%8E%E4%B8%80%E4%B8%AAAFNetworking%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E8%AF%B4%E8%B5%B7/"/>
    <id>https://crmo.github.io/2018/08/28/从一个AFNetworking循环引用说起/</id>
    <published>2018-08-27T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文分析使用代码是<a href="https://github.com/AFNetworking/AFNetworking/releases" target="_blank" rel="noopener">AFNetworking 3.2.1</a></p></blockquote><p>最近使用<code>Instruments</code>中的<code>Leaks</code>分析项目内存泄露，发现了一个AFNetworking的循环引用。如下图所示：</p><p><img src="/images/15354171666142.jpg" alt="15354171666142"></p><p>通过调用栈发现产生泄露的代码在这里：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AFURLSessionManager.m</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="comment">// ... 初始化代码，省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导致循环引用的方法</span></span><br><span class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其它初始化代码，省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致原因就是AFURLSessionManager引用NSURLSession，同时设置NSURLSession的delegate为自己，NSURLSession会强引用delegate，于是产生了循环引用。</p><blockquote><p>关于NSURLSession的delegate官方说明：<br>This delegate object is responsible for handling authentication challenges, for making caching decisions, and for handling other session-related events. The session object keeps a strong reference to this delegate until your app exits or explicitly invalidates the session. If you do not invalidate the session, your app leaks memory until it exits.</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在AFNetworking官方issues找到了相关的问题<a href="https://github.com/AFNetworking/AFNetworking/issues/1528" target="_blank" rel="noopener">Possible memory leak in AFURLSessionManager</a>。作者的回答如下：</p><p><img src="/images/15353328585634.jpg" alt="15353328585634"></p><p>解决方案有两种：</p><ol><li>这是最常见也是作者推荐的方法，只创建一个AFURLSessionManager，整个APP共享，虽然还是有循环引用，但是就没有内存泄露的问题了。</li><li>如果要使用多个AFURLSessionManager，在使用完成后手动调用<code>invalidateSessionCancelingTasks:</code>来断开循环引用。（这种方案不推荐，具体原因看下一小节）</li></ol><h2 id="AFURLSessionManager复用"><a href="#AFURLSessionManager复用" class="headerlink" title="AFURLSessionManager复用"></a>AFURLSessionManager复用</h2><p>关于AFURLSessionManager是否使用单例这个问题，官方demo使用的是单例，在苹果官方文档找到这么一段话</p><blockquote><p>With the NSURLSession API, your app creates one or more sessions, each of which coordinates a group of related data transfer tasks. For example, if you’re creating a web browser, your app might create one session per tab or window, or one session for interactive use and another for background downloads. Within each session, your app adds a series of tasks, each of which represents a request for a specific URL (following HTTP redirects, if necessary).</p></blockquote><p>我的理解是这样的，根据使用场景的不同，这个问题有不同的答案，在大多数场景下APP都是在和同一服务器打交道，一个<code>session</code>就够了，如果有连接多个服务器、或者后台下载等功能需求，可以给每个服务器、后台下载任务创建单独的<code>session</code>（但是也不能每个请求都单独创建session）。</p><p>在查找资料的时候，我发现有博客提到单例seesion可以减少TCP三次握手，动手验证下：</p><p>多个网络请求复用一个<code>AFURLSessionManager</code>，连续发两个网络请求，用<code>Wireshark</code>抓包可以看到，第二次网络请求复用了第一次的TCP连接，没有做三次握手。</p><p><img src="/images/15354191775340.jpg" alt="15354191775340"></p><p>下图是每次网络请求都新建一个<code>AFURLSessionManager</code>的抓包，可以看到每个网络请求都进行了TCP三次握手。</p><p><img src="/images/15354193039698.jpg" alt="15354193039698"></p><p>实验结果的确如网上所说，复用<code>AFURLSessionManager</code>可以减少三次握手，提升效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文分析使用代码是&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AFNetworking 3.2.1&lt;/
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS模拟器安装debug包</title>
    <link href="https://crmo.github.io/2018/08/21/iOS%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AE%89%E8%A3%85debug%E5%8C%85/"/>
    <id>https://crmo.github.io/2018/08/21/iOS模拟器安装debug包/</id>
    <published>2018-08-20T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.803Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目是Hybrid的平台，有第三方人员需要在上面开发H5应用，但是release包不能调试H5，只有debug报可以调试，但是项目源码不能交给第三方，在google搜索了下，发现一篇霜神的<a href="https://juejin.im/post/57b01f298ac247005f0acb0a" target="_blank" rel="noopener">文章</a>，讲的是debug包可以拷贝到其它机器运行，于是实践了一波。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>Xcode</li><li>Command Line Tools</li><li>ios-sim</li></ul><blockquote><p>ios-sim安装命令：npm install ios-sim -g</p></blockquote><h2 id="拷贝本地的debug包"><a href="#拷贝本地的debug包" class="headerlink" title="拷贝本地的debug包"></a>拷贝本地的debug包</h2><ol><li>run一次需要拷贝的项目，安装到模拟器上</li></ol><ol><li>执行下面命令行，需要注意的是<code>目标路径/xxx.zip</code>就是拷贝出来的debug应用包，需要替换为自己的路径，例如<code>/Users/crmo/Desktop/debug/debug.zip</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ditto -ck --sequesterRsrc --keepParent `ls -1 -d -t ~/Library/Developer/Xcode/DerivedData/*/Build/Products/*-iphonesimulator/*.app | head -n 1` 目标路径/xxx.zip</span><br></pre></td></tr></table></figure><h2 id="拷贝debug包到其它模拟器"><a href="#拷贝debug包到其它模拟器" class="headerlink" title="拷贝debug包到其它模拟器"></a>拷贝debug包到其它模拟器</h2><h3 id="1-获取模拟器列表"><a href="#1-获取模拟器列表" class="headerlink" title="1. 获取模拟器列表"></a>1. 获取模拟器列表</h3><blockquote><p>ios-sim showdevicetypes</p></blockquote><p>可以看到类似于下面的输出，就是本机可用的模拟器，选择一个需要运行的模拟器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">~ ios-sim showdevicetypes</span><br><span class="line">Apple-Watch-38mm, watchOS 4.3</span><br><span class="line">Apple-Watch-42mm, watchOS 4.3</span><br><span class="line">Apple-Watch-Series-2-38mm, watchOS 4.3</span><br><span class="line">Apple-Watch-Series-2-42mm, watchOS 4.3</span><br><span class="line">iPhone-7-Plus, 10.3</span><br><span class="line">iPhone-7-Plus, 11.4</span><br><span class="line">Apple-Watch-Series-3-38mm, watchOS 4.3</span><br><span class="line">Apple-Watch-Series-3-42mm, watchOS 4.3</span><br><span class="line">iPhone-5s, 11.4</span><br><span class="line">iPhone-6, 11.4</span><br><span class="line">iPhone-6-Plus, 11.4</span><br><span class="line">iPhone-6s, 11.4</span><br><span class="line">iPhone-6s-Plus, 11.4</span><br><span class="line">iPhone-7, 11.4</span><br><span class="line">iPhone-SE, 11.4</span><br><span class="line">iPad-Air, 11.4</span><br><span class="line">iPad-Air-2, 11.4</span><br><span class="line">iPhone-8, 11.4</span><br><span class="line">iPhone-8-Plus, 11.4</span><br><span class="line">iPhone-X, 11.4</span><br></pre></td></tr></table></figure><h3 id="2-在模拟器上启动debug包"><a href="#2-在模拟器上启动debug包" class="headerlink" title="2. 在模拟器上启动debug包"></a>2. 在模拟器上启动debug包</h3><blockquote><p>ios-sim launch 应用包路径/xxx.app –devicetypeid 模拟器</p></blockquote><p>需要说明的是，debug.zip解压后就可以得到对应应用的.app文件，例如我的debug包放在<code>/Users/crmo/Desktop/debug/debug.app</code>，模拟器选择iPhone-8，最终的命令是</p><blockquote><p>ios-sim launch /Users/crmo/Desktop/debug/debug.app –devicetypeid iPhone-8</p></blockquote><h2 id="simctl-was-not-found错误解决"><a href="#simctl-was-not-found错误解决" class="headerlink" title="simctl was not found错误解决"></a>simctl was not found错误解决</h2><p>在实践时测试机的<code>Command Line Tools</code>没有配置好，出现报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">simctl was not found.</span><br><span class="line">Check that you have Xcode 8.x installed:</span><br><span class="line">xcodebuild --versionCheck that you have Xcode 8.x selected:</span><br><span class="line">xcode-select --print-path</span><br></pre></td></tr></table></figure><p><strong>解决办法：</strong></p><p>1.首先确保正确安装了Command Line Tools，</p><blockquote><p>卸载Command Line Tools:rm -rf /Library/Developer/CommandLineTools<br>安装Command Line Tools:xcode-select –install</p></blockquote><p>2.在xcode配置一下Command Line Tools，如下图所示</p><p><img src="/images/15348328228775.jpg" alt="15348328228775"></p><hr><p>参考博客：</p><ul><li><a href="http://www.hudongdong.com/bug/772.html" target="_blank" rel="noopener">unable to find utility “simctl”的解决方案</a></li><li><a href="https://juejin.im/post/57b01f298ac247005f0acb0a" target="_blank" rel="noopener">给 iOS 模拟器 “安装”app 文件</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于项目是Hybrid的平台，有第三方人员需要在上面开发H5应用，但是release包不能调试H5，只有debug报可以调试，但是项目源码不能交给第三方，在google搜索了下，发现一篇霜神的&lt;a href=&quot;https://juejin.im/post/57b01f298
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>dispatch_sync死锁问题</title>
    <link href="https://crmo.github.io/2018/08/03/dispatch_sync%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <id>https://crmo.github.io/2018/08/03/dispatch_sync死锁问题/</id>
    <published>2018-08-02T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>使用<code>dispatch_sync</code>的时候要小心谨慎，稍不注意就会导致死锁问题，先看两个典型的案例：</p><p>案例一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)deadlock1 &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)deadlock2 &#123;</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_sync(queue1, ^&#123;</span><br><span class="line">        dispatch_sync(queue2, ^&#123;</span><br><span class="line">            dispatch_sync(queue1, ^&#123;</span><br><span class="line">                NSLog(@&quot;&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个案例死锁的原因都是同一个串行队列的任务相互等待。 当然实际工程中遇到的死锁问题会更加复杂，难以分析。</p><h2 id="典型误区"><a href="#典型误区" class="headerlink" title="典型误区"></a>典型误区</h2><p>在阅读相关书籍、博客都提到了一个方法<code>dispatch_get_current_queue()</code>，通过这个方法可以获取到当前队列，于是有人就用它来解决死锁问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)safeSync:(void(^)())block &#123;</span><br><span class="line">    if (!block) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dispatch_get_current_queue() == queue) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            block();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一眼看起来天衣无缝，对于案例一的确可以完美解决，但是对于案例二这种对队列的情况就判断不了。难怪苹果在iOS6就注释了这个方法。</p><hr><p>推荐阅读：</p><p><a href="https://www.objc.io/issues/2-concurrency/thread-safe-class-design/#pitfalls-of-gcd" target="_blank" rel="noopener">Thread-Safe Class Design</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;dispatch_sync&lt;/code&gt;的时候要小心谨慎，稍不注意就会导致死锁问题，先看两个典型的案例：&lt;/
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UIWebView获取详细浏览记录</title>
    <link href="https://crmo.github.io/2018/08/01/UIWebView%E8%8E%B7%E5%8F%96history/"/>
    <id>https://crmo.github.io/2018/08/01/UIWebView获取history/</id>
    <published>2018-07-31T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.824Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所用方法会使用到苹果私有API，上架APP Store请谨慎使用。</p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>获取<code>UIWebView</code>的前进后退的浏览记录，举个例子，比如从A-&gt;B-&gt;C-&gt;B，此时B上一页是A，下一页是C，需要获取A、C的URL信息。</p><blockquote><p>WKWebView暴露了这个属性，<code>WKBackForwardList *backForwardList</code>。可以很容易的取到，无奈项目还是使用的<code>UIWebView</code>，于是有了后面的探索。</p></blockquote><p>首先在<code>UIWebView</code>提供的API里找，相关的API只有<code>canGoBack</code>和<code>canGoForward</code>，命名很直观，是否可以后退和前进，这条路走不通。<br>想到是否可以通过JS的Window.history获取到，查了下API，唯一一个有点像的<code>length</code>属性，智能取到浏览记录中的所有URL的数量，不区分前后，比如在上面提到的例子中，在B页面取到的<code>length</code>是3，而且不能取出具体的URL。</p><p><img src="/images/15325235986699.jpg" alt="15325235986699"></p><p>无奈只有上源码了，我下载的是<a href="https://opensource.apple.com/release/ios-110.html" target="_blank" rel="noopener">“WebKit-7604.1.38.0.7”和“WebCore-7604.1.38.0.7”</a>。</p><h2 id="Window-History-length实现本质"><a href="#Window-History-length实现本质" class="headerlink" title="Window.History.length实现本质"></a>Window.History.length实现本质</h2><p>在WebCore里面找到了JS方法<code>Window.History.length</code>实现的本质，上代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebCore History.cpp</span></span><br><span class="line"><span class="keyword">unsigned</span> History::length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_frame)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span>* page = m_frame-&gt;page();</span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> page-&gt;backForward().count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebCore BackForwardController.cpp</span></span><br><span class="line"><span class="keyword">int</span> BackForwardController::count() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// count = 当前页之前的页面总数 + 当前页之后的页面总数 + 1</span></span><br><span class="line">    <span class="keyword">return</span> m_client-&gt;backListCount() + <span class="number">1</span> + m_client-&gt;forwardListCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>WebCore</code>里面<code>backListCount()</code>、<code>forwardListCount()</code>定义是虚函数，具体实现在<code>WebKit</code>可以找到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebKit BackForwardList.mm</span></span><br><span class="line"><span class="keyword">int</span> BackForwardList::backListCount()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_current == NoCurrentItemIndex ? <span class="number">0</span> : m_current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BackForwardList::forwardListCount()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_current == NoCurrentItemIndex ? <span class="number">0</span> : (<span class="keyword">int</span>)m_entries.size() - (m_current + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个方法我们需要关注一下，后面会用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebKit BackForwardList.mm</span></span><br><span class="line"><span class="comment">// 获取之前最多几条历史记录</span></span><br><span class="line"><span class="keyword">void</span> BackForwardList::backListWithLimit(<span class="keyword">int</span> limit, Vector&lt;Ref&lt;HistoryItem&gt;&gt;&amp; <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span>.clear();</span><br><span class="line">    <span class="keyword">if</span> (m_current != NoCurrentItemIndex) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> first = <span class="built_in">std</span>::max(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(m_current) - limit, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (; first &lt; m_current; ++first)</span><br><span class="line">            <span class="built_in">list</span>.append(m_entries[first].get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取History"><a href="#获取History" class="headerlink" title="获取History"></a>获取History</h2><p>在<code>WebView</code>的中，我们可以找到<code>WebBackForwardList</code>的定义。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    @property backForwardList</span></span><br><span class="line"><span class="comment">    @abstract The backforward list for this WebView.</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) WebBackForwardList *backForwardList;</span><br></pre></td></tr></table></figure><p><code>WebBackForwardList</code>是对<code>BackForwardList</code>的一层封装，阅读一下它的.h文件，不难找到获取浏览记录的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">    @method backListWithLimit:</span><br><span class="line">    @abstract Returns a portion of the list before the current entry.</span><br><span class="line">    @param limit A cap on the size of the array returned.</span><br><span class="line">    @result An array of items before the current entry, or nil if there are none.  The entries are in the order that they were originally visited.</span><br><span class="line">*/</span><br><span class="line">- (NSArray *)backListWithLimit:(int)limit;</span><br></pre></td></tr></table></figure><p>上面的方法可以获取到一个<code>WebHistoryItem</code>数组，<code>WebHistoryItem</code>保存了浏览记录的详细信息。</p><h2 id="获取WebBackForwardList"><a href="#获取WebBackForwardList" class="headerlink" title="获取WebBackForwardList"></a>获取WebBackForwardList</h2><p><code>UIWebView</code>没有暴露获取<code>WebView</code>或者<code>WebBackForwardList</code>的方法，但是我们可以用KVO曲线救国，于是我们需要找到<code>WebView</code>的私有变量名。用runtime可以做到，为了简化这个过程，我写了一个工具类来辅助搜索，具体可以看<a href="https://crmo.github.io/2018/07/31/runtime实现私有变量搜索/">这篇文章-runtime实现私有变量搜索</a>。简单来说就是用runtime获取类成员变量列表，然后用BFS来搜索我们要找的类。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以UIWebView为根节点，BFS搜索WebView</span></span><br><span class="line">[BFSSearchClass searchClass:<span class="string">@"WebView"</span> inClass:<span class="string">@"UIWebView"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索结果如下</span></span><br><span class="line"><span class="comment">// Class Name：类名，Ivar Name：变量名，Super Class：父类</span></span><br><span class="line">Class Name:【WebView】,Ivar Name:【_webView】</span><br><span class="line">Class Name:【<span class="built_in">UIWebDocumentView</span>】,Ivar Name:【Super Class】</span><br><span class="line">Class Name:【<span class="built_in">UIWebBrowserView</span>】,Ivar Name:【browserView】</span><br><span class="line">Class Name:【<span class="built_in">UIWebViewInternal</span>】,Ivar Name:【_internal】</span><br><span class="line">Root Class:<span class="built_in">UIWebView</span></span><br></pre></td></tr></table></figure><p>有了上面的结论，我们就可以用KVC来获取到浏览记录了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printWebViewHistory:(<span class="built_in">UIWebView</span> *)aWebView &#123;</span><br><span class="line">    <span class="keyword">id</span> webviewInternal = [aWebView valueForKey:<span class="string">@"_internal"</span>];</span><br><span class="line">    <span class="keyword">id</span> browserView = [webviewInternal valueForKey:<span class="string">@"browserView"</span>];</span><br><span class="line">    <span class="keyword">id</span> webView = [browserView valueForKey:<span class="string">@"_webView"</span>];</span><br><span class="line">    <span class="keyword">id</span> backForwardList = [webView performSelector:<span class="keyword">@selector</span>(backForwardList)];</span><br><span class="line">    <span class="comment">// WebHistoryItem存储的具体某条浏览记录信息</span></span><br><span class="line">    <span class="built_in">NSArray</span> *historyItems = [backForwardList performSelector:<span class="keyword">@selector</span>(backListWithLimit:) withObject:@<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> item <span class="keyword">in</span> historyItems) &#123;</span><br><span class="line">        <span class="comment">// 获取浏览记录的url </span></span><br><span class="line">        <span class="built_in">NSString</span> *url = [item performSelector:<span class="keyword">@selector</span>(URLString)];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文所用方法会使用到苹果私有API，上架APP Store请谨慎使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>runtime实现私有变量搜索</title>
    <link href="https://crmo.github.io/2018/07/31/runtime%E5%AE%9E%E7%8E%B0%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E6%90%9C%E7%B4%A2/"/>
    <id>https://crmo.github.io/2018/07/31/runtime实现私有变量搜索/</id>
    <published>2018-07-30T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.834Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文Demo(<a href="https://github.com/crmo/BFSSearchClass)地址" target="_blank" rel="noopener">https://github.com/crmo/BFSSearchClass)地址</a></p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在开发功能时，为了满足产品变态的需求，难免有系统类提供的API不够用的时候，这时候私有变量就可以发挥它光和热了。怎么通过一个类，一层一层的找到特定类型的私有成员变量？<br>受益于Objective-C的动态语言特性，就算苹果<code>UIKit</code>不开源，但是在runtime面前，类的结构还是暴露无遗。我的思路是逐层手动打印成员变量信息，如果是UI控件可以用Reveal来加快进度，配合KVC机制，获取私有变量就如同探囊取物一般。<br>在多次遇到这个问题后，我决定实现一个工具类来简化这个过程，毕竟能自动化的就尽量不要手动。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>搜索范围：成员变量、属性</p></blockquote><p>关键步骤如下：</p><ol><li>runtime中的方法<code>class_copyIvarList()</code>，可以取出类的所有成员变量结构体<code>Ivar</code>。</li><li>从Ivar中可以取出成员变量类型<code>Type Encodings</code></li><li>用<code>Type Encodings</code>获取到类名</li><li>遍历类的所有<code>Ivar</code>，获取到类的所有成员变量的类信息</li></ol><p>但是问题没这么简单，比如ClassA是ClassB的成员变量，ClassB是ClassC的成员变量，想通过ClassC找到ClassA，需要向下找两层才能找到，还要考虑父类的情况。<br>整个搜索过程就是一颗以待搜索类为根的树，可以用BFS来搜索，步骤如下（如图，数字是搜索顺序）：</p><ol><li>从根节点开始搜索</li><li>首先遍历当前节点的父类，加入搜索队列</li><li>再取出当前节点的所有成员变量，加入搜索队列</li></ol><p><img src="/images/QQ20180731-202956@2x.png" alt="QQ20180731-202956@2x"></p><h2 id="如何从Ivar中获取Class"><a href="#如何从Ivar中获取Class" class="headerlink" title="如何从Ivar中获取Class"></a>如何从Ivar中获取Class</h2><p>Ivar中不能直接取出对应类名，只能取出<code>Type Encodings</code>，间接可以得到类名。从<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">官方文档</a>截了张图，可以清晰的看到Code的定义。</p><p><img src="/images/15329163411347.jpg" alt="15329163411347"></p><p>基本数据类型、id类型、集合类型、结构体等类型就不需要搜索了，可以过滤掉。我们只搜索两种类型</p><ol><li>类，例如<code>@&quot;UIWebViewInternal&quot;</code></li><li>代理，例如<code>@&quot;&lt;UIViewControllerTransitioningDelegate&gt;&quot;</code></li></ol><h2 id="优化及存在问题"><a href="#优化及存在问题" class="headerlink" title="优化及存在问题"></a>优化及存在问题</h2><ol><li>可以用一个<code>NSMutableSet</code>存储已经搜索过的类，每次搜索前判断一下是否已经搜索过</li><li>记录搜索次数，可以限制搜索次数。</li><li>对于定义为id类型、集合类的成员变量没有做处理，可以继续深入遍历</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文Demo(&lt;a href=&quot;https://github.com/crmo/BFSSearchClass)地址&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/crmo/BFSSearchC
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS横竖屏总结</title>
    <link href="https://crmo.github.io/2018/07/23/iOS%E6%A8%AA%E7%AB%96%E5%B1%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://crmo.github.io/2018/07/23/iOS横竖屏总结/</id>
    <published>2018-07-22T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.843Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>Auto Layout</code>来进行布局就不用自己去监听横竖屏事件了，只需要绘制多套布局即可。但是项目有很多页面是自己手动计算的，于是只有想办法再旋转屏幕时重新布局。</p><h2 id="相关枚举"><a href="#相关枚举" class="headerlink" title="相关枚举"></a>相关枚举</h2><p>屏幕方向有3个相关枚举，界面方向<code>UIInterfaceOrientation</code>，设备方向<code>UIDeviceOrientation</code>，支持旋转方向<code>UIInterfaceOrientationMask</code>。</p><blockquote><p>注意UIInterfaceOrientation与UIDeviceOrientation左右方向是相反的</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIInterfaceOrientation</span>) &#123;</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationUnknown</span>            = <span class="built_in">UIDeviceOrientationUnknown</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationPortrait</span>           = <span class="built_in">UIDeviceOrientationPortrait</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationPortraitUpsideDown</span> = <span class="built_in">UIDeviceOrientationPortraitUpsideDown</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationLandscapeLeft</span>      = <span class="built_in">UIDeviceOrientationLandscapeRight</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationLandscapeRight</span>     = <span class="built_in">UIDeviceOrientationLandscapeLeft</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIInterfaceOrientationMask</span>) &#123;</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskPortrait</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationPortrait</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationLandscapeLeft</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationLandscapeRight</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskPortraitUpsideDown</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationPortraitUpsideDown</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscape</span> = (<span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskAll</span> = (<span class="built_in">UIInterfaceOrientationMaskPortrait</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span> | <span class="built_in">UIInterfaceOrientationMaskPortraitUpsideDown</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskAllButUpsideDown</span> = (<span class="built_in">UIInterfaceOrientationMaskPortrait</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="横竖屏控制"><a href="#横竖屏控制" class="headerlink" title="横竖屏控制"></a>横竖屏控制</h2><p>控制界面横竖屏切换有3个重要的点，最终结果以这三个地方的值取交集。</p><p><strong>1.info.plist全局控制</strong></p><p>可以在<code>General-&gt;Deplyment Info</code>界面上勾选</p><p><img src="/images/15320065885480.jpg" alt="15320065885480"></p><p> info.plist文件中配置也是一样的，两边会同步变更</p><p><img src="/images/15320512384395.jpg" alt="15320512384395"></p><p><strong>2.AppDelegate中根据不同Window控制</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppDelegate</span></span><br><span class="line">- (<span class="built_in">UIInterfaceOrientationMask</span>)application:(<span class="built_in">UIApplication</span> *)application supportedInterfaceOrientationsForWindow:(<span class="built_in">UIWindow</span> *)window &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskPortrait</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.在ViewController中控制当前页面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// UIViewController</span><br><span class="line">- (BOOL)shouldAutorotate &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</span><br><span class="line">    return UIInterfaceOrientationMaskLandscapeLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，交集不能为空，否则会导致crash</p></blockquote><p>*** Terminating app due to uncaught exception ‘UIApplicationInvalidInterfaceOrientation’, reason: ‘Supported orientations has no common orientation with the application, and [ViewController<br>shouldAutorotate] is returning YES’</p><p><img src="/images/15320548897266-1.jpg" alt="15320548897266"></p><h2 id="旋转事件监听"><a href="#旋转事件监听" class="headerlink" title="旋转事件监听"></a>旋转事件监听</h2><h3 id="旋转事件传递过程"><a href="#旋转事件传递过程" class="headerlink" title="旋转事件传递过程"></a>旋转事件传递过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">op0=&gt;operation: __CFRunLoopDoSources0</span><br><span class="line">op1=&gt;operation: UIDevice</span><br><span class="line">op2=&gt;operation: UIWindow</span><br><span class="line">op3=&gt;operation: UIViewController</span><br><span class="line">op4=&gt;operation: UIView</span><br><span class="line"></span><br><span class="line">op1-&gt;op2-&gt;op3-&gt;op4</span><br></pre></td></tr></table></figure><h3 id="屏幕旋转相关事件"><a href="#屏幕旋转相关事件" class="headerlink" title="屏幕旋转相关事件"></a>屏幕旋转相关事件</h3><p>viewWillTransitionToSize:withTransitionCoordinator:</p><ul><li>ViewController被父容器变更size时调用（例如window旋转时调用root view controller的该方法）</li><li>如果重载该方法，需要调用super传递事件给子ViewController</li><li>这个方法是最关键的，可以在该方法中对界面进行重新布局</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator</span><br><span class="line">&#123;</span><br><span class="line">    // coordinator用来处理转换动画</span><br><span class="line">    [coordinator animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context)</span><br><span class="line">     &#123;</span><br><span class="line">         // 开始旋转</span><br><span class="line">     &#125; completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context)</span><br><span class="line">     &#123;</span><br><span class="line">         // 旋转结束</span><br><span class="line">     &#125;];</span><br><span class="line">     // 记得调用super</span><br><span class="line">    [super viewWillTransitionToSize:size withTransitionCoordinator:coordinator];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UIApplicationWillChangeStatusBarOrientationNotification </p><ul><li>状态栏将要旋转，这个时候取view的frame还是旋转之前的</li><li>NSNotification中用key <code>UIApplicationStatusBarOrientationUserInfoKey</code>可以取到将要旋转到的方向。</li></ul><p>UIApplicationDidChangeStatusBarOrientationNotification </p><ul><li>状态栏已经旋转，这个时候取view的frame是旋转之后的</li><li>NSNotification中用key <code>UIApplicationStatusBarOrientationUserInfoKey</code>可以取到旋转之前的方向。</li></ul><p>UIDeviceOrientationDidChangeNotification </p><ul><li>设备方向变更，在收到通知时取view的frame是旋转之后的。</li><li>在手机上将旋转屏幕锁定之后，设备方向变更之后收不到该通知</li><li>在代码里面限制设备旋转方向，设备方向变更后依然能收到该通知</li></ul><p>调用顺序如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 旋转屏幕</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op1=&gt;operation: viewWillTransitionToSize:withTransitionCoordinator:</span><br><span class="line">op2=&gt;operation: UIApplicationWillChangeStatusBarOrientationNotification</span><br><span class="line">op3=&gt;operation: UIApplicationDidChangeStatusBarOrientationNotification</span><br><span class="line">op4=&gt;operation: viewWillLayoutSubviews</span><br><span class="line">op5=&gt;operation: viewDidLayoutSubviews</span><br><span class="line">op6=&gt;operation: UIDeviceOrientationDidChangeNotification</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;e</span><br></pre></td></tr></table></figure><h2 id="自定义Window的旋转事件"><a href="#自定义Window的旋转事件" class="headerlink" title="自定义Window的旋转事件"></a>自定义Window的旋转事件</h2><p>如果想要在自定义Window的子View收到屏幕旋转通知，要设置UIWindow的rootViewController，然后把所有子view都加到rootViewController，系统会处理横竖屏事件。这里我还遇到一个坑<a href="https://crmo.github.io/2018/07/19/记一个实现UIWindow子类的小坑/">记一个实现UIWindow子类的小坑</a>。</p><hr><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://satanwoo.github.io/2016/09/17/uiwindow-iOS/" target="_blank" rel="noopener">https://satanwoo.github.io/2016/09/17/uiwindow-iOS/</a><br><a href="https://tbd.ink/2017/07/05/iOS/17070501.iOS屏幕旋转知识点以及实现/index/" target="_blank" rel="noopener">iOS屏幕旋转知识点以及实现</a><br><a href="https://imtangqi.com/2017/03/08/handle-orientation-changes-one/" target="_blank" rel="noopener">iOS 屏幕旋转的那些事（一）</a><br><a href="https://satanwoo.github.io/2016/09/17/uiwindow-iOS/" target="_blank" rel="noopener">浅谈iOS的多Window处理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用&lt;code&gt;Auto Layout&lt;/code&gt;来进行布局就不用自己去监听横竖屏事件了，只需要绘制多套布局即可。但是项目有很多页面是自己手动计算的，于是只有想办法再旋转屏幕时重新布局。&lt;/p&gt;
&lt;h2 id=&quot;相关枚举&quot;&gt;&lt;a href=&quot;#相关枚举&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>记一个实现UIWindow子类的小坑</title>
    <link href="https://crmo.github.io/2018/07/19/%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0UIWindow%E5%AD%90%E7%B1%BB%E7%9A%84%E5%B0%8F%E5%9D%91/"/>
    <id>https://crmo.github.io/2018/07/19/记一个实现UIWindow子类的小坑/</id>
    <published>2018-07-18T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>项目中为了实现一个全局遮罩界面，使用了一个UIWindow的子类<code>MyWindow</code>，<code>MyWindow</code>为了实现回调定义了代理<code>MyWindowDelegate</code>。代码大致如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MyWindowDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyWindow</span> : <span class="title">UIWindow</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>)<span class="keyword">id</span>&lt;MyWindowDelegate&gt; delegate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyWindow</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.windowLevel = <span class="built_in">UIWindowLevelNormal</span>;</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        <span class="built_in">UIViewController</span> *vc = [[ViewController2 alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.rootViewController = vc;</span><br><span class="line">        <span class="keyword">self</span>.hidden = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后在实现界面横屏时，发现整个UIWindow不响应横竖屏事件。刚开始以为横竖屏设置被关闭了，查了各种资料，发现这种写法是没有问题的。设置UIWindow的rootViewController，然后把所有子view都加到rootViewController，系统会处理横竖屏问题。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>用Runtime把UIWindow的私有变量打出来，就发现问题了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printUIWindowIvars &#123;</span><br><span class="line">    Ivar *ivars = class_copyIvarList([<span class="built_in">UIWindow</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, ivar_getName(ivar));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看输出，发现有个私有变量<code>_delegate</code>。</p><p><img src="/images/15319834677166.jpg" alt="15319834677166"></p><p><code>MyWindow</code>的属性<code>delegate</code>覆盖了父类<code>UIWindow</code>的变量，导致横竖屏切换事件失效。在代理命名的时候一定要注意啊，<code>delegate</code>看来不是一个好的实践，应该加前缀区分避免覆盖父类的实现，特别是这种私有的变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;项目中为了实现一个全局遮罩界面，使用了一个UIWindow的子类&lt;code&gt;MyWindow&lt;/code&gt;，&lt;code&gt;My
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>一个autoreleasepool的使用场景</title>
    <link href="https://crmo.github.io/2018/07/18/%E4%B8%80%E4%B8%AAautoreleasepool%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://crmo.github.io/2018/07/18/一个autoreleasepool的使用场景/</id>
    <published>2018-07-17T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.861Z</updated>
    
    <content type="html"><![CDATA[<p>今天在学习大佬博客的时候看到一个问题，下面代码会有什么问题？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// largeNumber是一个很大的数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; largeNumber; i++) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"hello -%04d"</span>, i];</span><br><span class="line">    str = [str stringByAppendingString:<span class="string">@" - world"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始没看出什么问题，就是普通的循环，每次循环创建一个局部变量<code>NSString</code>。于是写了个Demo验证了下，在观察内存的时候发现了端倪，在循环过程中，内存不断飙升。</p><p><img src="/images/15318782609811.jpg" alt="15318782609811"></p><p>顿时明白了，原来问题的关键就是这个<code>largeNumber</code>，当循环此时很大时，就会创建大量的局部变量，而且得不到释放，于是内存就爆了。这时候就该<code>@autoreleasepool</code>上场了，优化后代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; largeNumber; i++) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"hello -%04d"</span>, i];</span><br><span class="line">        str = [str stringByAppendingString:<span class="string">@" - world"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看运行内存，可以看到非常平稳。</p><p><img src="/images/15318784002251.jpg" alt="15318784002251"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在学习大佬博客的时候看到一个问题，下面代码会有什么问题？&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UITabbar自定义Badge</title>
    <link href="https://crmo.github.io/2018/07/10/UITabbar%E8%87%AA%E5%AE%9A%E4%B9%89Badge/"/>
    <id>https://crmo.github.io/2018/07/10/UITabbar自定义Badge/</id>
    <published>2018-07-09T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.882Z</updated>
    
    <content type="html"><![CDATA[<p>tabBarItem的Badge默认样式是带数字的，但是产品要求只要一个小红点，不需要数字，这就需要我们自定义Badge了。</p><p>用Reveal分析UITabBar，发现每个按钮是一个<code>UITabBarButton</code>，层级如下：</p><blockquote><p>-UITabBarButton<br>–UITabBarSwappableImageView // 图标<br>–UITabBarButtonLabel // 文字</p></blockquote><p>如何从<code>UITabBar</code>中找到对应index的<code>UITabBarButton</code>呢？我们断点调试下，可以看到可以直接从<code>UITabBar</code>中用KVC取出。</p><p><img src="/images/QQ20180711-174329.png" alt="QQ20180711-174329"></p><p>实现方案如下：</p><ul><li>用KVC找到UITabBarSwappableImageView，关键函数<code>__iconViewWithIndex</code></li><li>新建Badge，加到UITabBarSwappableImageView上</li><li>新建Badge的时候设置Tag，通过Tag来移除Badge</li></ul><p>上代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kBadgeViewTagBase = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITabBar</span> (<span class="title">badge</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示Badge</span></span><br><span class="line">- (<span class="keyword">void</span>)showBadgeOnItemIndex:(<span class="keyword">int</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="keyword">self</span>.items.count) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果之前添加过，直接设置hidden为NO</span></span><br><span class="line">    <span class="built_in">UIView</span> *icon = [<span class="keyword">self</span> __iconViewWithIndex:index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subView <span class="keyword">in</span> icon.subviews) &#123;</span><br><span class="line">        <span class="keyword">if</span> (subView.tag == kBadgeViewTagBase) &#123;</span><br><span class="line">            subView.hidden = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *badgeView = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    badgeView.tag = kBadgeViewTagBase;</span><br><span class="line">    badgeView.layer.cornerRadius = <span class="number">5</span>;</span><br><span class="line">    badgeView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    badgeView.frame = <span class="built_in">CGRectMake</span>(icon.frame.size.width - <span class="number">5</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">9</span>);</span><br><span class="line">    [icon addSubview:badgeView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏Badge</span></span><br><span class="line">- (<span class="keyword">void</span>)hideBadgeOnItemIndex:(<span class="keyword">int</span>)index &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *icon = [<span class="keyword">self</span> __iconViewWithIndex:index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subView <span class="keyword">in</span> icon.subviews) &#123;</span><br><span class="line">        <span class="keyword">if</span> (subView.tag == kBadgeViewTagBase) &#123;</span><br><span class="line">            subView.hidden = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取图标所在View</span></span><br><span class="line">- (<span class="built_in">UIView</span> *)__iconViewWithIndex:(<span class="keyword">int</span>)index &#123;</span><br><span class="line">    <span class="built_in">UITabBarItem</span> *item = <span class="keyword">self</span>.items[index];</span><br><span class="line">    <span class="built_in">UIView</span> *tabBarButton = [item valueForKey:<span class="string">@"_view"</span>];</span><br><span class="line">    <span class="built_in">UIView</span> *icon = [tabBarButton valueForKey:<span class="string">@"_info"</span>];</span><br><span class="line">    <span class="keyword">return</span> icon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tabBarItem的Badge默认样式是带数字的，但是产品要求只要一个小红点，不需要数字，这就需要我们自定义Badge了。&lt;/p&gt;
&lt;p&gt;用Reveal分析UITabBar，发现每个按钮是一个&lt;code&gt;UITabBarButton&lt;/code&gt;，层级如下：&lt;/p&gt;
&lt;b
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>计算文字长度</title>
    <link href="https://crmo.github.io/2018/07/09/%E8%AE%A1%E7%AE%97%E6%96%87%E5%AD%97%E9%95%BF%E5%BA%A6/"/>
    <id>https://crmo.github.io/2018/07/09/计算文字长度/</id>
    <published>2018-07-08T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.871Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://developer.apple.com/documentation/foundation/nsstring/1524729-boundingrectwithsize?language=occ" target="_blank" rel="noopener">官方文档</a></p></blockquote><h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSRect</span>)boundingRectWithSize:(<span class="built_in">NSSize</span>)size </span><br><span class="line">                       options:(<span class="built_in">NSStringDrawingOptions</span>)options </span><br><span class="line">                    attributes:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSAttributedStringKey</span>, <span class="keyword">id</span>&gt; *)attributes </span><br><span class="line">                       context:(<span class="built_in">NSStringDrawingContext</span> *)context;</span><br></pre></td></tr></table></figure><h2 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h2><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>绘制的限制size，计算出来的值不会超过这个大小。</p><h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><p>一些配置项。定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSStringDrawingOptions</span>) &#123;</span><br><span class="line">    <span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">// The specified origin is the line fragment origin, not the base line origin</span></span><br><span class="line">    <span class="built_in">NSStringDrawingUsesFontLeading</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">// Uses the font leading for calculating line heights</span></span><br><span class="line">    <span class="built_in">NSStringDrawingUsesDeviceMetrics</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">// Uses image glyph bounds instead of typographic bounds</span></span><br><span class="line">    <span class="built_in">NSStringDrawingTruncatesLastVisibleLine</span> <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">6</span>_0) = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">// Truncates and adds the ellipsis character to the last visible line if the text doesn't fit into the bounds specified. Ignored if NSStringDrawingUsesLineFragmentOrigin is not also set.</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">6</span>_0);</span><br></pre></td></tr></table></figure><p>实际测试使用<code>NSStringDrawingUsesLineFragmentOrigin|NSStringDrawingUsesFontLeading</code>可以满足需求，<code>NSStringDrawingUsesLineFragmentOrigin</code>是必须的，<code>NSStringDrawingUsesFontLeading</code>加不加在测试的时候没发现区别，但是在<a href="https://stackoverflow.com/questions/13621084/boundingrectwithsize-for-nsattributedstring-returning-wrong-size/15399767#15399767" target="_blank" rel="noopener">stackoverflow相关讨论</a>里加上了，留个坑，后面知道为什么了来补充吧。</p><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><p>字体</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>上下文</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>如果是多行文字，options要加上<code>NSStringDrawingUsesLineFragmentOrigin</code></li><li>返回的值是小数，需要调用<code>ceil</code>向上取整</li><li>得到的宽度可能比实际宽</li></ol><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">CGSize</span>)getTextLabelSize:(<span class="built_in">NSString</span> *)message &#123;</span><br><span class="line">    <span class="keyword">if</span> ([message length] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 文本框的最大宽度</span></span><br><span class="line">        <span class="keyword">float</span> maxWidth = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">CGRect</span> textRect = [message</span><br><span class="line">                           boundingRectWithSize:<span class="built_in">CGSizeMake</span>(maxWidth, <span class="built_in">CGFLOAT_MAX</span>)</span><br><span class="line">                           options:(<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> |</span><br><span class="line">                                    <span class="built_in">NSStringDrawingUsesFontLeading</span>)</span><br><span class="line">                           attributes:@&#123;</span><br><span class="line">                                        <span class="built_in">NSFontAttributeName</span> :</span><br><span class="line">                                            [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">16</span>]</span><br><span class="line">                                        &#125;</span><br><span class="line">                           context:<span class="literal">nil</span>];</span><br><span class="line">        textRect.size.height = ceilf(textRect.size.height);</span><br><span class="line">        textRect.size.width = ceilf(textRect.size.width);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGSizeMake</span>(textRect.size.width, textRect.size.height);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGSizeZero</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring/1524729-boundingrectwithsize?language=occ&quot; target=&quot;_b
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UITextField控制输入长度</title>
    <link href="https://crmo.github.io/2018/07/06/UITextField%E6%8E%A7%E5%88%B6%E8%BE%93%E5%85%A5%E9%95%BF%E5%BA%A6/"/>
    <id>https://crmo.github.io/2018/07/06/UITextField控制输入长度/</id>
    <published>2018-07-05T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.894Z</updated>
    
    <content type="html"><![CDATA[<p>有些时候会有控制输入框文字长度的需求，记录一个简单的思路。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)textField:(<span class="built_in">UITextField</span> *)textField shouldChangeCharactersInRange:(<span class="built_in">NSRange</span>)range replacementString:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    <span class="keyword">if</span> (string.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> limit = <span class="number">15</span>; <span class="comment">// 文本的最大长度</span></span><br><span class="line">    <span class="built_in">NSString</span> *newStr = [textField.text stringByAppendingString:string]; <span class="comment">// 修改之后的新字符串</span></span><br><span class="line">    <span class="built_in">NSInteger</span> newStrLength = newStr.length;</span><br><span class="line">    newStrLength -= [textField textInRange:[textField markedTextRange]].length; <span class="comment">// 去掉高亮内容，输入中文拼音的情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newStrLength &gt; limit) &#123;</span><br><span class="line">        <span class="comment">// 处理composed character, 比如emoji</span></span><br><span class="line">        <span class="built_in">NSString</span> *tempStr = [newStr substringWithRange:[newStr rangeOfComposedCharacterSequencesForRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, limit)]];</span><br><span class="line">        textField.text = tempStr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个坑注意下：</p><ol><li>emoji是<code>composed character</code>，它是由多个字符组合，长度不是1。最开始用的<code>substringToIndex</code>会导致最后一个emoji乱码。</li><li>计算长度的时候要去掉中文输入的时候高亮部分</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有些时候会有控制输入框文字长度的需求，记录一个简单的思路。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>property or synthsize</title>
    <link href="https://crmo.github.io/2018/07/05/property%20or%20synthsize/"/>
    <id>https://crmo.github.io/2018/07/05/property or synthsize/</id>
    <published>2018-07-04T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.910Z</updated>
    
    <content type="html"><![CDATA[<p>@property (nonatomic, retain) NSObject *var;</p><ul><li>生成var的set、get方法的方法声明</li><li>生成var的set、get方法的实现（<strong>早期版本编译器不生成</strong>）</li><li>生成成员变量_var（<strong>早期版本编译器不生成</strong>）</li></ul><p>@synthsize var = _var</p><ul><li>生成var的set、get方法的实现</li><li>生成var对应的成员变量_var</li></ul><blockquote><p>mrc年代的get、set方法的写法</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setVar:(<span class="built_in">NSObject</span> *)var &#123;</span><br><span class="line">    <span class="keyword">if</span> (_var != var) &#123; <span class="comment">// 如果多次set同一个对象，如果不判断会导致对象被释放</span></span><br><span class="line">        <span class="comment">// 释放之前的var</span></span><br><span class="line">        [_var release];</span><br><span class="line">        _var = [var <span class="keyword">retain</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSObject</span> *)var &#123;</span><br><span class="line">    <span class="keyword">return</span> _var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@property (nonatomic, retain) NSObject *var;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成var的set、get方法的方法声明&lt;/li&gt;
&lt;li&gt;生成var的set、get方法的实现（&lt;strong&gt;早期版本编译器不生成&lt;/strong&gt;）&lt;/
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Tagged Pointer小记</title>
    <link href="https://crmo.github.io/2018/07/04/Tagged%20Pointer%E5%B0%8F%E8%AE%B0/"/>
    <id>https://crmo.github.io/2018/07/04/Tagged Pointer小记/</id>
    <published>2018-07-03T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.998Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文使用的测试环境是arm64架构真机</p></blockquote><p>为了探究Tagged Pointer本质，可以查看runtime源码，主要看文件<code>objc-internal.h</code>。</p><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>可以看到以下宏定义，只有在64位系统才支持<code>Tagged Pointer</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJC_HAVE_TAGGED_POINTERS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>64-bit的mac，tag存储在LSB（Least Significant Bit 最低位）。其它情况比如64位的真机和模拟器，tag存储在MSB（Most Significant Bit 最高位）。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if TARGET_OS_OSX &amp;&amp; __x86_64__</span></span><br><span class="line">    <span class="comment">// 64-bit Mac - tag bit is LSB</span></span><br><span class="line"><span class="meta">#   define OBJC_MSB_TAGGED_POINTERS 0</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="comment">// Everything else - tag bit is MSB</span></span><br><span class="line"><span class="meta">#   define OBJC_MSB_TAGGED_POINTERS 1</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if OBJC_MSB_TAGGED_POINTERS</span></span><br><span class="line"><span class="meta">#   define _OBJC_TAG_MASK (1UL<span class="meta-string">&lt;&lt;63)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_INDEX_SHIFT 60</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_SLOT_SHIFT 60</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_PAYLOAD_LSHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_PAYLOAD_RSHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_MASK (0xfUL&lt;&lt;60)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_INDEX_SHIFT 52</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_SLOT_SHIFT 52</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 12</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#else</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_MASK 1UL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_INDEX_SHIFT 1</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_SLOT_SHIFT 0</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_PAYLOAD_LSHIFT 0</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_PAYLOAD_RSHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_MASK 0xfUL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_INDEX_SHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_SLOT_SHIFT 4</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 0</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#endif</span></span></span><br></pre></td></tr></table></figure><p>接下来是一个枚举定义，定义了默认的使用<code>Tagged Pointer</code>的类。例如NSString、NSNumber、NSIndexPath、NSDate（OBJC_TAG_NSAtom、OBJC_TAG_1、OBJC_TAG_NSManagedObjectID不知道是啥意思，还请知道的同学告诉我）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">objc_tag_index_t</span> : <span class="keyword">uint16_t</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    OBJC_TAG_NSAtom            = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_1                 = <span class="number">1</span>, </span><br><span class="line">    OBJC_TAG_NSString          = <span class="number">2</span>, </span><br><span class="line">    OBJC_TAG_NSNumber          = <span class="number">3</span>, </span><br><span class="line">    OBJC_TAG_NSIndexPath       = <span class="number">4</span>, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID = <span class="number">5</span>, </span><br><span class="line">    OBJC_TAG_NSDate            = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_RESERVED_7        = <span class="number">7</span>, </span><br><span class="line"></span><br><span class="line">    OBJC_TAG_First60BitPayload = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_Last60BitPayload  = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_First52BitPayload = <span class="number">8</span>, </span><br><span class="line">    OBJC_TAG_Last52BitPayload  = <span class="number">263</span>, </span><br><span class="line"></span><br><span class="line">    OBJC_TAG_RESERVED_264      = <span class="number">264</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><p>判断是不是<code>Tagged Pointer</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_objc_isTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成一个<code>Tagged Pointer</code>，最高的4位是tagged，剩下的是数据</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> * _Nonnull</span><br><span class="line">_objc_makeTaggedPointer(objc_tag_index_t tag, uintptr_t value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag &lt;= OBJC_TAG_Last60BitPayload) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)</span><br><span class="line">            (_OBJC_TAG_MASK | </span><br><span class="line">             ((uintptr_t)tag &lt;&lt; _OBJC_TAG_INDEX_SHIFT) | </span><br><span class="line">             ((value &lt;&lt; _OBJC_TAG_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_LSHIFT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)</span><br><span class="line">            (_OBJC_TAG_EXT_MASK |</span><br><span class="line">             ((uintptr_t)(tag - OBJC_TAG_First52BitPayload) &lt;&lt; _OBJC_TAG_EXT_INDEX_SHIFT) |</span><br><span class="line">             ((value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>Tagged Pointer</code>中取出值</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uintptr_t</span><br><span class="line">_objc_getTaggedPointerValue(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class="line">    uintptr_t basicTag = ((uintptr_t)ptr &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class="line">    <span class="keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((uintptr_t)ptr &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((uintptr_t)ptr &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NSNumber应用举例"><a href="#NSNumber应用举例" class="headerlink" title="NSNumber应用举例"></a>NSNumber应用举例</h2><p>可以使用下面代码来验证NSNumber如何使用<code>Tagged Pointer</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *charNumber = [<span class="built_in">NSNumber</span> numberWithChar:<span class="string">'1'</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *shortNumber = [<span class="built_in">NSNumber</span> numberWithShort:<span class="number">1</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *intNumber = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *floatNumber = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.0</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *longNumber = [<span class="built_in">NSNumber</span> numberWithLong:<span class="number">1</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *doubleNumber = [<span class="built_in">NSNumber</span> numberWithDouble:<span class="number">1.0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出变量的指针地址：</span></span><br><span class="line"><span class="comment">// charNumber 0xb000000000000310</span></span><br><span class="line"><span class="comment">// shortNumber 0xb000000000000011</span></span><br><span class="line"><span class="comment">// intNumber 0xb000000000000012</span></span><br><span class="line"><span class="comment">// floatNumber 0xb000000000000014</span></span><br><span class="line"><span class="comment">// longNumber 0xb000000000000013</span></span><br><span class="line"><span class="comment">// doubleNumber 0xb000000000000015</span></span><br></pre></td></tr></table></figure><p>不难发现规律，都是以b(1011)开头</p><ul><li>最高位是1，说明这个指针是一个<code>Tagged Pointer</code></li><li>第61-63位是11（十进制是3），也就是<code>OBJC_TAG_NSNumber</code>（查上面的枚举）</li><li>第1-4位是NSNumber的类型：比如，char是0、short是1、int是2、float是4</li><li>剩下的56位就是真正的值了</li></ul><h2 id="NSString应用举例"><a href="#NSString应用举例" class="headerlink" title="NSString应用举例"></a>NSString应用举例</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str1 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"a"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"ab"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出变量的指针地址：</span></span><br><span class="line"><span class="comment">// str1: 0xa000000000000611</span></span><br><span class="line"><span class="comment">// str2: 0xa000000000062612</span></span><br></pre></td></tr></table></figure><p>与NSNumber类似</p><ul><li>最高位是1，说明这个指针是一个<code>Tagged Pointer</code></li><li>第61-63位是11（十进制是2），也就是<code>OBJC_TAG_NSString</code></li><li>第1-4位是字符串长度</li><li>剩下的56位就是真正的值了</li></ul><blockquote><p>更多细节推荐这篇文章<a href="http://www.cocoachina.com/ios/20150918/13449.html" target="_blank" rel="noopener">采用Tagged Pointer的字符串</a></p></blockquote><hr><p>参考文章</p><ul><li><a href="https://www.jianshu.com/p/e354f9137ba8" target="_blank" rel="noopener">iOS Tagged Pointer</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" target="_blank" rel="noopener">wiki</a></li><li><a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer" target="_blank" rel="noopener">深入理解Tagged Pointer</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文使用的测试环境是arm64架构真机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了探究Tagged Pointer本质，可以查看runtime源码，主要看文件&lt;code&gt;objc-internal.h&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;宏
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
</feed>
