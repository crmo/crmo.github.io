<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CR.MO`s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://crmo.github.io/"/>
  <updated>2019-06-16T03:55:13.816Z</updated>
  <id>https://crmo.github.io/</id>
  
  <author>
    <name>CR.MO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GCD 解决生产者消费者问题</title>
    <link href="https://crmo.github.io/2019/06/16/GCD%20%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/"/>
    <id>https://crmo.github.io/2019/06/16/GCD 解决生产者消费者问题/</id>
    <published>2019-06-15T16:00:00.000Z</published>
    <updated>2019-06-16T03:55:13.816Z</updated>
    
    <content type="html"><![CDATA[<p>说起生产者消费者问题（Producer-consumer problem），相信大家都印象深刻，有遗忘可以看看<a href="https://zh.wikipedia.org/wiki/生产者消费者问题#使用信号灯的算法" target="_blank" rel="noopener">wiki</a>上的解释，我们今天来聊聊怎么用 GCD 实现一个生产者消费者模型。</p><p>我们先理一下思路，看看问题关键点：</p><ol><li>生产者生成产品放到缓冲区中，然后重复此过程，但是生产的产品数量不能超过缓冲区大小，如果缓冲区满了，停止生产新的产品，等待缓冲区有空位；</li><li>消费者不停从缓冲区取出产品，如果缓冲区空了，则停止消费，等待新的产品放到缓冲区中；</li></ol><p>很容易就联想到信号量 <code>dispatch_semaphore_t</code> ，我们需要使用两个信号量分别控制<code>生产者</code>与<code>消费者</code>，<code>semaphoreProduce</code> 控制生产者当缓冲区满时停止生产，<code>semaphoreConsume</code> 控制消费者当缓冲区空时停止消费。如下图所示（配图纯手工制作，轻喷😂）：</p><p><img src="/images/IMG_0010.jpg" alt="灵魂画手配图✌️"></p><p>Show me the code.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 控制生产者的信号量</span><br><span class="line">dispatch_semaphore_t semaphoreProduce;</span><br><span class="line">// 控制消费者的信号量</span><br><span class="line">dispatch_semaphore_t semaphoreConsume;</span><br><span class="line">// 当前产品数量</span><br><span class="line">int productCount = 0;</span><br><span class="line">// 缓冲区大小</span><br><span class="line">const int bufferSize = 5;</span><br><span class="line"></span><br><span class="line">// 初始化生产者、消费者信号量</span><br><span class="line">- (void)initProducerAndConsume &#123;</span><br><span class="line">    // 初始化缓冲区大小</span><br><span class="line">    semaphoreProduce = dispatch_semaphore_create(bufferSize);</span><br><span class="line">    semaphoreConsume = dispatch_semaphore_create(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生产商品</span><br><span class="line">- (void)produce &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphoreProduce, DISPATCH_TIME_FOREVER);</span><br><span class="line">        [NSThread sleepForTimeInterval:1];</span><br><span class="line">        productCount++;</span><br><span class="line">        NSLog(@&quot;生产商品，商品总量：%d&quot;, productCount);</span><br><span class="line">        dispatch_semaphore_signal(semaphoreConsume);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消费商品</span><br><span class="line">- (void)consume &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphoreConsume, DISPATCH_TIME_FOREVER);</span><br><span class="line">        [NSThread sleepForTimeInterval:1];</span><br><span class="line">        productCount--;</span><br><span class="line">        NSLog(@&quot;消费商品，商品总量：%d&quot;, productCount);</span><br><span class="line">        dispatch_semaphore_signal(semaphoreProduce);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说起生产者消费者问题（Producer-consumer problem），相信大家都印象深刻，有遗忘可以看看&lt;a href=&quot;https://zh.wikipedia.org/wiki/生产者消费者问题#使用信号灯的算法&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iOSer 大厂 Offer 攻略</title>
    <link href="https://crmo.github.io/2019/06/16/iOSer%20%E5%A4%A7%E5%8E%82%20Offer%20%E6%94%BB%E7%95%A5/"/>
    <id>https://crmo.github.io/2019/06/16/iOSer 大厂 Offer 攻略/</id>
    <published>2019-06-15T16:00:00.000Z</published>
    <updated>2019-06-16T10:57:54.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔者工作经验4年，毕业之后一直梦想着进入大厂工作，一直朝着这个目标努力。经过一年的精心准备，拿到了 <code>字节跳动</code> 的 Offer，在这里分享一下我的一些心得，希望能帮助到有需要的同学。</p></blockquote><h2 id="一、摆正心态"><a href="#一、摆正心态" class="headerlink" title="一、摆正心态"></a>一、摆正心态</h2><p>我加了好几个 iOS 技术交流群，发现大家都有一个共识 ”iOS 没人要了“ 😂，其实很大部分是大佬们的自嘲（当真你就输了），不过也从侧面印证出移动端开发市场的要求越来越高，加上市场大环境不好，想要斩获大厂 Offer 难度越来越大。</p><p>但是作为程序员，我们没必要为这些事情所烦扰，越是寒冬，我们更应当充实自己，让自己变得稀缺，市场总会给到你满意的报酬。我们既然选择了这个高速发展的行业，自己就应该充满活力，保持学习的心态和惯性。</p><p>所以应对资本寒冬，我们应该保持平和的心态，潜心学习，等待机会。</p><p>分享下为了大厂Offer所做的准备工作：</p><ol><li>坚持阅读技术书籍、技术博客、技术文档</li><li>输出技术博客</li><li>阅读开源项目源码</li><li>尝试独立开发，独立完成自己的APP</li><li>练习算法题</li></ol><h2 id="二、阅读技术书籍、博客"><a href="#二、阅读技术书籍、博客" class="headerlink" title="二、阅读技术书籍、博客"></a>二、阅读技术书籍、博客</h2><p>通过阅读技术书籍、博客、文档，可以快速学习到大佬们总结的经验，完善自己的知识体系，扩宽知识面。分享下我获取知识的渠道吧：</p><ul><li><p>掘金：<a href="https://juejin.im" target="_blank" rel="noopener">掘金</a>我机会每天都要上去看看，个人认为掘金是国内 iOS 技术社区中含金量较高的了，强力推荐掘金上的一个专栏《老司机 iOS 周报》，是一线大佬们精心挑选的文章，看就对了😁。</p></li><li><p>小专栏：这是一个付费的知识平台，由于付费的原因，作者在文章更新频率和更新质量上都有所保证。我订阅了35个专栏（别问我都学完没，订阅了就算学习了😂）。推荐几个不错的专栏，<a href="https://xiaozhuanlan.com/LeetCodeGIF?rel=8008493458" target="_blank" rel="noopener">《在PPT动画中学算法》</a>、<a href="https://xiaozhuanlan.com/wwdc19?rel=8008493458" target="_blank" rel="noopener">《WWDC19 内参》</a>、<a href="https://xiaozhuanlan.com/colin?rel=8008493458" target="_blank" rel="noopener">《iOS 图像处理》</a>、<a href="https://xiaozhuanlan.com/daydaystudy?rel=8008493458" target="_blank" rel="noopener">《图解数据结构》</a>、<a href="https://xiaozhuanlan.com/Effective-Mac?rel=8008493458" target="_blank" rel="noopener">《Mac 高效开发指南》</a>、<a href="https://xiaozhuanlan.com/app-architecture?rel=8008493458" target="_blank" rel="noopener">《App 架构》</a></p></li><li><p>知识小集：这是个公众号，是一群大佬共同维护的，更新频繁，文章质量不错。</p></li><li><p>书籍推荐：《Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法》、《Objective-C 高级编程 iOS和OS X多线程和内存管理》、《OBJECTIVE－C编程之道  IOS设计模式解析》、《高性能iOS应用开发》、《iOS Core Animation Advanced Techniques》、《代码整洁之道》。这些书我读了好几遍，每次读都有新的收获。</p></li><li><p>博客推荐：这篇文章总结的很好，直接分享给大家<a href="https://juejin.im/post/5a941ef96fb9a06346201d9e" target="_blank" rel="noopener">高质量 iOS 博客推荐</a>。</p></li><li><p>极客时间：极客时间是专门为程序员打造的知识服务平台，涵盖了各个领域的知识，上面的课程值得一学，推荐滴滴技术专家戴铭大佬的课程 <a href="http://gk.link/a/103UK" target="_blank" rel="noopener">《iOS开发高手课》</a>。</p></li></ul><h2 id="三、输出技术博客"><a href="#三、输出技术博客" class="headerlink" title="三、输出技术博客"></a>三、输出技术博客</h2><p>只阅读书籍、文章还远远不够，输出是最好的学习方式，在输出的过程中，你会发现很多细节其实自己并没有掌握，所以我也在坚持输出技术博客。同时技术博客也是很好的简历，比起简历上的一句 ”精通XXX技术“，一篇精彩的 ”XXX技术解析“ 是不是更有说服力呢？</p><p>我从开始工作就开始写技术博客，刚开始产量比较低。直到一本书改变了我对写作的看法，Spenser 大神的《写作是最好的自我投资》，以前一直认为写文章很难，要写的完美才敢发出来，很多时候创作激情来了，写两个字，看了看嫌弃自己写的太烂又默默的删掉了，最后啥也没有留下来。看完这本书才明白，以前的想法就是作茧自缚，要先动手写，多写，积累多了自然就会写了。</p><p>于是下定决心，先写起来，用 Hexo 搭建了技术博客（<a href="http://crmo.github.io">传送门</a>），在<a href="https://www.jianshu.com/u/714b759c0a3c" target="_blank" rel="noopener">简书</a>上也同步更新。把对自己的要求和期望放低，不求写出像霜神、喵神等大神们教科书般的经典文章，就分享一些工作学习中遇到的小 tip。渐渐也收获到了大家的一些喜欢和评论，发现帮助了一些有需要的朋友，就更加坚定自己的路是走对了。</p><h2 id="四、挑战算法这种大山"><a href="#四、挑战算法这种大山" class="headerlink" title="四、挑战算法这种大山"></a>四、挑战算法这种大山</h2><p>算法是一个合格程序员必备的内功心法，是进入大厂必备的技能，不过大家常常会产生一些误解，有两种极端：</p><p>1、认为算法很难，像洪水猛兽一般难以克服，一堆数据结构，各种抽象的数学公式，于是就放弃了。<br>2、认为算法没用，之前面试的时候和很多iOS开发聊过算法的问题，发现很多人都觉得算法在移动端开发也没啥用，做了好几年开发了都没用到过，唯一有关系的数组排序，查询啥的系统库都封装好了，不需要自己去实现。曾经的我也这么想过，不过在体会过算法的精妙之后，我才领悟到算法的重要性。</p><p>我认为首先算法很有用，其次算法并不难，而且很有趣。</p><p>举个例子，在开发功能时，为了满足产品变态的需求，难免有系统类提供的API不够用的时候，这时候私有变量就可以发挥它光和热了。怎么通过一个类，一层一层的找到特定类型的私有成员变量？在学习了广度优先搜索（BFS）算法之后，我利用BFS写了一个工具类来实现这个需求，</p><blockquote><p>详情见<a href="http://crmo.github.io/2018/07/31/runtime实现私有变量搜索/">runtime实现私有变量搜索</a>。</p></blockquote><p>除了解决开发中的问题，当然学习算法还有一个比较重要的作用，应对大厂面试，现在大厂对于算法还是比较重视的，我在面试字节跳动的时候，每一轮技术面结束都有一道算法题，难度不大，但是很考验平时的积累。我分享下我的学习方法吧：</p><ul><li>首先是系统的学习相关知识，推荐两个学习算法的专栏<a href="https://xiaozhuanlan.com/LeetCodeGIF?rel=8008493458" target="_blank" rel="noopener">《在PPT动画中学算法》</a>、<a href="https://xiaozhuanlan.com/daydaystudy?rel=8008493458" target="_blank" rel="noopener">《图解数据结构》</a>，有多余的时间最好能看看这两本书《算法》、《剑指Offer》（面试必备！）。</li><li>然后就是练题了，一定要多练题！！<a href="https://leetcode.com" target="_blank" rel="noopener">Leetcode</a>是一个非常好的平台，坚持每周刷两道题，一年就能做快100道题，应对面试也就差不多了(我刷了97道)。</li></ul><h2 id="五、尝试独立开发"><a href="#五、尝试独立开发" class="headerlink" title="五、尝试独立开发"></a>五、尝试独立开发</h2><p>我一直都有很多idea，但是一直都没狠下心来做，后来有幸接触了开源大佬的专栏<a href="https://xiaozhuanlan.com/kyxuDev?rel=8008493458" target="_blank" rel="noopener">《KyXu 教你独立开发赚钱》</a>，他以程序员的角度，展现了一个产品的从0到1的全貌，让我心驰神往，于是心一横，购买了一个开发者账号。在2018年上架了两款独立应用<a href="http://t.cn/EAs5ubq" target="_blank" rel="noopener">识之</a>和<a href="https://dwz.cn/HvVix2hH" target="_blank" rel="noopener">香蕉播放器</a>，积累了一些技术之外的经验，比如产品、设计、运营之类的，感觉收获还是蛮大的。</p><p>这里推荐两本关于设计的电子书：<a href="https://xiaozhuanlan.com/Producter?rel=8008493458" target="_blank" rel="noopener">《Producter：让产品从 0 到 1》</a>、<a href="https://xiaozhuanlan.com/larry?rel=8008493458" target="_blank" rel="noopener">《程序员聊设计》</a>。</p><hr><p><strong>最后，祝各位拿到心仪的Offer！（👻点赞并分享祝福加倍）。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;笔者工作经验4年，毕业之后一直梦想着进入大厂工作，一直朝着这个目标努力。经过一年的精心准备，拿到了 &lt;code&gt;字节跳动&lt;/code&gt; 的 Offer，在这里分享一下我的一些心得，希望能帮助到有需要的同学。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>connectionProxyDictionary 笔记</title>
    <link href="https://crmo.github.io/2019/06/16/connectionProxyDictionary%E7%AC%94%E8%AE%B0/"/>
    <id>https://crmo.github.io/2019/06/16/connectionProxyDictionary笔记/</id>
    <published>2019-06-15T16:00:00.000Z</published>
    <updated>2019-06-16T03:53:17.404Z</updated>
    
    <content type="html"><![CDATA[<p>最近研究了下 <code>connectionProxyDictionary</code>，做一个简单的笔记。<a href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1411499-connectionproxydictionary" target="_blank" rel="noopener">官方文档</a>是这么描述的。</p><blockquote><p>This property controls which proxy tasks within sessions based on this configuration use when connecting to remote hosts.<br>The default value is NULL, which means that tasks use the default system settings.</p></blockquote><p>这个属性可以设置网络代理，默认值是 NULL，使用系统的代理设置。</p><blockquote><p>有一个比较巧妙的用法，可以通过设置为空字典可以禁止代理抓包(charles、fiddler等)。</p></blockquote><p>上代码。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span>* proxyHost =  <span class="string">@"192.168.12.23"</span>;<span class="comment">//@"myProxyHost.com";</span></span><br><span class="line"><span class="built_in">NSNumber</span>* proxyPort = [<span class="built_in">NSNumber</span> numberWithInt: <span class="number">12345</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个代理服务器，包括HTTP或HTTPS代理，当然还可以添加SOCKS,FTP,RTSP等</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *proxyDict = @&#123;</span><br><span class="line">    (<span class="built_in">NSString</span> *)kCFNetworkProxiesHTTPEnable  : [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>],</span><br><span class="line">    (<span class="built_in">NSString</span> *)kCFNetworkProxiesHTTPProxy: proxyHost,</span><br><span class="line">    (<span class="built_in">NSString</span> *)kCFNetworkProxiesHTTPProxyPort: proxyPort,</span><br><span class="line"></span><br><span class="line">    (<span class="built_in">NSString</span> *)kCFNetworkProxiesHTTPSEnable : [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>],</span><br><span class="line">    (<span class="built_in">NSString</span> *)kCFNetworkProxiesHTTPSProxy: proxyHost,</span><br><span class="line">    (<span class="built_in">NSString</span> *)kCFNetworkProxiesHTTPSProxyPort: proxyPort,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</span><br><span class="line"><span class="comment">// 设置代理</span></span><br><span class="line">configuration.connectionProxyDictionary = proxyDict;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止代理</span></span><br><span class="line">configuration.connectionProxyDictionary = @&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1411499-connectionproxydictionary" target="_blank" rel="noopener">Apple 文档</a><br>2、<a href="https://stackoverflow.com/questions/28101582/how-to-programmatically-add-a-proxy-to-an-nsurlsession" target="_blank" rel="noopener">How to programmatically add a proxy to an NSURLSession</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近研究了下 &lt;code&gt;connectionProxyDictionary&lt;/code&gt;，做一个简单的笔记。&lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsurlsessionconfigur
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>NSURLCache 缓存机制浅谈</title>
    <link href="https://crmo.github.io/2019/04/16/NSURLCache%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E6%B5%85%E8%B0%88/"/>
    <id>https://crmo.github.io/2019/04/16/NSURLCache 缓存机制浅谈/</id>
    <published>2019-04-15T16:00:00.000Z</published>
    <updated>2019-04-16T12:48:12.494Z</updated>
    
    <content type="html"><![CDATA[<p>APP 中有很多从服务器获取数据、资源的需求，为了节省流量、加快访问速度、离线使用等需求，就会使用到网络缓存。<code>HTTP协议</code>对于缓存设计了很多机制，感兴趣的同学可以看看<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13" target="_blank" rel="noopener">《RFC2616-section13-Caching in HTTP》</a>。</p><h2 id="iOS-中常见缓存机制"><a href="#iOS-中常见缓存机制" class="headerlink" title="iOS 中常见缓存机制"></a>iOS 中常见缓存机制</h2><p>在iOS中，如果没有特殊需求，使用系统的缓存机制就可以满足。如：max-age、Last-Modified、ETag、Expires等机制系统都实现了的，不需要自己再去搞一套。只需要将 <code>NSURLRequest</code> 的 <code>cachePolicy</code> 设置为 <code>NSURLRequestUseProtocolCachePolicy</code> 。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLRequest</span> *request = [[<span class="built_in">NSURLRequest</span> alloc] init];</span><br><span class="line">request.cachePolicy = <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>;</span><br></pre></td></tr></table></figure><p>这里简单说下常见的几种机制，首先来看一个<code>GET请求</code>的响应报文，里面包含了几种常见的缓存标识。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 </span><br><span class="line">Cache-Controlmax-age=86400, private</span><br><span class="line">Last-ModifiedTue, 16 Apr 2019 06:07:39 GMT</span><br><span class="line">ETagW/&quot;28111-1554979928000&quot;</span><br><span class="line">ExpiresWed, 17 Apr 2019 06:07:39 GMT</span><br><span class="line">DateTue, 16 Apr 2019 06:07:39 GMT</span><br><span class="line">Transfer-Encodingchunked</span><br><span class="line">Connectionkeep-alive</span><br></pre></td></tr></table></figure><h3 id="max-age"><a href="#max-age" class="headerlink" title="max-age"></a>max-age</h3><p><code>max-age</code> 是 <code>cache-control</code> 下的一个指令，表示 <code>Response</code> 的最大 Age。例如：</p><blockquote><p>Cache-Control     max-age=86400, private</p></blockquote><p>含义为：该 <code>Response</code> 的有效期为1天，在一天以内，同样的 URL 将不会再次请求，直接使用缓存。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code> 告诉客户端 <code>Response</code> 的过期时间。例如：</p><blockquote><p>Expires Wed, 17 Apr 2019 06:07:39 GMT</p></blockquote><p>含义为：该 <code>Response</code> 在 <code>Wed, 17 Apr 2019 06:07:39 GMT</code> 时过期，在这之前，同样的 URL 将不会再次请求，直接使用缓存。<br>需要注意的是，<code>max-age</code> 的优先级大于 <code>expires</code>。</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p><code>Last-Modified</code> 指明资源的最终修改时间，客户端在请求的时候，将这个值带在 <code>If-Modified-Since</code> 中。例如：</p><blockquote><p>If-Modified-Since    Thu, 11 Apr 2019 10:52:08 GMT</p></blockquote><p>服务器会根据客户端传递的时间判断资源是否有更新，如果没有更新，服务器返回304，客户端直接使用缓存，如果有更新，服务器返回200和最新的资源。</p><h3 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h3><p><code>Etag</code> 类似于资源的唯一hash值，资源发生变化，这个值就发生变更，客户端在请求资源时，会将 <code>Etag</code> 放在 <code>If-None-Match</code> 中，例如：</p><blockquote><p>If-None-Match     W/“28111-1554979928000”</p></blockquote><p>服务端根据客户端传递的 <code>Etag</code> 判断资源是否有更新，如果没有更新，服务器返回304，客户端直接使用缓存，如果有更新，服务器返回200和最新的资源。</p><h2 id="启发式缓存（heuristic-expiration）"><a href="#启发式缓存（heuristic-expiration）" class="headerlink" title="启发式缓存（heuristic expiration）"></a>启发式缓存（heuristic expiration）</h2><p>在测试缓存机制时，发现了一种特殊情况，返回报文里没有 <code>max-age</code> 和 <code>Expires</code>，再次请求相同URL时却直接使用的缓存，没有重新发请求，请求报文如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 </span><br><span class="line">Accept-Rangesbytes</span><br><span class="line">ETagW/&quot;28111-1554979928000&quot;</span><br><span class="line">Last-ModifiedThu, 11 Apr 2019 10:52:08 GMT</span><br><span class="line">DateTue, 16 Apr 2019 07:23:21 GMT</span><br><span class="line">Content-Typeimage/jpeg</span><br><span class="line">Content-Length28111</span><br><span class="line">Connectionkeep-alive</span><br></pre></td></tr></table></figure><p>让人摸不着头脑，在查询资料后发现一篇文章，提到了这个现象，<a href="https://blackpixel.com/writing/2012/05/caching-and-nsurlconnection.html" target="_blank" rel="noopener">Caching and NSURLConnection</a>。</p><p>在文章的指引下，仔细研究了下<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13" target="_blank" rel="noopener">RFC2616-section13-Caching in HTTP</a>，发现了答案。</p><p>RFC的原文如下：</p><blockquote><p>If none of Expires, Cache-Control: max-age, or Cache-Control: s- maxage (see section 14.9.3) appears in the response, and the response does not include other restrictions on caching, the cache MAY compute a freshness lifetime using a heuristic. The cache MUST attach Warning 113 to any response whose age is more than 24 hours if such warning has not already been added.<br>Also, if the response does have a Last-Modified time, the heuristic expiration value SHOULD be no more than some fraction of the interval since that time. A typical setting of this fraction might be 10%.</p></blockquote><p>这是一种叫启发式缓存（heuristic expiration）的策略，在 response 中如果没有 Expires、max-age、s-maxage，来明确指定资源的过期时间，NSURLCache 会根据 Last-Modified 来计算一个过期时间。</p><blockquote><p>根据实验结果，在iOS中计算公式是这样的：lifetime = (Last-Modified - Now) * 10%</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1、<a href="https://blackpixel.com/writing/2012/05/caching-and-nsurlconnection.html" target="_blank" rel="noopener">Caching and NSURLConnection</a><br>2、<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13" target="_blank" rel="noopener">RFC2616-section13-Caching in HTTP</a><br>3、<a href="https://nshipster.com/nsurlcache/" target="_blank" rel="noopener">NSURLCache-NSHipster</a><br>4、<a href="https://segmentfault.com/a/1190000004356632" target="_blank" rel="noopener">iOS网络缓存扫盲篇 - 使用两行代码就能完成80%的缓存需求</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;APP 中有很多从服务器获取数据、资源的需求，为了节省流量、加快访问速度、离线使用等需求，就会使用到网络缓存。&lt;code&gt;HTTP协议&lt;/code&gt;对于缓存设计了很多机制，感兴趣的同学可以看看&lt;a href=&quot;https://www.w3.org/Protocols/rfc
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>从FMDB线程安全问题说起</title>
    <link href="https://crmo.github.io/2019/01/28/%E4%BB%8EFMDB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E8%AF%B4%E8%B5%B7/"/>
    <id>https://crmo.github.io/2019/01/28/从FMDB线程安全问题说起/</id>
    <published>2019-01-27T16:00:00.000Z</published>
    <updated>2019-02-02T01:39:15.071Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文讨论的 FMDB 版本为<code>2.7.5</code>，测试环境是 <code>Xcode 10.1 &amp; iOS 12.1</code>。</p></blockquote><h2 id="一、问题记录"><a href="#一、问题记录" class="headerlink" title="一、问题记录"></a>一、问题记录</h2><p>最近在分析崩溃日志的时候发现一个 FMDB 的 crash 频繁出现，crash 堆栈如下：</p><p><img src="/images/15486768292546.jpg" alt="15486768292546"></p><p>在控制台能看到报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[logging] BUG IN CLIENT OF sqlite3.dylib: illegal multi-threaded access to database connection</span><br><span class="line">Warning: there is at least one open result set around after performing [FMDatabaseQueue inDatabase:]</span><br></pre></td></tr></table></figure><p>从日志中能大概猜到，这是多线程访问数据库导致的 crash。FMDB 提供了 <code>FMDatabaseQueue</code> 在多线程环境下操作数据库，它内部维护了一个串行队列来保证线程安全。我检查了所有操作数据库的代码，都是在 <code>FMDatabaseQueue</code> 队列里执行的，为啥还是会报多线程问题（一脸懵逼🤔）？</p><p>在网上找了一圈，发现 github 上有人遇到了同样的问题， <a href="https://github.com/ccgus/fmdb/issues/724" target="_blank" rel="noopener">Issue 724</a> 和 <a href="https://github.com/ccgus/fmdb/issues/711" target="_blank" rel="noopener">Issue 711</a>，Stack Overflow上有相关的<a href="https://stackoverflow.com/questions/49198831/sqlite3-dylib-illegal-multi-threaded-access-to-database-connection/54397109#54397109" target="_blank" rel="noopener">讨论</a>。</p><p>项目里业务太复杂，很难排查问题，于是写了一个简化版的 Demo 来复现问题：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> *dbPath = [docPath stringByAppendingPathComponent:<span class="string">@"test.sqlite"</span>];</span><br><span class="line">    _queue = [FMDatabaseQueue databaseQueueWithPath:dbPath];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建测试数据，新建一个表test，inert一些数据</span></span><br><span class="line">    [_queue inDatabase:^(FMDatabase * _Nonnull db) &#123;</span><br><span class="line">        [db executeUpdate:<span class="string">@"create table if not exists test (a text, b text, c text, d text, e text, f text, g text, h text, i text)"</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            [db executeUpdate:<span class="string">@"insert into test (a, b, c, d, e, f, g, h, i) values ('1', '1', '1','1', '1', '1','1', '1', '1')"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多线程查询数据库</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [_queue inDatabase:^(FMDatabase * _Nonnull db) &#123;</span><br><span class="line">                FMResultSet *result = [db executeQuery:<span class="string">@"select * from test where a = '1'"</span>];</span><br><span class="line">                <span class="comment">// 这里要用if，改成while就没问题了</span></span><br><span class="line">                <span class="keyword">if</span> ([result next]) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里不调用close</span></span><br><span class="line"><span class="comment">//                [result close];</span></span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>问题完美复现，接下来就可以排查问题了，有两个问题亟待解决：</p><ol><li>iOS 系统自带的 SQLite 究竟是不是线程安全的？</li><li>为什么使用了线程安全队列 <code>FMDatabaseQueue</code>， 还是出现了线程安全问题？</li></ol><h2 id="二、SQLite-线程安全"><a href="#二、SQLite-线程安全" class="headerlink" title="二、SQLite 线程安全"></a>二、SQLite 线程安全</h2><p>我们先来看第一个问题，iOS 系统自带的 SQLite 究竟是不是线程安全的？</p><p>Google 了一下，发现了关于SQLite的<a href="https://www.sqlite.org/threadsafe.html" target="_blank" rel="noopener">官方文档 - Using SQLite In Multi-Threaded Applications</a>。文档写的很清晰，有时间最好认真读读，这里简单总结一下。</p><p>SQLite 有3种线程模式：</p><ol><li>Single-thread，单线程模式，编译时所有互斥锁代码会被删除掉，多线程环境下不安全。</li><li>Multi-thread，在大部分情况下多线程环境安全，比如同一个数据库，开多个线程，每个线程都开一个连接同时访问这个库，这种情况是安全的。但是也有不安全情况：多个线程同时使用同一个数据库连接（或从该连接派生的任何预准备语句）</li><li>Serialized，完全线程安全。</li></ol><p>有3个时间点可以配置 threading mode，编译时（compile-time）、初始化时（start-time）、运行时（run-time）。配置生效规则是 run-time 覆盖 start-time 覆盖 compile-time，有一些特殊情况：</p><ol><li>编译时设置 <code>Single-thread</code>，用户就不能再开启多线程模式，因为线程安全代码被优化了。</li><li>如果编译时设置的多线程模式，在运行时不能降级为单线程模式，只能在<code>Multi-thread</code>和<code>Serialized</code>间切换。</li></ol><h3 id="threading-mode-编译选项"><a href="#threading-mode-编译选项" class="headerlink" title="threading mode 编译选项"></a>threading mode 编译选项</h3><p>SQLite threading mode 编译选项的<a href="https://www.sqlite.org/compile.html#threadsafe" target="_blank" rel="noopener">官方文档</a></p><p><img src="/images/15486559651186.jpg" alt="15486559651186"></p><p>编译时，通过配置项<code>SQLITE_THREADSAFE</code>可以配置 SQLite 在多线程环境下是否安全。有三个可选项：</p><ol><li>0，对应 Single-thread ，编译时所有互斥锁代码会被删除掉，SQLite 在多线程环境下不安全。</li><li>1，对应 Serialized，在多线程环境下安全，如果不手动指定，这是默认选项。</li><li>2，对应 Multi-thread ，在大部分情况下多线程环境安全，不安全情况：有两个线程同时尝试使用相同数据库连接（或从该数据库连接派生的任何预处理语句 Prepared Statements）</li></ol><p>除了编译时可以指定 threading mode ，还可以通过函数 <code>sqlite3_config()</code> （start-time ）改变全局的 threading mode 或者通过<code>sqlite3_open_v2()</code> （run-time）改变某个数据库连接的 threading mode。</p><p>但是如果编译时配置了<code>SQLITE_THREADSAFE = 0</code>，编译时所有线程安全代码都被优化掉了，就不能再切换到多线程模式了。</p><p>有了前面的知识，我们就可以分析问题一了。调用函数 <code>sqlite3_threadsafe()</code> 可以获取编译时的配置项，我们可以用这个函数获取系统自带的 SQLite 在编译时的配置，结论是2（Multi-thread）。</p><p>也就是说，系统自带的 SQLite 在不做任何配置的情况下不是完全线程安全的。当然可以手动将模式切换到 <code>Serialized</code> 就可以实现完全线程安全了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 方案一：全局设置模式</span><br><span class="line">sqlite3_config(SQLITE_CONFIG_SERIALIZED);</span><br><span class="line"></span><br><span class="line">// 方案二：设置 connecting 模式，调用 sqlite3_open_v2 时 flag 加上 SQLITE_OPEN_FULLMUTEX</span><br><span class="line">sqlite3_open_v2(path, &amp;db, SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE | SQLITE_OPEN_FULLMUTEX, nil)</span><br></pre></td></tr></table></figure><p>经过测试，通过上面两种方案改造之后，Demo 中的 crash 问题完美解决。但是我认为这不是最优的解决方案，苹果为啥不直接将编译选项设置为 <code>Serialized</code>，这篇文章就永远不会出现了😂，劳民伤财让大家折腾半天，去手动设置模式。我认为性能是一个重要因素，<code>Multi-thread</code> 性能优于 <code>Serialized</code>, 用户只要保证一个连接不在多线程同时访问就没问题了，其实能满足大部分需求。</p><p>比如 FMDB 的 <code>FMDatabaseQueue</code> 就是为了解决该问题。</p><h2 id="三、FMDatabaseQueue-其实并不安全"><a href="#三、FMDatabaseQueue-其实并不安全" class="headerlink" title="三、FMDatabaseQueue 其实并不安全"></a>三、FMDatabaseQueue 其实并不安全</h2><p>FMDB 的官方文档写到：</p><blockquote><p>FMDatabaseQueue will run the blocks on a serialized queue (hence the name of the class). So if you call FMDatabaseQueue’s methods from multiple threads at the same time, they will be executed in the order they are received. This way queries and updates won’t step on each other’s toes, and every one is happy.</p></blockquote><p>在多线程使用 <code>FMDatabaseQueue</code> 的确很安全，通过 GCD 的串行队列来保证所有读写操作都是串行执行的。它的核心代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_queue = dispatch_queue_create([[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"fmdb.%@"</span>, <span class="keyword">self</span>] UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)inDatabase:(__attribute__((noescape)) <span class="keyword">void</span> (^)(FMDatabase *db))block &#123;</span><br><span class="line">    <span class="comment">// ...省略部分代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_queue, ^() &#123;</span><br><span class="line">        FMDatabase *db = [<span class="keyword">self</span> database];</span><br><span class="line">        block(db);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是分析第一节 Demo 的 crash 堆栈，可以看到崩溃发生在线程3的函数 <code>[FMResultSet reset]</code>，函数定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reset &#123;</span><br><span class="line">    <span class="keyword">if</span> (_statement) &#123;</span><br><span class="line">        <span class="comment">// 释放预处理语句（Reset A Prepared Statement Object）</span></span><br><span class="line">        sqlite3_reset(_statement);</span><br><span class="line">    &#125;</span><br><span class="line">    _inUse = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [FMStatement reset]</span><br><span class="line">- [FMResultSet close]</span><br><span class="line">- [FMResultSet dealloc]</span><br></pre></td></tr></table></figure><p>顺着调用堆栈，我们来看看 <code>FMResultSet</code> 的 <code>dealloc</code> 和 <code>close</code> 方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span> close];</span><br><span class="line">    FMDBRelease(_query);</span><br><span class="line">    _query = <span class="literal">nil</span>;</span><br><span class="line">    FMDBRelease(_columnNameToIndexMap);</span><br><span class="line">    _columnNameToIndexMap = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)close &#123;</span><br><span class="line">    [_statement reset];</span><br><span class="line">    FMDBRelease(_statement);</span><br><span class="line">    _statement = <span class="literal">nil</span>;</span><br><span class="line">    [_parentDB resultSetDidClose:<span class="keyword">self</span>];</span><br><span class="line">    [<span class="keyword">self</span> setParentDB:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以得出结论，在 <code>FMResultSet</code> <code>dealloc</code> 时会调用 <code>close</code> 方法，来关闭预处理语句。再回到第一节的 crash 堆栈，不难发现线程7在用同一个数据库连接读数据库，结合官方文档中的一段话，我们就可以得出结论了。</p><blockquote><p>When compiled with SQLITE_THREADSAFE=2, SQLite can be used in a multithreaded program so long as no two threads attempt to use the same database connection (or any prepared statements derived from that database connection) at the same time.</p></blockquote><p>使用 <code>FMDatabaseQueue</code> 还是发生了多线程使用同一个数据库连接、预处理语句的情况，于是就崩溃了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>问题找到了，接下来聊聊怎么避免问题。</p><h3 id="FMDB的正确打开方式"><a href="#FMDB的正确打开方式" class="headerlink" title="FMDB的正确打开方式"></a>FMDB的正确打开方式</h3><p>如果用 <code>while</code> 循环遍历 <code>FMResultSet</code> 就不存在该问题，因为 <code>[FMResultSet next]</code> 遍历到最后会调用 <code>[FMResultSet close]</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[_queue inDatabase:^(FMDatabase * _Nonnull db) &#123;</span><br><span class="line">    FMResultSet *result = [db executeQuery:<span class="string">@"select * from test where a = '1'"</span>];</span><br><span class="line">    <span class="comment">// 安全</span></span><br><span class="line">    <span class="keyword">while</span> ([result next]) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 安全</span></span><br><span class="line">    <span class="keyword">if</span> ([result next]) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    [result close];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>如果一定要用 <code>if ([result next])</code> ，手动加上 <code>[FMResultSet close]</code> 也没有问题。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>我遇到这个问题，是被官方文档的一句话误导了。</p><blockquote><p>Typically, there’s no need to -close an FMResultSet yourself, since that happens when either the result set is deallocated, or the parent database is closed.</p></blockquote><p>于是我提了一个 <a href="https://github.com/ccgus/fmdb/pull/728" target="_blank" rel="noopener">Pull requests</a> ，我提出了两种解决方案：</p><ol><li>修改文档，在文档中强调，用户需要手动调用 close。</li><li>在 <code>[FMDatabaseQueue inDatabase:]</code> 函数的最后，调用 <code>[FMDatabase closeOpenResultSets]</code> 帮助调用者关闭所有 FMResultSet。</li></ol><p>FMDB 的作者 <code>ccgus</code> 采用了第一种方案，在最新的一次 <a href="https://github.com/ccgus/fmdb/commit/7da3c812cdddd6f5da1df31e7751ef3e56dacd6b" target="_blank" rel="noopener">commit</a> 修改了文档，加上了相关说明。</p><blockquote><p>Typically, there’s no need to -close an FMResultSet yourself, since that happens when either the result set is exhausted. However, if you only pull out a single request or any other number of requests which don’t exhaust the result set, you will need to call the -close method on the FMResultSet.</p></blockquote><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.sqlite.org/threadsafe.html" target="_blank" rel="noopener">Using SQLite In Multi-Threaded Applications</a></li><li><a href="https://stackoverflow.com/questions/49198831/sqlite3-dylib-illegal-multi-threaded-access-to-database-connection/54397109#54397109" target="_blank" rel="noopener">sqlite3.dylib: illegal multi-threaded access to database connection</a></li><li><a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a></li><li><a href="https://www.sqlite.org/compile.html#threadsafe" target="_blank" rel="noopener">SQLite编译选项官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文讨论的 FMDB 版本为&lt;code&gt;2.7.5&lt;/code&gt;，测试环境是 &lt;code&gt;Xcode 10.1 &amp;amp; iOS 12.1&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、问题记录&quot;&gt;&lt;a href=&quot;#一
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Core Animation学习笔记（三）- 视觉效果</title>
    <link href="https://crmo.github.io/2018/12/03/Core%20Animation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://crmo.github.io/2018/12/03/Core Animation学习笔记（三）/</id>
    <published>2018-12-02T16:00:00.000Z</published>
    <updated>2018-12-04T13:48:48.983Z</updated>
    
    <content type="html"><![CDATA[<p>我们在之前的文章中讨论了<code>CALayer</code>的<code>backing images</code>与几何布局，这篇文章我们来看看如何通过它的特性来实现一些炫酷的效果。</p><h2 id="圆角与边框"><a href="#圆角与边框" class="headerlink" title="圆角与边框"></a>圆角与边框</h2><p><code>CALayer</code>有一个叫做<code>conrnerRadius</code>的属性控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角）。默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层。如果把<code>masksToBounds</code>设置成YES的话，图层里面的所有东西都会被截取。<br><code>CALayer</code>另外两个非常有用属性就是<code>borderWidth</code>和<code>borderColor</code>。二者共同定义了图层边的绘制样式。这条线（也被称作stroke）沿着图层的bounds绘制，同时也包含图层的角。<br><code>borderWidth</code>是以点为单位的定义边框粗细的浮点数，默认为0。<code>borderColor</code>定义了边框的颜色，默认为黑色。</p><p>需要注意的是，<code>conrnerRadius</code>与<code>masksToBounds</code>同时使用是会造成离屏渲染，使用需要谨慎。例如在TableView的cell实现圆角头像，使用这种方案实现圆角就不合适了。有一种简单的替代方案：利用一张中间为透明圆形的图片来进行遮盖，虽然会引起blending，但性能仍然高于离屏渲染。</p><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>与圆角和边框不同，阴影会根据<code>backing image</code>与子视图来绘制，而不是layer的边界和角半径。<br>自定义阴影主要有下面属性需要关注（配合下图的例子看着比较直观）：</p><ul><li>shadowOpacity：阴影的透明度，取值范围在0.0（不可见）到1.0（不透明）之间</li><li>shadowColor：阴影颜色，默认是黑色</li><li>shadowOffset：阴影的方向和距离，他是一个CGSize，宽度控制阴影横向位移，高度控制阴影纵向位移。它的默认值是{0, -3}，也就是说阴影向上便宜3个点。</li><li>shadowRadius：阴影的模糊度，默认值是3。</li></ul><p><img src="/images/15438192854146-1.jpg" alt="阴影属性举例"></p><h3 id="shadowPath"><a href="#shadowPath" class="headerlink" title="shadowPath"></a>shadowPath</h3><p>需要注意的是使用<code>shadowOffse</code>设置阴影会导致离屏渲染，实时计算阴影是一个非常消耗资源的操作，尤其是图层有多个子图层，且每个图层还有一个有透明效果的<code>backing images</code>的时候。<br>这时可以通过设置<code>shadowPath</code>属性来提高性能，<code>shadowPath</code>是一个<code>CGPathRef</code>类型（一个指向<code>CGPath</code>的指针）。<code>CGPath</code>是一个<code>Core Graphics</code>对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。下图可以清晰的看到两种方式在性能上的差距。</p><p><img src="/images/15438427503914.png" alt="15438427503914"></p><p>下面的代码实现了一个自定义的矩形阴影。</p><p><img src="/images/15438159073216.jpg" alt="自定义矩形阴影"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置阴影颜色</span></span><br><span class="line">layer.shadowColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line"><span class="comment">// 设置阴影不透明度</span></span><br><span class="line">layer.shadowOpacity = <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">// 绘制一个矩形</span></span><br><span class="line"><span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line"><span class="built_in">CGPathAddRect</span>(path, <span class="literal">NULL</span>, layer.bounds);</span><br><span class="line"><span class="built_in">CGPathRelease</span>(path);</span><br><span class="line"><span class="comment">// 自定义矩形阴影</span></span><br><span class="line">layer.shadowPath = path;</span><br></pre></td></tr></table></figure><h2 id="拉伸"><a href="#拉伸" class="headerlink" title="拉伸"></a>拉伸</h2><p>当图片实际大小与要展示的大小不同的时候，图像就需要缩放。有两个属性可以定义属性缩放使用的算法：</p><ul><li>minificationFilter：缩小图片使用算法，默认<code>kCAFilterLinear</code></li><li>magnificationFilter：放大图片使用算法，默认<code>kCAFilterLinear</code></li></ul><p>CALayer提供了三种缩放的方式：</p><ul><li>kCAFilterLinear：双线性过滤算法，默认算法</li><li>kCAFilterTrilinear：三线性过滤算法</li><li>kCAFilterNearest：临近过滤算法</li></ul><p>关于什么是线性过滤算法，可以看看维基百科的相关词条<a href="https://zh.wikipedia.org/wiki/双线性过滤" target="_blank" rel="noopener">维基百科-双线性过滤</a>。这里摘录一段供参考：</p><blockquote><p>双线性过滤（Bilinear filtering）是进行缩放显示的时候进行纹理平滑的一种纹理过滤方法。 在大多数情况下，纹理在屏幕上显示的时候都不会同保存的纹理一模一样，没有任何损失。正因为这样，所以一些像素要使用纹素之间的点进行表示，在这里我们假设纹素都是位于各个单元中心或者左上或者其它位置的点。双线性过滤器利用像素所表示点周围四个最近的点（纹素点）之间进行双线性插值。<br>在纹理缩减到一半或者放大一倍的范围内，双线性过滤都能够有非常好的精度。这也就是说，如果纹理在每个方向都有 256 个像素，那么将它缩减到 128 以下或者放大到 512 以上的时候，由于会丢掉太多的像素或者进行了过多的平滑处理，纹理看起来就会很差。<br>三线性过滤尽管比较复杂，但是可以使得过渡非常平滑。</p></blockquote><p>临近过滤算法是一种简单粗暴的方法，它只取样最近的单像素点，不管其它像素点。这样做非常快，也不会使图片模糊。但是会让压缩的图片更糟，让放大的图片显得块状或是马赛克严重。</p><p>对比线性过滤和临近过滤算法，非常小的图像或具有鲜明对比度和较少斜线的较大图像（例如，计算机生成的图像）​​，临近过滤算法将保持对比度并且可以产生更好的效果。但是对于大多数图像，尤其是具有斜线或曲线的图像，线性过滤算法好得多。换句话说，线性过滤保留了形状，临近过滤保留了像素差异。</p><p>书中举了两个很直观例子，对于大图来说，双线性过滤算法和三线性过滤算法表现得更出色：<br><img src="/images/15438313676615.png" alt="15438313676615"></p><p>对于没有斜线的小图来说，最近过滤算法要好很多：<br><img src="/images/15438313825142.png" alt="15438313825142"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>CALayer</code>提供了一系列方法来实现常见的视觉效果，但是在使用的时候我们要注意离屏渲染问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在之前的文章中讨论了&lt;code&gt;CALayer&lt;/code&gt;的&lt;code&gt;backing images&lt;/code&gt;与几何布局，这篇文章我们来看看如何通过它的特性来实现一些炫酷的效果。&lt;/p&gt;
&lt;h2 id=&quot;圆角与边框&quot;&gt;&lt;a href=&quot;#圆角与边框&quot; class=
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Core Animation学习笔记（一）- CALayer</title>
    <link href="https://crmo.github.io/2018/12/02/Core%20Animation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://crmo.github.io/2018/12/02/Core Animation学习笔记（一）/</id>
    <published>2018-12-01T16:00:00.000Z</published>
    <updated>2018-12-04T13:43:26.582Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是我阅读书籍《iOS CORE ANIMATION ADVANCED TECHNIQUES》的读书笔记，感谢原书作者及译者的分享！<br>推荐大家有时间可以读读英文版原书，虽然年代比较久远了，但是还是能有不少收获。英文不好的同学可以看<a href="https://zsisme.gitbooks.io/ios-/content/index.html" target="_blank" rel="noopener">中文版</a></p></blockquote><h2 id="一、Core-Animation定义"><a href="#一、Core-Animation定义" class="headerlink" title="一、Core Animation定义"></a>一、Core Animation定义</h2><p>什么是<code>Core Animation</code>，相信很多同学对于它既熟悉又陌生，从名字上来看它应该是一个做动画的框架，其实动画只是它的一部分，它曾经叫做<code>Layer Kit</code>。</p><p>引用书中的定义：</p><blockquote><p>Core Animation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的<code>Layer</code>，并存储在<code>Layer Tree</code>中。于是这个树形成了UIKit以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。</p></blockquote><p>看完还是一脸懵逼？没关系，在这一系列文章中，我将抽丝剥茧，带领大家揭开<code>Core Animation</code>的神秘面纱。</p><h2 id="二、UIView与CALayer"><a href="#二、UIView与CALayer" class="headerlink" title="二、UIView与CALayer"></a>二、UIView与CALayer</h2><p>我们平时开发中，接触最多的就是<code>UIView</code>，UIView可以处理触摸事件，可以支持基于<code>Core Graphics</code>绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p><p>每个<code>UIView</code>都包含一个<code>CALayer</code>实例，也就是所谓的<code>backing layer</code>。<code>CALayer</code>与<code>UIView</code>最大的区别是它不处理用户的交互，它的职责是负责屏幕上的显示和动画。<code>UIView</code>负责处理用户交互，并管理<code>CALayer</code>。</p><p><code>UIView</code>其实就是对<code>CALayer</code>的高级封装，为什么苹果不直接用一个简单层级来处理所有事情？原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有<code>UIKit</code>和<code>UIView</code>，但是Mac OS有<code>AppKit</code>和<code>NSView</code>的原因。他们功能上很相似，但是在实现上有着显著的区别。</p><h3 id="CALayer独有功能"><a href="#CALayer独有功能" class="headerlink" title="CALayer独有功能"></a>CALayer独有功能</h3><p>有一些UIView没有暴露出来的CALayer的功能：</p><ul><li>阴影，圆角，带颜色的边框</li><li>3D变换</li><li>非矩形范围</li><li>透明遮罩</li><li>多级非线性动画</li></ul><h2 id="三、backing-image"><a href="#三、backing-image" class="headerlink" title="三、backing image"></a>三、backing image</h2><p><code>backing image</code>是<code>CALayer</code>的重要部分，通过它可以实现各种复杂的UI。有两种设置<code>backing image</code>的方法:</p><ol><li>设置CALayer的<code>contents</code>属性</li><li>直接用<code>Core Graphics</code>绘制</li></ol><h3 id="contents"><a href="#contents" class="headerlink" title="contents"></a>contents</h3><p>CALayer有一个属性叫做<code>contents</code>，这个属性的类型被定义为id，但是，如果你给<code>contents</code>赋的不是CGImage，那么你得到的图层将是空白的。</p><blockquote><p><code>contents</code>这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。</p></blockquote><p>我们先来看一个Demo，在<code>CALayer</code>中加载了一张图片：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    view.center = <span class="keyword">self</span>.view.center;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:view];</span><br><span class="line">    <span class="built_in">CALayer</span> *layer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    [view.layer addSublayer:layer];</span><br><span class="line">    layer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [UIImage imageNamed:@"test"]会根据不同机型取不同倍图</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"test"</span>];</span><br><span class="line">    <span class="comment">// UIImage转CGImageRef时scale属性丢失</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = image.CGImage;</span><br><span class="line">    layer.contents = (__bridge <span class="keyword">id</span>)imageRef;</span><br><span class="line">    <span class="comment">// 设置图片缩放</span></span><br><span class="line">    <span class="comment">// 如果contentsGravity设置为自动缩放，可以不用设置这个属性</span></span><br><span class="line">    layer.contentsScale = image.scale;</span><br><span class="line">    <span class="comment">// 设置图片居中不缩放</span></span><br><span class="line">    layer.contentsGravity = kCAGravityCenter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="contentsGravity"><a href="#contentsGravity" class="headerlink" title="contentsGravity"></a>contentsGravity</h4><p><code>UIImageView</code>中通过设置<code>contentMode</code>来设置图片拉伸方式，在<code>CALayer</code>中有一个对应属性<code>contentsGravity</code>，它是一个NSString类型，默认值是<code>kCAGravityResize</code>。<br>它的可选的值有：</p><ul><li>kCAGravityCenter</li><li>kCAGravityTop</li><li>kCAGravityBottom</li><li>kCAGravityLeft</li><li>kCAGravityRight</li><li>kCAGravityTopLeft</li><li>kCAGravityTopRight</li><li>kCAGravityBottomLeft</li><li>kCAGravityBottomRight</li><li>kCAGravityResize</li><li>kCAGravityResizeAspect</li><li>kCAGravityResizeAspectFill</li></ul><h4 id="UIImage转CGImage拉伸丢失问题"><a href="#UIImage转CGImage拉伸丢失问题" class="headerlink" title="UIImage转CGImage拉伸丢失问题"></a>UIImage转CGImage拉伸丢失问题</h4><p>和UIImage不同，CGImage没有拉伸的概念。使用UIImage类去读取图片的时候，它会读取了屏幕（1x、2x、3x）对应尺寸的图片。但是用CGImage来设置<code>layer.contents</code>时，拉伸这个因素在转换的时候就丢失了，不过我们可以通过手动设置<code>contentsScale</code>来修复这个问题。</p><h4 id="contentsScale"><a href="#contentsScale" class="headerlink" title="contentsScale"></a>contentsScale</h4><p>如果<code>contentsScale</code>设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片。<code>UIView</code>中对应<code>contentScaleFactor</code>属性。</p><h4 id="contentsCenter"><a href="#contentsCenter" class="headerlink" title="contentsCenter"></a>contentsCenter</h4><p>contentsCenter是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。类似于<code>UIImage</code>里的<code>resizableImageWithCapInsets</code> 方法，只是它可以运用到任何<code>backing image</code>，甚至包括<code>Core Graphics</code>绘制的图形。</p><p><img src="images/15436482245238.jpg" alt=""></p><h3 id="Custom-Drawing"><a href="#Custom-Drawing" class="headerlink" title="Custom Drawing"></a>Custom Drawing</h3><p>第二种方案是直接用<code>Core Graphics</code>绘制<code>backing image</code>，具体实现方式是通过继承<code>UIView</code>并实现<code>drawRect</code>来自定义绘制。</p><h4 id="CALayerDelegate"><a href="#CALayerDelegate" class="headerlink" title="CALayerDelegate"></a>CALayerDelegate</h4><p>要理解<code>drawRect</code>的工作原理，首先我们来看看<code>CALayerDelegate</code>。<br><code>CALayer</code>有一个可选的delegate，通过实现<code>CALayerDelegate</code>，就可以自定义<code>CALayer</code>的<code>backing image</code>。<br><code>CALayerDelegate</code>中有两个值得关注的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由-display方法的默认实现调用，你应该实现整个显示过程（通常通过设置'contents'属性）</span></span><br><span class="line"><span class="comment">// 如果实现了该方法，就不会调用drawLayer:inContext:了</span></span><br><span class="line">- (<span class="keyword">void</span>)displayLayer:(<span class="built_in">CALayer</span> *)layer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由-drawInContext方法的默认实现调用</span></span><br><span class="line"><span class="comment">// 如果没有实现displayLayer:，就会调用该方法</span></span><br><span class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx;</span><br></pre></td></tr></table></figure><p>给个简单的Demo：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    view.center = <span class="keyword">self</span>.view.center;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:view];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CALayer</span> *layer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    [view.layer addSublayer:layer];</span><br><span class="line">    layer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 设置代理</span></span><br><span class="line">    layer.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// display方法必须手动调用，不然不会执行绘制</span></span><br><span class="line">    [layer display]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx &#123;</span><br><span class="line">    <span class="comment">// 画一个圆环</span></span><br><span class="line">    <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="built_in">UIColor</span> redColor].CGColor);</span><br><span class="line">    <span class="built_in">CGContextStrokeEllipseInRect</span>(ctx, layer.bounds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，<code>[layer display]</code>需要手动调用，<code>CALayer</code>不会自动重绘它的内容，而是把重绘决定权交给了开发者。</p></blockquote><h4 id="drawRect"><a href="#drawRect" class="headerlink" title="drawRect"></a>drawRect</h4><p>理解了<code>CALayerDelegate</code>再来看<code>drawRect</code>就简单很多了，<code>UIView</code>把<code>CALayerDelegate</code>设置为自己，并实现了<code>displayLayer:</code>，我们不再需要关心这些细节，只需要重写<code>drawRect</code>，在方法内绘制<code>backing image</code>即可。</p><p><strong>drawRect调用时机</strong></p><p>当<code>UIView</code>在屏幕上出现的时候，<code>drawRect</code>方法就会被自动调用。然后内容就会被缓存起来直到它需要被更新，通常是因为手动调用了<code>setNeedsDisplay</code>，或影响到表现效果的属性值被更改时，如bounds属性。</p><p>需要注意的是，调用<code>setNeedsDisplay</code>后，不会马上触发<code>drawRect</code>，而是要等到接收到RunLoop的<code>kCFRunLoopBeforeWaiting</code>通知后触发<code>drawRect</code>，如下图所示。</p><p><img src="images/15436511549803.jpg" alt="drawRect调用栈"></p><p><strong>如非必须，勿重写drawRect</strong></p><p><code>drawRect</code>方法没有默认的实现，因为对UIView来说，<code>backing image</code>并不是必须的。如果<code>UIView</code>检测到<code>drawRect</code>方法被调用了，它就会为视图分配一个<code>backing image</code>，这个<code>backing image</code>的像素尺寸等于<code>视图大小 * contentsScale</code>；反之则不会创建<code>backing image</code>，因此如果没有自定义绘制的任务就不要在重写一个空的<code>drawRect</code>。</p><blockquote><p>在做实验的时候发现了一个有趣现象，在同一个RunLoop循环里，先调用<code>setNeedsDisplay</code>，再设置<code>view.layer</code>的<code>contents</code>，系统就不会调用<code>drawRect</code>方法了(难道是因为设置<code>contents</code>会把<code>needsDisplay</code>设置为NO？？)。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果我们只是写一个简单的登录界面，其实用<code>UIView</code>这种高级接口就够了。但是为了实现复杂UI与丝滑体验，使用<code>Core Animation</code>就是一个很好的选择（缺点是门槛高点，编码复杂度要高些）。<br>本文要点总结如下：</p><ol><li><code>Core Animation</code>是一个负责处理图层、屏幕绘制、动画等的复合引擎</li><li><code>UIView</code>是对<code>CALayer</code>的高级封装，每个<code>UIView</code>包含一个<code>CALayer</code>实例。</li><li>在<code>CALayer</code>上绘制内容，需要设置它的<code>backing image</code>，有两种方式：<ul><li>设置CALayer的<code>contents</code>属性</li><li>直接用<code>Core Graphics</code>绘制</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文是我阅读书籍《iOS CORE ANIMATION ADVANCED TECHNIQUES》的读书笔记，感谢原书作者及译者的分享！&lt;br&gt;推荐大家有时间可以读读英文版原书，虽然年代比较久远了，但是还是能有不少收获。英文不好的同学可以看&lt;a hr
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Core Animation学习笔记（二）- 图层几何布局</title>
    <link href="https://crmo.github.io/2018/12/02/Core%20Animation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://crmo.github.io/2018/12/02/Core Animation学习笔记（二）/</id>
    <published>2018-12-01T16:00:00.000Z</published>
    <updated>2018-12-04T13:48:45.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Layout"><a href="#一、Layout" class="headerlink" title="一、Layout"></a>一、Layout</h2><p>UIView有三个比较重要的布局属性：<code>frame</code>，<code>bounds</code>和<code>center</code>，<code>CALayer</code>对应地叫做<code>frame</code>，<code>bounds</code>和<code>position</code>。<br><code>frame</code>是图层在父图层上的坐标，<code>bounds</code>是内部坐标（{0, 0}通常是左上角）。<br><code>center</code>和<code>position</code>要难理解一些，简单来说他们定义了<code>anchorPoint</code>在父图层中的位置（后面会详细说明）。</p><p><img src="/images/15437391858284.jpg" alt="15437391858284"></p><p><code>frame</code>其实是一个虚拟属性，是根据<code>bounds</code>，<code>position</code>和<code>transform</code>计算而来，所以当其中任何一个值发生改变，<code>frame</code>都会变化。相反，改变<code>frame</code>的值同样会影响到他们当中的值。</p><p>这里有一个容易忽视的细节，我们通常开发的时候<code>frame</code>与<code>bounds</code>的宽高都相等。但是当对图层做变换的时候（旋转或者缩放）frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，这时候它们将不再相等。如下图所示。</p><p><img src="/images/15437396721415.jpg" alt="15437396721415"></p><h2 id="二、anchorPoint、position、center三者不得不说的故事"><a href="#二、anchorPoint、position、center三者不得不说的故事" class="headerlink" title="二、anchorPoint、position、center三者不得不说的故事"></a>二、anchorPoint、position、center三者不得不说的故事</h2><p>要彻底理解<code>position</code>究竟是什么鬼，首先我们得搞懂什么是<code>anchorPoint</code>。它可以理解为一个固定图层的图钉，它的主要作用是作为变换的支点，比如在旋转图层时，就会以<code>anchorPoint</code>为圆心旋转（一起来想象一下）。</p><p><img src="/images/15437419896060.jpg" alt="15437419896060"></p><p><code>anchorPoint</code>用相对坐标表示，它表示相对于图层的位置，取值范围0-1。</p><ul><li>左上角：(0,0)</li><li>右下角：(1,1)</li><li>中心：(0.5,0.5)</li></ul><p>而<code>position</code>就表示<code>anchorPoint</code>在父图层的坐标，下面这张图非常的清晰明了。</p><p><img src="/images/15437425063586.jpg" alt="15437425063586"></p><p>由于<code>anchorPoint</code>是<code>CALayer</code>的属性，默认值是(0.5,0.5)，也就是中心。而<code>UIView</code>没有这个属性，因此<code>UIView</code>的<code>center</code>属性就表示view的中心点在父view的坐标（命名为center可以说是非常的直观）。</p><h2 id="Coordinate-Systems"><a href="#Coordinate-Systems" class="headerlink" title="Coordinate Systems"></a>Coordinate Systems</h2><h3 id="坐标系转换"><a href="#坐标系转换" class="headerlink" title="坐标系转换"></a>坐标系转换</h3><p>CALayer给不同坐标系之间的图层转换提供了一些工具类方法，这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGPoint</span>)convertPoint:(<span class="built_in">CGPoint</span>)point fromLayer:(<span class="built_in">CALayer</span> *)layer;</span><br><span class="line">- (<span class="built_in">CGPoint</span>)convertPoint:(<span class="built_in">CGPoint</span>)point toLayer:(<span class="built_in">CALayer</span> *)layer;</span><br><span class="line">- (<span class="built_in">CGRect</span>)convertRect:(<span class="built_in">CGRect</span>)rect fromLayer:(<span class="built_in">CALayer</span> *)layer;</span><br><span class="line">- (<span class="built_in">CGRect</span>)convertRect:(<span class="built_in">CGRect</span>)rect toLayer:(<span class="built_in">CALayer</span> *)layer;</span><br></pre></td></tr></table></figure><h3 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h3><p>常规说来，在iOS上，一个图层的<code>position</code>位于父图层的左上角，但是在Mac OS上，通常是位于左下角。<code>Core Animation</code>可以通过<code>geometryFlipped</code>属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个BOOL类型。在iOS上通过设置它为YES意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们的<code>geometryFlipped</code>属性也设为YES）。</p><h3 id="Z轴"><a href="#Z轴" class="headerlink" title="Z轴"></a>Z轴</h3><p>和<code>UIView</code>严格的二维坐标系不同，<code>CALayer</code>存在于一个三维空间当中。除了我们已经讨论过的<code>position</code>和<code>anchorPoint</code>属性之外，<code>CALayer</code>还有另外两个属性，<code>zPosition</code>和<code>anchorPointZ</code>，二者都是在Z轴上描述图层位置的浮点类型。</p><h2 id="Hit-testing"><a href="#Hit-testing" class="headerlink" title="Hit testing"></a>Hit testing</h2><p><code>CALayer</code>并不关心事件响应链，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：<code>containsPoint:</code>和<code>hitTest:</code>。<br><code>containsPoint:</code>接受一个在本图层坐标系下的CGPoint，如果这个点在layer的frame范围内就返回YES。<br><code>hitTest:</code>方法接受一个CGPoint类型参数，它返回这个点所在layer，也就是layer本身，或者叶子节点。</p><h2 id="自动布局"><a href="#自动布局" class="headerlink" title="自动布局"></a>自动布局</h2><p><code>CALayer</code>不支持自动布局，需要实现<code>CALayerDelegate</code>的函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutSublayersOfLayer:(<span class="built_in">CALayer</span> *)layer;</span><br></pre></td></tr></table></figure><p>然后手动管理布局，非常的不友好，这是一个为什么不直接用<code>CALayer</code>，而是要用<code>UIView</code>的重要原因。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>理解frame，bounds，center，position，anchorPoint对于理解图层布局很重要。</li><li><code>CALayer</code>没有处理事件响应链，需要手动处理。</li><li><code>CALayer</code>不支持自动布局。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://kittenyang.com/anchorpoint/" target="_blank" rel="noopener">这将是你最后一次纠结position与anchorPoint！</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Layout&quot;&gt;&lt;a href=&quot;#一、Layout&quot; class=&quot;headerlink&quot; title=&quot;一、Layout&quot;&gt;&lt;/a&gt;一、Layout&lt;/h2&gt;&lt;p&gt;UIView有三个比较重要的布局属性：&lt;code&gt;frame&lt;/code&gt;，&lt;code&gt;bo
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>App Store上架漫谈</title>
    <link href="https://crmo.github.io/2018/11/15/App%20Store%E4%B8%8A%E6%9E%B6%E6%BC%AB%E8%B0%88/"/>
    <id>https://crmo.github.io/2018/11/15/App Store上架漫谈/</id>
    <published>2018-11-14T16:00:00.000Z</published>
    <updated>2018-12-02T07:46:38.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近忙着写Bug😂，好久没有写文章了。今天和大家分享下我最近上架第二个独立开发的APP“识之”的上架经验（其实就是为了做一波广告）。</p><blockquote><p>重点来了！！！<br>识之，人工智能AI识别，动物、植物、Logo、汽车车型、菜品、通用（识别各种东西）统统可以识别。只需用相机拍一张照片，或者从相册中选择要识别的图片，即可得到答案。使用完全免费使用，解决您的知识焦虑！<br>下载链接：<a href="http://t.cn/EAs5ubq" target="_blank" rel="noopener">http://t.cn/EAs5ubq</a><br>五星好评截图返现💕</p></blockquote><p>好了，重点结束了，接下来聊点闲话😏。</p><h2 id="聊聊审核"><a href="#聊聊审核" class="headerlink" title="聊聊审核"></a>聊聊审核</h2><p>“识之”是我上架的第二个独立开发APP，2天搞定审核成功上架（第一个APP是3天），有些心得和大家分享下。<br>不得不说苹果审核团队现在的效率很高，一般一天就可以审核完成，我记得我刚开始做iOS那会，审核一次要一周，真的太漫长了。<br>每次提交新版本之后，第二天早上起床第一件事情就是收邮件。经常会看到这样的标题的邮件，心态瞬间蹦了。</p><p><img src="/images/WechatIMG82.jpeg" alt="WechatIMG82"></p><p>但是不要慌，这只是苹果怀疑你存在一些问题，并不代表真的有问题。先静下心来，读读这篇<a href="https://developer.apple.com/cn/app-store/review/guidelines" target="_blank" rel="noopener">上架过审秘籍</a>。</p><p>然后<code>仔细阅读</code>苹果的答复，仔细揣摩审核团队的用意。把审核团队当做小白用户，站在他们的角度来思考他们提出的问题，然后对照<a href="https://developer.apple.com/cn/app-store/review/guidelines" target="_blank" rel="noopener">苹果审核条例</a>仔细检查。如果确认自己不存在问题，就直接回复邮件说明，针对审核团队提出的问题详细解释（不需要重新提交二进制文件），一般隔天就能收到审核团队的答复。</p><blockquote><p>这里有个技巧我屡试不爽，提交审核时，可以附上一个演示视频。因为APP的业务逻辑一般比较复杂，单靠文字描述难以表述清楚（想想产品经理当面交代的功能都经常被做偏，别说短短一封邮件了），而且长文本会让人看着很抓狂，审核团队一天密集的审核，看着长篇大论心情自然不好。这时候附上一个精心录制的演示视频，一眼就可以看懂你的APP是干嘛的。<br>视频推荐上传到Youtube方便国外观看。</p></blockquote><p>如果确认APP真的存在问题，那就乖乖的修改吧，修改之后重新提交审核（额。。。马甲包什么的不在本文的讨论范围）。</p><blockquote><p>今年10月后上架的APP都需要提供隐私政策，<a href="http://crmo.github.io/2018/10/13/应对苹果隐私政策看我就够了/">这篇文章</a>教你轻松应对。</p></blockquote><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><p>这里和大家分享下“识之”的上架过程，”香蕉播放器“的上架过程看<a href="http://crmo.github.io/2018/10/07/记“香蕉播放器”上架的辛酸历程/">这篇文章</a>。<br>提交的第二天就收到拒信，涉及到的条款：<code>3.1.4</code>、<code>4.2</code>（这次终于没有刺激的2.1大礼包了）。下面是审核团队的回复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Guideline 3.1.4 - Business - Payments - Content Codes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Your app enables additional features or functionality when used with augmented reality markers or QR codes. However, those features are not available in the app to users without the necessary markers.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">To resolve this issue, please provide a means to access these features from within the app, such as through achievements or in-app purchase. If they can be freely obtained, such as through a link to a website, please revise your app to include clear instructions for obtaining the necessary markers or codes.</span><br><span class="line"></span><br><span class="line">Please note that apps cannot require users to purchase unrelated products or engage in advertising or marketing activities to unlock app functionality.</span><br><span class="line"></span><br><span class="line">Guideline 4.2 - Design - Minimum Functionality</span><br><span class="line"></span><br><span class="line">We noticed that your app includes an AR or QR scanner but does not include any additional content or functionality unless the user has access to the AR marker or QR code. While we understand that your app displays additional content when an AR marker or QR code is scanned, to users who do not have access to the AR markers or QR codes, your app only appears to display a camera view.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">We encourage you to provide your users with additional content in your app, including directions on how to use your app and information on how to obtain any necessary AR markers or QR codes.</span><br><span class="line"></span><br><span class="line">To ensure users have the best experience, apps should provide valuable utility or entertainment, draw people in by offering compelling capabilities or content, or enable people to do something they couldn&apos;t do before or in a way they couldn&apos;t do it before.</span><br></pre></td></tr></table></figure><p>阅读理解时间开始了，第一遍看完我是一脸懵逼的，回复中提到了两个关键词<code>AR markers</code>和<code>QR codes</code>，可是我根本没有用到这些东西。于是我冷静下来，查了下审核指南。</p><p><img src="/images/15422845505208.jpg" alt="15422845505208"></p><p><img src="/images/15422846190717.jpg" alt="15422846190717"></p><p>结合审核指南就能理解审核团队的用意了，他们没有理解我的APP的功能，我的APP主要页面是一个相机，拍一张照片，然后识别图片中的物体是啥。<br>审核团队的理解是APP需要配合特殊的实体物体或者二维码才能正常使用，否则APP就没有任何用途。这显然是误解我了，于是我录制了一个视频，详细的演示了APP的功能，配上文字说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dear Apple Review Team:</span><br><span class="line">    Thank you for your patience review, we have done a detailed check on the following questions.</span><br><span class="line">    Our app does not depend on specific markers or QR codes,users can use our app recognize anything,such as cars,plants,animals,dishes,logos.</span><br><span class="line">    We made this app to help users identify objects around them.For example, if the user sees a beautiful plant and wants to know what it is,he can open our app，then take a photo use camera,our app will tell him what is this in the photo.</span><br><span class="line">    We recorded a detailed demo video to illustrate our features:https://youtu.be/1okyq-ZJGzU</span><br><span class="line">    Finally, thank you again for your hard review.</span><br></pre></td></tr></table></figure><p>第二天上架成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近忙着写Bug😂，好久没有写文章了。今天和大家分享下我最近上架第二个独立开发的APP“识之”的上架经验（其实就是为了做一波广告）。&lt;/p
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>聊聊iOS开发中的JSBridge</title>
    <link href="https://crmo.github.io/2018/10/22/%E8%81%8A%E8%81%8AiOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84JSBridge/"/>
    <id>https://crmo.github.io/2018/10/22/聊聊iOS开发中的JSBridge/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-22T13:40:18.102Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/tower-bridge-2324875_1280.jpg" alt="tower-bridge-2324875_1280"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hybrid App（混合模式移动应用）是指介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。谈到Hybrid App，JS与Native code的交互就是一个绕不开的话题，这时就需要“一座桥”来连接两端。<br><code>JSBridge</code>架起了一座连接<code>JavaScript</code>与<code>Native Code</code>的桥梁，让两端可以相互调用。</p><p><img src="/images/JSBridge.png" alt="JSBridge"></p><p>本文基于<code>UIWebView</code>，将会分别介绍3种方案。通过<code>Iframe</code>、<code>Ajax</code>、<code>JSCore</code>来实现JSBridge，涉及到的<a href="https://github.com/crmo/CRJSBridgeDemo" target="_blank" rel="noopener">Demo地址</a>，顺手给个Star呗😏。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h3><p>废话不多说，直入主题，首先讲的这种方案比较常见。<code>WebViewJavascriptBridge</code>与<code>Cordava</code>都是采用的该方案（推荐看看我之前的文章<a href="http://crmo.github.io/2018/05/09/Cordova源码解析/">Cordova源码解析</a>）。<br>核心思路就是在UIWebView拦截Iframe的src，双方提前约定好协议，例如<code>https://__jsbridge__</code>就是一次调用开始。<br>可以学习<code>Cordova</code>的策略，将并发的多次调用打包合并为一次处理，可以优化性能。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>1.JS暴露一个方法给Native，接收执行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">responseFromObjC</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!callback) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    callback(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Native实现<code>UIWebView</code>的代理，在<code>webView:shouldStartLoadWithRequest:navigationType:</code>方法拦截请求，识别到特定URL，开始一次调用流程。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截JS调用原生核心方法</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = request.URL;</span><br><span class="line">    <span class="comment">// 判断url是否是JSBridge调用</span></span><br><span class="line">    <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@"__jsbridge__"</span>]) &#123;</span><br><span class="line">       <span class="comment">// 处理JS调用Native</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.JS开启一个Iframe，加载一个特定的URL，开始一次调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.style.display = <span class="string">'none'</span>;</span><br><span class="line">iframe.src = <span class="string">'https://__jsbridge__?action='</span>+ action + <span class="string">'&amp;data='</span> + data;</span><br><span class="line"><span class="built_in">document</span>.documentElement.appendChild(iframe);</span><br></pre></td></tr></table></figure><p>4.Native方法执行完成后，调用JS方法<code>responseFromObjC</code>将结果回传给JS。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 获取调用参数，demo的调用方式是：'https://__jsbridge__?action=action&amp;data='</span></span><br><span class="line"><span class="comment">// 参数直接放在query里面的，更好的方案是js暴露一个方法给原生，原生调用方法获取数据</span></span><br><span class="line"><span class="built_in">NSURLComponents</span> *urlComponents = [<span class="built_in">NSURLComponents</span> componentsWithURL:url resolvingAgainstBaseURL:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *queryItems = urlComponents.queryItems;</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *params = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURLQueryItem</span> *queryItem <span class="keyword">in</span> queryItems) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = queryItem.name;</span><br><span class="line">    <span class="built_in">NSString</span> *value = queryItem.value;</span><br><span class="line">    [params setObject:value forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSString</span> *action = params[<span class="string">@"action"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *data = params[<span class="string">@"data"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([action isEqualToString:<span class="string">@"alertMessage"</span>]) &#123;</span><br><span class="line">    <span class="comment">// 调用原生方法，获取数据</span></span><br><span class="line">    <span class="comment">// js暴露方法`responseFromObjC`给原生，原生通过该方法回调</span></span><br><span class="line">    <span class="comment">// 在实际项目中，为了实现实现js并发原生方法，最好带一个callBackID，来区分不同的调用</span></span><br><span class="line">    [webView stringByEvaluatingJavaScriptFromString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"responseFromObjC('%@')"</span>, data]];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [webView stringByEvaluatingJavaScriptFromString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"responseFromObjC('Unkown action'"</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:demo代码为了简化，直接将参数放在URL的query里，如果只传输一些简单数据是没有问题的，更好的方案是JS先将参数存放起来，通过URL传递一个key给Native，再暴露一个通过key取数据的方法，Native主动调用这个方法取。</p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>第二种方案是JS使用<code>XMLHttpRequest</code>发起请求，在Native拦截达到调用的目的。通过自定义<code>NSURLProtocol</code>可以拦截到Ajax请求。Demo里有详细的代码和注释，建议结合Demo一起看。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>1.新建类继承自<code>NSURLProtocol</code>，并注册。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSURLProtocol</span> registerClass:[CRURLProtocol <span class="keyword">class</span>]];</span><br></pre></td></tr></table></figure><p>2.实现自定义<code>NSURLProtocol</code>，在<code>startLoading</code>方法拦截Ajax请求</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startLoading &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [[<span class="keyword">self</span> request] URL];</span><br><span class="line">    <span class="comment">// 拦截“http://__jsbridge__”请求</span></span><br><span class="line">    <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@"__jsbridge__"</span>]) &#123;</span><br><span class="line">       <span class="comment">// 处理JS调用Native</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.JS发起Ajax请求，URL为提前约定的特殊值，例如：http://<strong>jsbridge</strong>。请求参数放在<code>Request Body</code>里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用原生</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callNative</span>(<span class="params">action, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="built_in">window</span>.XMLHttpRequest(),</span><br><span class="line">        url = <span class="string">'http://__jsbridge__'</span>;</span><br><span class="line">        xhr.open(<span class="string">'POST'</span>, url, <span class="literal">false</span>);</span><br><span class="line">        xhr.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                    action: action,</span><br><span class="line">                    data: data</span><br><span class="line">                    &#125;));</span><br><span class="line">        <span class="keyword">return</span> xhr.responseText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.Naive拦截到请求，获取参数，执行Native方法，最后通过Ajax的<code>Response</code>把结果返回给JS。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 2. 从HTTPBody中取出调用参数</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dic = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:<span class="keyword">self</span>.request.HTTPBody options:<span class="built_in">NSJSONReadingAllowFragments</span> error:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSString</span> *action = dic[<span class="string">@"action"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *data = dic[<span class="string">@"data"</span>];</span><br><span class="line"><span class="built_in">NSData</span> *responseData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 根据action转发到不同方法处理，param携带参数</span></span><br><span class="line"><span class="keyword">if</span> ([action isEqualToString:<span class="string">@"alertMessage"</span>]) &#123;</span><br><span class="line">    responseData = [data dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    responseData = [<span class="string">@"Unknown action"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 处理完成，将结果返回给js</span></span><br><span class="line">[<span class="keyword">self</span> sendResponseWithResponseCode:<span class="number">200</span> data:responseData mimeType:<span class="string">@"text/html"</span>];</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendResponseWithResponseCode:(<span class="built_in">NSInteger</span>)statusCode data:(<span class="built_in">NSData</span>*)data mimeType:(<span class="built_in">NSString</span>*)mimeType &#123;</span><br><span class="line">    <span class="built_in">NSHTTPURLResponse</span>* response = [[<span class="built_in">NSHTTPURLResponse</span> alloc] initWithURL:[[<span class="keyword">self</span> request] URL] statusCode:statusCode HTTPVersion:<span class="string">@"HTTP/1.1"</span> headerFields:@&#123;<span class="string">@"Content-Type"</span> : mimeType&#125;];</span><br><span class="line">    </span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">    &#125;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSCore"><a href="#JSCore" class="headerlink" title="JSCore"></a>JSCore</h3><p>前两种方案虽然实现方法不一致，但是思路都是类似的，由于JS不能直接调用Native方法，通过曲线救国的方式，找到一个载体来传递信息。<br>第三种方案就比较直接了，使用iOS7推出的黑科技<code>JavaScriptCore</code>，将Native方法直接暴露给JS，打通两端的数据通道。谈到<code>JavaScriptCore</code>不得不说的是bang590的<code>JSPatch</code>，还有ReactNative、Weex等都是利用<code>JavaScriptCore</code>来实现各种炫酷的功能。(强力推荐一本Lefe_x的书<a href="https://github.com/awesome-tips/iOS-Tips/blob/master/resources/一份走心的JS-Native交互电子书.pdf" target="_blank" rel="noopener">《一份走心的JS-Native交互电子书》</a>，非常精彩)。<br>不过这种方案有个缺陷，<code>UIWebView</code>没有暴露<code>JSContext</code>，虽然可以通过KVC拿到，但是毕竟不是一种完美的解决方案，不知道上架会不会有风险（求知道的同学指教一下）。</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>实现流程就不细说了，流程比较简单，Demo里面有。说说关键实现代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)injectJSBridge &#123;</span><br><span class="line">    <span class="comment">// 获取JSContext</span></span><br><span class="line">    JSContext *context = [_webView valueForKeyPath:<span class="string">@"documentView.webView.mainFrame.javaScriptContext"</span>];</span><br><span class="line">    <span class="comment">// 给JS注入方法callNative</span></span><br><span class="line">    context[<span class="string">@"callNative"</span>] = ^(JSValue *action, JSValue *data) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *actionStr = [action toString];</span><br><span class="line">        <span class="built_in">NSString</span> *dataStr = [data toString];</span><br><span class="line">        <span class="keyword">if</span> ([actionStr isEqualToString:<span class="string">@"alertMessage"</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> dataStr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"Unkown action"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS调用非常简单，一句话搞定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callNative(<span class="string">"alertMessage"</span>, <span class="string">"Hello world!"</span>)</span><br></pre></td></tr></table></figure><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>为了验证三种方案的性能，设计了个简单的实验，分别执行了100、1000、10000次调用，测试手机iPhone X，系统iOS 12，时间对比如下图所示。<br>先说结论，JSCore的性能是最优的，<code>JSCore&gt;Ajax&gt;Iframe</code>。在低并发的时候三种方案差距不大，执行次数10000次时Iframe效率就很低了，Ajax次之，JSCore性能很稳定。当然实际使用的时候不会出现调用10000次这种极限情况。<br><code>Cordova</code>对于并发有个优化策略，很值得参考，将并发的多次调用打包合并为一次处理。</p><p><img src="/images/15401284999756.jpg" alt="15401284999756"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/tower-bridge-2324875_1280.jpg&quot; alt=&quot;tower-bridge-2324875_1280&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS定义长字符串的实用宏</title>
    <link href="https://crmo.github.io/2018/10/16/iOS%E5%AE%9A%E4%B9%89%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%94%A8%E5%AE%8F/"/>
    <id>https://crmo.github.io/2018/10/16/iOS定义长字符串的实用宏/</id>
    <published>2018-10-15T16:00:00.000Z</published>
    <updated>2018-10-17T00:58:11.756Z</updated>
    
    <content type="html"><![CDATA[<p>今天在看<code>WebViewJavascriptBridge</code>源码的时候发现一个神奇的宏，在定义较长字符串时很实用。<br>举个例子，将一段js代码存到一个变量，为了便于阅读需要加入换行，需要在每行结束加上<code>\</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"function() &#123; \</span></span><br><span class="line"><span class="string">if (window.WebViewJavascriptBridge) &#123; \</span></span><br><span class="line"><span class="string">return; \</span></span><br><span class="line"><span class="string">&#125; \</span></span><br><span class="line"><span class="string">&#125;)(); \</span></span><br><span class="line"><span class="string">"</span>;</span><br></pre></td></tr></table></figure><p>这时，可以用宏来优化。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define LONG_STRING_DEFINE(x) #x</span></span><br><span class="line"><span class="built_in">NSString</span> *str = @LONG_STRING_DEFINE(function() &#123;</span><br><span class="line"><span class="keyword">if</span> (window.WebViewJavascriptBridge) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>宏展开后代码如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@";(function() &#123; if (window.WebViewJavascriptBridge) &#123; return; &#125;)();"</span>;</span><br></pre></td></tr></table></figure><h2 id="用Xcode看宏展开"><a href="#用Xcode看宏展开" class="headerlink" title="用Xcode看宏展开"></a>用Xcode看宏展开</h2><p>打开<code>Assistant Editor</code>，选择<code>Preproces</code>，就可以看到展开的宏。</p><p><img src="/images/15396963641371.jpg" alt="15396963641371"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在看&lt;code&gt;WebViewJavascriptBridge&lt;/code&gt;源码的时候发现一个神奇的宏，在定义较长字符串时很实用。&lt;br&gt;举个例子，将一段js代码存到一个变量，为了便于阅读需要加入换行，需要在每行结束加上&lt;code&gt;\&lt;/code&gt;。&lt;/p&gt;
&lt;figu
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>应对iOS隐私政策三步曲</title>
    <link href="https://crmo.github.io/2018/10/13/%E5%BA%94%E5%AF%B9%E8%8B%B9%E6%9E%9C%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>https://crmo.github.io/2018/10/13/应对苹果隐私政策看我就够了/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2018-10-21T15:32:19.907Z</updated>
    
    <content type="html"><![CDATA[<p>国庆假期回来准备提交新版本到App Store，遇到苹果新政策，实测下来影响不大，应对还算比较简单，总结一下分享给大家。</p><h2 id="政策说明"><a href="#政策说明" class="headerlink" title="政策说明"></a>政策说明</h2><p><img src="/images/QQ20181012-090233.png" alt="QQ20181012-090233"></p><p>从2018年10月3号起，所有新提交的App都必须提供隐私条例，<a href="https://developer.apple.com/news/?id=08312018a" target="_blank" rel="noopener">官方连接</a>。</p><p>对于隐私条例，苹果审核条例是这么说明的。</p><p><img src="/images/QQ20181012-085839.png" alt="QQ20181012-085839"></p><p>需要在两个地方提供隐私条例：</p><ol><li>元数据</li><li>应用内有明显的入口</li></ol><h2 id="生成隐私条例"><a href="#生成隐私条例" class="headerlink" title="生成隐私条例"></a>生成隐私条例</h2><p>关于隐私条例，网上有各种模板，弄一个改改就行了，这里推荐一个<a href="https://www.freeprivacypolicy.com" target="_blank" rel="noopener">自动生成的网站</a>。<br>免费生成，还提供一个链接，挂在它们网站，就不用自己搞服务器了。例如<a href="https://www.freeprivacypolicy.com/privacy/view/cb2289ee81ec0d2f61ec1790bccf861d" target="_blank" rel="noopener">我给App生成的隐私条例</a></p><p><img src="/images/QQ20181012-090746.png" alt="QQ20181012-090746"></p><h2 id="集成隐私条例"><a href="#集成隐私条例" class="headerlink" title="集成隐私条例"></a>集成隐私条例</h2><p>第一步：把刚刚生成的URL填在元数据里</p><p><img src="/images/QQ20181012-091050.png" alt="QQ20181012-091050"></p><p>第二步：在应用内加一个页面，开一个WebView加载刚刚生成的URL，例如我就放在了“关于-隐私条例”</p><p>第三步：提交审核时，在备注里面说明，隐私条例的入口在哪里。（这一步可能不要也行，不过为了稳妥我加上了，给苹果审核团队讲清楚总是好的）</p><p>第二天就上架成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;国庆假期回来准备提交新版本到App Store，遇到苹果新政策，实测下来影响不大，应对还算比较简单，总结一下分享给大家。&lt;/p&gt;
&lt;h2 id=&quot;政策说明&quot;&gt;&lt;a href=&quot;#政策说明&quot; class=&quot;headerlink&quot; title=&quot;政策说明&quot;&gt;&lt;/a&gt;政策说明&lt;/
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>记“香蕉播放器”上架的辛酸历程</title>
    <link href="https://crmo.github.io/2018/10/07/%E8%AE%B0%E2%80%9C%E9%A6%99%E8%95%89%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%9D%E4%B8%8A%E6%9E%B6%E7%9A%84%E8%BE%9B%E9%85%B8%E5%8E%86%E7%A8%8B/"/>
    <id>https://crmo.github.io/2018/10/07/记“香蕉播放器”上架的辛酸历程/</id>
    <published>2018-10-06T16:00:00.000Z</published>
    <updated>2018-10-07T08:50:30.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>先说点废话，从事iOS开发以来，一直有一个目标，拥有一个自己的APP上架App Store，并且登上苹果推荐榜单，这可能是大多数iOSer的梦想。在脑子里产生了各种想法，但是发现自己能想到的别人都做了，并且做的很好，加上工作生活上的很多事情（主要是懒😝），一拖就是3年。<br>后来因为自己的真实需求，App Store找不到能满足需求的产品，就做了一个播放器自己用，在中秋假期狠下心来，买了开发者账号（688，心痛！！就当为了梦想充值吧。），把这个播放器上架了。</p><h2 id="购买开发者账号"><a href="#购买开发者账号" class="headerlink" title="购买开发者账号"></a>购买开发者账号</h2><p>关于怎么买个人开发者账号，网上的教程一抓一大把，整个购买流程也没啥好注意的，根据提示一步一步走就OK了。但是到了最后付款环节把我卡了一周（办了两张信用卡。。。），必须要<code>visa+银联</code>双标的信用卡，注意一定要双标，只有visa或者只有银联都不行。<br>付了款一天左右苹果就会发来邮件，提供身份证正反面照片就可以了。</p><h2 id="上架App-Store"><a href="#上架App-Store" class="headerlink" title="上架App Store"></a>上架App Store</h2><p>上架流程就轻车熟路了，打包上传、填写各种APP说明、上传图标、宣传图、提交审核。激动的我一晚上没睡好觉，第二天早上打开邮箱，等待我的居然是<code>2.1大礼包</code>（Guideline 2.1 - Information Needed）。</p><p><img src="/images/WechatIMG59.png" alt="WechatIMG59"></p><p>一看我就懵逼了，上架这么多次第一次遇到这么严厉的回复，感觉分分钟要被封号。经过多方咨询，发现这是苹果今年新推出的大礼包，很多人都遇到过，一般是机器审核回复的，遇到这种情况别慌（除非你是马甲包、或者抄袭的之类的APP），仔细检查条例，然后逐条答复（最好用英文）。<br>最后我还录制了一个视频，来演示我的APP的主要功能，上传到<code>youtube</code>，附在了备注。<br>分享下我的答复模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">尊敬的苹果审核团队：</span><br><span class="line">    感谢您的耐心审核，针对下面问题，我们做了详细的检查</span><br><span class="line">    </span><br><span class="line">关于 Guideline 2.1</span><br><span class="line"></span><br><span class="line">1.1.6 - “香蕉播放器”没有包含任何的虚假与误导信息，全部都是真实有效的</span><br><span class="line">2.3.0 - “香蕉播放器”没有在通过审核后修改任何概念和功能</span><br><span class="line">2.3.1 - “香蕉播放器”没有包含任何隐藏功能，没有包含赌博、彩票网站</span><br><span class="line">3.1.1 - “香蕉播放器”内没有任何内购、支付功能，所有功能都是免费提供给用户</span><br><span class="line">3.2.1 - “香蕉播放器”内部包含任何贷款等金融服务</span><br><span class="line">4.3.0 - “香蕉播放器”功能都是独立开发，不存在抄袭或者大量相似</span><br><span class="line">5.2.1 - “香蕉播放器”没有法人实体和版权风险</span><br><span class="line">5.2.3 - “香蕉播放器”没有提供文件共享服务，或者其它存在版权问题的音视频</span><br><span class="line">5.3.4 - “香蕉播放器”仅在中国区上架，没有违规内容</span><br><span class="line"></span><br><span class="line">关于 Guideline 2.3.7</span><br><span class="line"></span><br><span class="line">我已经按照说明，修改了元数据，请审核团队再次审核。</span><br><span class="line"></span><br><span class="line">最后再次感谢您辛苦的审核。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dear Apple Review Team:</span><br><span class="line">    Thank you for your patience review, we have done a detailed check on the following questions.</span><br><span class="line">    </span><br><span class="line">About Guideline 2.1</span><br><span class="line"></span><br><span class="line">1.1.6 - &quot;Banana Player&quot; does not contain any false and misleading information, all of which are true and effective</span><br><span class="line">2.3.0 - &quot;Banana Player&quot; does not modify any concepts and features after passing the review</span><br><span class="line">2.3.1 - &quot;Banana Player&quot; does not contain any hidden features, does not contain gambling, lottery sites</span><br><span class="line">3.1.1 - There is no in-app purchase and payment function in the “Banana Player”, all functions are provided to the user free of charge.</span><br><span class="line">3.2.1 - &quot;Banana Player&quot; contains any financial services such as loans</span><br><span class="line">4.3.0 - The &quot;Banana Player&quot; feature is developed independently, without plagiarism or a lot of similarity</span><br><span class="line">5.2.1 - &quot;Banana Player&quot; has no legal entity and copyright risk</span><br><span class="line">5.2.3 - &quot;Banana Player&quot; does not provide file sharing services, or other audio and video with copyright issues</span><br><span class="line">5.3.4 - &quot;Banana Player&quot; is only available in China, no illegal content</span><br><span class="line"></span><br><span class="line">About Guideline 2.3.7</span><br><span class="line"></span><br><span class="line">I have modified the metadata according to the instructions, please review the team again.</span><br><span class="line"></span><br><span class="line">Finally, thank you again for your hard review.</span><br></pre></td></tr></table></figure><p>第二天审核通过，成功上架！</p><h2 id="打个广告"><a href="#打个广告" class="headerlink" title="打个广告"></a>打个广告</h2><blockquote><p>下载🔗：<a href="https://dwz.cn/HvVix2hH" target="_blank" rel="noopener">https://dwz.cn/HvVix2hH</a></p></blockquote><p>“香蕉播放器”是我独立开发的第一款APP，免费无广告。主要功能在手机上播放从网盘、光盘、网站下载的音频资料、课程、音乐。无需数据线，用Wi-Fi就可以拷贝文件到手机，自动记录播放进度。<br>如果有需求可以支持一波，有什么问题欢迎联系我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;先说点废话，从事iOS开发以来，一直有一个目标，拥有一个自己的APP上架App Store，并且登上苹果推荐榜单，这可能是大
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>记一个行结束符引发的JS报错</title>
    <link href="https://crmo.github.io/2018/09/05/%E8%AE%B0%E4%B8%80%E4%B8%AA%E8%A1%8C%E7%BB%93%E6%9D%9F%E7%AC%A6%E5%BC%95%E5%8F%91%E7%9A%84JS%E6%8A%A5%E9%94%99/"/>
    <id>https://crmo.github.io/2018/09/05/记一个行结束符引发的JS报错/</id>
    <published>2018-09-04T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近遇到一个神奇的Bug，通过<code>UIWebView</code>的<code>stringByEvaluatingJavaScriptFromString:</code>方法执行一段<code>JavaScript</code>代码时，<code>JavaScript</code>报错:</p><blockquote><p>SyntaxError: Unexpected EOF</p></blockquote><p>经过仔细的排查，发现待执行的<code>JavaScript</code>代码里面包含<code>U+2028</code>字符。还找到了<a href="https://stackoverflow.com/questions/2965293/javascript-parse-error-on-u2028-unicode-character" target="_blank" rel="noopener">Stack Overflow相关讨论</a>。<br><code>JavaScript</code>解析器会把行分隔符<code>U+2028</code>和段落分隔符<code>U+2029</code>解析成一行的结束，代码里要是包含这两个字符相当于换行，例如：</p><blockquote><p>alert(“\u2028”)</p></blockquote><p>就会被解析为</p><blockquote><p>alert(“<br>“)</p></blockquote><p>于是就产生了语法错误。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我用的方法比较简单、粗暴，在执行<code>JavaScript</code>代码前，直接过滤掉这两个字符。代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line">    javaScriptString = [javaScriptString stringByReplacingOccurrencesOfString:<span class="string">@"\u2028"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    javaScriptString = [javaScriptString stringByReplacingOccurrencesOfString:<span class="string">@"\u2029"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    <span class="built_in">NSString</span>* ret = [(<span class="built_in">UIWebView</span>*)_engineWebView stringByEvaluatingJavaScriptFromString:javaScriptString];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最近遇到一个神奇的Bug，通过&lt;code&gt;UIWebView&lt;/code&gt;的&lt;code&gt;stringByEvaluating
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>从一个AFNetworking循环引用说起</title>
    <link href="https://crmo.github.io/2018/08/28/%E4%BB%8E%E4%B8%80%E4%B8%AAAFNetworking%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E8%AF%B4%E8%B5%B7/"/>
    <id>https://crmo.github.io/2018/08/28/从一个AFNetworking循环引用说起/</id>
    <published>2018-08-27T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文分析使用代码是<a href="https://github.com/AFNetworking/AFNetworking/releases" target="_blank" rel="noopener">AFNetworking 3.2.1</a></p></blockquote><p>最近使用<code>Instruments</code>中的<code>Leaks</code>分析项目内存泄露，发现了一个AFNetworking的循环引用。如下图所示：</p><p><img src="/images/15354171666142.jpg" alt="15354171666142"></p><p>通过调用栈发现产生泄露的代码在这里：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AFURLSessionManager.m</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="comment">// ... 初始化代码，省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导致循环引用的方法</span></span><br><span class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其它初始化代码，省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致原因就是AFURLSessionManager引用NSURLSession，同时设置NSURLSession的delegate为自己，NSURLSession会强引用delegate，于是产生了循环引用。</p><blockquote><p>关于NSURLSession的delegate官方说明：<br>This delegate object is responsible for handling authentication challenges, for making caching decisions, and for handling other session-related events. The session object keeps a strong reference to this delegate until your app exits or explicitly invalidates the session. If you do not invalidate the session, your app leaks memory until it exits.</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在AFNetworking官方issues找到了相关的问题<a href="https://github.com/AFNetworking/AFNetworking/issues/1528" target="_blank" rel="noopener">Possible memory leak in AFURLSessionManager</a>。作者的回答如下：</p><p><img src="/images/15353328585634.jpg" alt="15353328585634"></p><p>解决方案有两种：</p><ol><li>这是最常见也是作者推荐的方法，只创建一个AFURLSessionManager，整个APP共享，虽然还是有循环引用，但是就没有内存泄露的问题了。</li><li>如果要使用多个AFURLSessionManager，在使用完成后手动调用<code>invalidateSessionCancelingTasks:</code>来断开循环引用。（这种方案不推荐，具体原因看下一小节）</li></ol><h2 id="AFURLSessionManager复用"><a href="#AFURLSessionManager复用" class="headerlink" title="AFURLSessionManager复用"></a>AFURLSessionManager复用</h2><p>关于AFURLSessionManager是否使用单例这个问题，官方demo使用的是单例，在苹果官方文档找到这么一段话</p><blockquote><p>With the NSURLSession API, your app creates one or more sessions, each of which coordinates a group of related data transfer tasks. For example, if you’re creating a web browser, your app might create one session per tab or window, or one session for interactive use and another for background downloads. Within each session, your app adds a series of tasks, each of which represents a request for a specific URL (following HTTP redirects, if necessary).</p></blockquote><p>我的理解是这样的，根据使用场景的不同，这个问题有不同的答案，在大多数场景下APP都是在和同一服务器打交道，一个<code>session</code>就够了，如果有连接多个服务器、或者后台下载等功能需求，可以给每个服务器、后台下载任务创建单独的<code>session</code>（但是也不能每个请求都单独创建session）。</p><p>在查找资料的时候，我发现有博客提到单例seesion可以减少TCP三次握手，动手验证下：</p><p>多个网络请求复用一个<code>AFURLSessionManager</code>，连续发两个网络请求，用<code>Wireshark</code>抓包可以看到，第二次网络请求复用了第一次的TCP连接，没有做三次握手。</p><p><img src="/images/15354191775340.jpg" alt="15354191775340"></p><p>下图是每次网络请求都新建一个<code>AFURLSessionManager</code>的抓包，可以看到每个网络请求都进行了TCP三次握手。</p><p><img src="/images/15354193039698.jpg" alt="15354193039698"></p><p>实验结果的确如网上所说，复用<code>AFURLSessionManager</code>可以减少三次握手，提升效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文分析使用代码是&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AFNetworking 3.2.1&lt;/
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS模拟器安装debug包</title>
    <link href="https://crmo.github.io/2018/08/21/iOS%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AE%89%E8%A3%85debug%E5%8C%85/"/>
    <id>https://crmo.github.io/2018/08/21/iOS模拟器安装debug包/</id>
    <published>2018-08-20T16:00:00.000Z</published>
    <updated>2019-03-07T01:03:01.793Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目是Hybrid的平台，有第三方人员需要在上面开发H5应用，但是release包不能调试H5，只有debug报可以调试，但是项目源码不能交给第三方，在google搜索了下，发现一篇霜神的<a href="https://juejin.im/post/57b01f298ac247005f0acb0a" target="_blank" rel="noopener">文章</a>，讲的是debug包可以拷贝到其它机器运行，于是实践了一波。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>Xcode</li><li>Command Line Tools</li><li>ios-sim</li></ul><blockquote><p>ios-sim安装命令：npm install ios-sim -g</p></blockquote><h2 id="拷贝本地的debug包"><a href="#拷贝本地的debug包" class="headerlink" title="拷贝本地的debug包"></a>拷贝本地的debug包</h2><ol><li>run一次需要拷贝的项目，安装到模拟器上</li></ol><ol><li>执行下面命令行，需要注意的是<code>目标路径/xxx.zip</code>就是拷贝出来的debug应用包，需要替换为自己的路径，例如<code>/Users/crmo/Desktop/debug/debug.zip</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ditto -ck --sequesterRsrc --keepParent `ls -1 -d -t ~/Library/Developer/Xcode/DerivedData/*/Build/Products/*-iphonesimulator/*.app | head -n 1` 目标路径/xxx.zip</span><br></pre></td></tr></table></figure><h2 id="拷贝debug包到其它模拟器"><a href="#拷贝debug包到其它模拟器" class="headerlink" title="拷贝debug包到其它模拟器"></a>拷贝debug包到其它模拟器</h2><h3 id="1-获取模拟器列表"><a href="#1-获取模拟器列表" class="headerlink" title="1. 获取模拟器列表"></a>1. 获取模拟器列表</h3><blockquote><p>ios-sim showdevicetypes</p></blockquote><p>可以看到类似于下面的输出，就是本机可用的模拟器，选择一个需要运行的模拟器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">~ ios-sim showdevicetypes</span><br><span class="line">Apple-Watch-38mm, watchOS 4.3</span><br><span class="line">Apple-Watch-42mm, watchOS 4.3</span><br><span class="line">Apple-Watch-Series-2-38mm, watchOS 4.3</span><br><span class="line">Apple-Watch-Series-2-42mm, watchOS 4.3</span><br><span class="line">iPhone-7-Plus, 10.3</span><br><span class="line">iPhone-7-Plus, 11.4</span><br><span class="line">Apple-Watch-Series-3-38mm, watchOS 4.3</span><br><span class="line">Apple-Watch-Series-3-42mm, watchOS 4.3</span><br><span class="line">iPhone-5s, 11.4</span><br><span class="line">iPhone-6, 11.4</span><br><span class="line">iPhone-6-Plus, 11.4</span><br><span class="line">iPhone-6s, 11.4</span><br><span class="line">iPhone-6s-Plus, 11.4</span><br><span class="line">iPhone-7, 11.4</span><br><span class="line">iPhone-SE, 11.4</span><br><span class="line">iPad-Air, 11.4</span><br><span class="line">iPad-Air-2, 11.4</span><br><span class="line">iPhone-8, 11.4</span><br><span class="line">iPhone-8-Plus, 11.4</span><br><span class="line">iPhone-X, 11.4</span><br></pre></td></tr></table></figure><h3 id="2-在模拟器上启动debug包"><a href="#2-在模拟器上启动debug包" class="headerlink" title="2. 在模拟器上启动debug包"></a>2. 在模拟器上启动debug包</h3><blockquote><p>ios-sim launch 应用包路径/xxx.app –devicetypeid 模拟器</p></blockquote><p>需要说明的是，debug.zip解压后就可以得到对应应用的.app文件，例如我的debug包放在<code>/Users/crmo/Desktop/debug/debug.app</code>，模拟器选择iPhone-8，最终的命令是</p><blockquote><p>ios-sim launch /Users/crmo/Desktop/debug/debug.app –devicetypeid iPhone-8</p></blockquote><p>或者将应用直接安装到模拟器上</p><blockquote><p>ios-sim install /Users/crmo/Desktop/debug/debug.app –devicetypeid iPhone-8</p></blockquote><h2 id="simctl-was-not-found错误解决"><a href="#simctl-was-not-found错误解决" class="headerlink" title="simctl was not found错误解决"></a>simctl was not found错误解决</h2><p>在实践时测试机的<code>Command Line Tools</code>没有配置好，出现报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">simctl was not found.</span><br><span class="line">Check that you have Xcode 8.x installed:</span><br><span class="line">xcodebuild --versionCheck that you have Xcode 8.x selected:</span><br><span class="line">xcode-select --print-path</span><br></pre></td></tr></table></figure><p><strong>解决办法：</strong></p><p>1.首先确保正确安装了Command Line Tools，</p><blockquote><p>卸载Command Line Tools:rm -rf /Library/Developer/CommandLineTools<br>安装Command Line Tools:xcode-select –install</p></blockquote><p>2.在xcode配置一下Command Line Tools，如下图所示</p><p><img src="/images/15348328228775.jpg" alt="15348328228775"></p><hr><p>参考博客：</p><ul><li><a href="http://www.hudongdong.com/bug/772.html" target="_blank" rel="noopener">unable to find utility “simctl”的解决方案</a></li><li><a href="https://juejin.im/post/57b01f298ac247005f0acb0a" target="_blank" rel="noopener">给 iOS 模拟器 “安装”app 文件</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于项目是Hybrid的平台，有第三方人员需要在上面开发H5应用，但是release包不能调试H5，只有debug报可以调试，但是项目源码不能交给第三方，在google搜索了下，发现一篇霜神的&lt;a href=&quot;https://juejin.im/post/57b01f298
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>dispatch_sync死锁问题</title>
    <link href="https://crmo.github.io/2018/08/03/dispatch_sync%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <id>https://crmo.github.io/2018/08/03/dispatch_sync死锁问题/</id>
    <published>2018-08-02T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>使用<code>dispatch_sync</code>的时候要小心谨慎，稍不注意就会导致死锁问题，先看两个典型的案例：</p><p>案例一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)deadlock1 &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)deadlock2 &#123;</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_sync(queue1, ^&#123;</span><br><span class="line">        dispatch_sync(queue2, ^&#123;</span><br><span class="line">            dispatch_sync(queue1, ^&#123;</span><br><span class="line">                NSLog(@&quot;&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个案例死锁的原因都是同一个串行队列的任务相互等待。 当然实际工程中遇到的死锁问题会更加复杂，难以分析。</p><h2 id="典型误区"><a href="#典型误区" class="headerlink" title="典型误区"></a>典型误区</h2><p>在阅读相关书籍、博客都提到了一个方法<code>dispatch_get_current_queue()</code>，通过这个方法可以获取到当前队列，于是有人就用它来解决死锁问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)safeSync:(void(^)())block &#123;</span><br><span class="line">    if (!block) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dispatch_get_current_queue() == queue) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            block();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一眼看起来天衣无缝，对于案例一的确可以完美解决，但是对于案例二这种对队列的情况就判断不了。难怪苹果在iOS6就注释了这个方法。</p><hr><p>推荐阅读：</p><p><a href="https://www.objc.io/issues/2-concurrency/thread-safe-class-design/#pitfalls-of-gcd" target="_blank" rel="noopener">Thread-Safe Class Design</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;dispatch_sync&lt;/code&gt;的时候要小心谨慎，稍不注意就会导致死锁问题，先看两个典型的案例：&lt;/
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UIWebView获取详细浏览记录</title>
    <link href="https://crmo.github.io/2018/08/01/UIWebView%E8%8E%B7%E5%8F%96history/"/>
    <id>https://crmo.github.io/2018/08/01/UIWebView获取history/</id>
    <published>2018-07-31T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.824Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所用方法会使用到苹果私有API，上架APP Store请谨慎使用。</p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>获取<code>UIWebView</code>的前进后退的浏览记录，举个例子，比如从A-&gt;B-&gt;C-&gt;B，此时B上一页是A，下一页是C，需要获取A、C的URL信息。</p><blockquote><p>WKWebView暴露了这个属性，<code>WKBackForwardList *backForwardList</code>。可以很容易的取到，无奈项目还是使用的<code>UIWebView</code>，于是有了后面的探索。</p></blockquote><p>首先在<code>UIWebView</code>提供的API里找，相关的API只有<code>canGoBack</code>和<code>canGoForward</code>，命名很直观，是否可以后退和前进，这条路走不通。<br>想到是否可以通过JS的Window.history获取到，查了下API，唯一一个有点像的<code>length</code>属性，智能取到浏览记录中的所有URL的数量，不区分前后，比如在上面提到的例子中，在B页面取到的<code>length</code>是3，而且不能取出具体的URL。</p><p><img src="/images/15325235986699.jpg" alt="15325235986699"></p><p>无奈只有上源码了，我下载的是<a href="https://opensource.apple.com/release/ios-110.html" target="_blank" rel="noopener">“WebKit-7604.1.38.0.7”和“WebCore-7604.1.38.0.7”</a>。</p><h2 id="Window-History-length实现本质"><a href="#Window-History-length实现本质" class="headerlink" title="Window.History.length实现本质"></a>Window.History.length实现本质</h2><p>在WebCore里面找到了JS方法<code>Window.History.length</code>实现的本质，上代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebCore History.cpp</span></span><br><span class="line"><span class="keyword">unsigned</span> History::length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_frame)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span>* page = m_frame-&gt;page();</span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> page-&gt;backForward().count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebCore BackForwardController.cpp</span></span><br><span class="line"><span class="keyword">int</span> BackForwardController::count() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// count = 当前页之前的页面总数 + 当前页之后的页面总数 + 1</span></span><br><span class="line">    <span class="keyword">return</span> m_client-&gt;backListCount() + <span class="number">1</span> + m_client-&gt;forwardListCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>WebCore</code>里面<code>backListCount()</code>、<code>forwardListCount()</code>定义是虚函数，具体实现在<code>WebKit</code>可以找到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebKit BackForwardList.mm</span></span><br><span class="line"><span class="keyword">int</span> BackForwardList::backListCount()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_current == NoCurrentItemIndex ? <span class="number">0</span> : m_current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BackForwardList::forwardListCount()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_current == NoCurrentItemIndex ? <span class="number">0</span> : (<span class="keyword">int</span>)m_entries.size() - (m_current + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个方法我们需要关注一下，后面会用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebKit BackForwardList.mm</span></span><br><span class="line"><span class="comment">// 获取之前最多几条历史记录</span></span><br><span class="line"><span class="keyword">void</span> BackForwardList::backListWithLimit(<span class="keyword">int</span> limit, Vector&lt;Ref&lt;HistoryItem&gt;&gt;&amp; <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span>.clear();</span><br><span class="line">    <span class="keyword">if</span> (m_current != NoCurrentItemIndex) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> first = <span class="built_in">std</span>::max(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(m_current) - limit, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (; first &lt; m_current; ++first)</span><br><span class="line">            <span class="built_in">list</span>.append(m_entries[first].get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取History"><a href="#获取History" class="headerlink" title="获取History"></a>获取History</h2><p>在<code>WebView</code>的中，我们可以找到<code>WebBackForwardList</code>的定义。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    @property backForwardList</span></span><br><span class="line"><span class="comment">    @abstract The backforward list for this WebView.</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) WebBackForwardList *backForwardList;</span><br></pre></td></tr></table></figure><p><code>WebBackForwardList</code>是对<code>BackForwardList</code>的一层封装，阅读一下它的.h文件，不难找到获取浏览记录的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">    @method backListWithLimit:</span><br><span class="line">    @abstract Returns a portion of the list before the current entry.</span><br><span class="line">    @param limit A cap on the size of the array returned.</span><br><span class="line">    @result An array of items before the current entry, or nil if there are none.  The entries are in the order that they were originally visited.</span><br><span class="line">*/</span><br><span class="line">- (NSArray *)backListWithLimit:(int)limit;</span><br></pre></td></tr></table></figure><p>上面的方法可以获取到一个<code>WebHistoryItem</code>数组，<code>WebHistoryItem</code>保存了浏览记录的详细信息。</p><h2 id="获取WebBackForwardList"><a href="#获取WebBackForwardList" class="headerlink" title="获取WebBackForwardList"></a>获取WebBackForwardList</h2><p><code>UIWebView</code>没有暴露获取<code>WebView</code>或者<code>WebBackForwardList</code>的方法，但是我们可以用KVO曲线救国，于是我们需要找到<code>WebView</code>的私有变量名。用runtime可以做到，为了简化这个过程，我写了一个工具类来辅助搜索，具体可以看<a href="https://crmo.github.io/2018/07/31/runtime实现私有变量搜索/">这篇文章-runtime实现私有变量搜索</a>。简单来说就是用runtime获取类成员变量列表，然后用BFS来搜索我们要找的类。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以UIWebView为根节点，BFS搜索WebView</span></span><br><span class="line">[BFSSearchClass searchClass:<span class="string">@"WebView"</span> inClass:<span class="string">@"UIWebView"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索结果如下</span></span><br><span class="line"><span class="comment">// Class Name：类名，Ivar Name：变量名，Super Class：父类</span></span><br><span class="line">Class Name:【WebView】,Ivar Name:【_webView】</span><br><span class="line">Class Name:【<span class="built_in">UIWebDocumentView</span>】,Ivar Name:【Super Class】</span><br><span class="line">Class Name:【<span class="built_in">UIWebBrowserView</span>】,Ivar Name:【browserView】</span><br><span class="line">Class Name:【<span class="built_in">UIWebViewInternal</span>】,Ivar Name:【_internal】</span><br><span class="line">Root Class:<span class="built_in">UIWebView</span></span><br></pre></td></tr></table></figure><p>有了上面的结论，我们就可以用KVC来获取到浏览记录了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printWebViewHistory:(<span class="built_in">UIWebView</span> *)aWebView &#123;</span><br><span class="line">    <span class="keyword">id</span> webviewInternal = [aWebView valueForKey:<span class="string">@"_internal"</span>];</span><br><span class="line">    <span class="keyword">id</span> browserView = [webviewInternal valueForKey:<span class="string">@"browserView"</span>];</span><br><span class="line">    <span class="keyword">id</span> webView = [browserView valueForKey:<span class="string">@"_webView"</span>];</span><br><span class="line">    <span class="keyword">id</span> backForwardList = [webView performSelector:<span class="keyword">@selector</span>(backForwardList)];</span><br><span class="line">    <span class="comment">// WebHistoryItem存储的具体某条浏览记录信息</span></span><br><span class="line">    <span class="built_in">NSArray</span> *historyItems = [backForwardList performSelector:<span class="keyword">@selector</span>(backListWithLimit:) withObject:@<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> item <span class="keyword">in</span> historyItems) &#123;</span><br><span class="line">        <span class="comment">// 获取浏览记录的url </span></span><br><span class="line">        <span class="built_in">NSString</span> *url = [item performSelector:<span class="keyword">@selector</span>(URLString)];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文所用方法会使用到苹果私有API，上架APP Store请谨慎使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>runtime实现私有变量搜索</title>
    <link href="https://crmo.github.io/2018/07/31/runtime%E5%AE%9E%E7%8E%B0%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E6%90%9C%E7%B4%A2/"/>
    <id>https://crmo.github.io/2018/07/31/runtime实现私有变量搜索/</id>
    <published>2018-07-30T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.834Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文Demo(<a href="https://github.com/crmo/BFSSearchClass)地址" target="_blank" rel="noopener">https://github.com/crmo/BFSSearchClass)地址</a></p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在开发功能时，为了满足产品变态的需求，难免有系统类提供的API不够用的时候，这时候私有变量就可以发挥它光和热了。怎么通过一个类，一层一层的找到特定类型的私有成员变量？<br>受益于Objective-C的动态语言特性，就算苹果<code>UIKit</code>不开源，但是在runtime面前，类的结构还是暴露无遗。我的思路是逐层手动打印成员变量信息，如果是UI控件可以用Reveal来加快进度，配合KVC机制，获取私有变量就如同探囊取物一般。<br>在多次遇到这个问题后，我决定实现一个工具类来简化这个过程，毕竟能自动化的就尽量不要手动。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>搜索范围：成员变量、属性</p></blockquote><p>关键步骤如下：</p><ol><li>runtime中的方法<code>class_copyIvarList()</code>，可以取出类的所有成员变量结构体<code>Ivar</code>。</li><li>从Ivar中可以取出成员变量类型<code>Type Encodings</code></li><li>用<code>Type Encodings</code>获取到类名</li><li>遍历类的所有<code>Ivar</code>，获取到类的所有成员变量的类信息</li></ol><p>但是问题没这么简单，比如ClassA是ClassB的成员变量，ClassB是ClassC的成员变量，想通过ClassC找到ClassA，需要向下找两层才能找到，还要考虑父类的情况。<br>整个搜索过程就是一颗以待搜索类为根的树，可以用BFS来搜索，步骤如下（如图，数字是搜索顺序）：</p><ol><li>从根节点开始搜索</li><li>首先遍历当前节点的父类，加入搜索队列</li><li>再取出当前节点的所有成员变量，加入搜索队列</li></ol><p><img src="/images/QQ20180731-202956@2x.png" alt="QQ20180731-202956@2x"></p><h2 id="如何从Ivar中获取Class"><a href="#如何从Ivar中获取Class" class="headerlink" title="如何从Ivar中获取Class"></a>如何从Ivar中获取Class</h2><p>Ivar中不能直接取出对应类名，只能取出<code>Type Encodings</code>，间接可以得到类名。从<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">官方文档</a>截了张图，可以清晰的看到Code的定义。</p><p><img src="/images/15329163411347.jpg" alt="15329163411347"></p><p>基本数据类型、id类型、集合类型、结构体等类型就不需要搜索了，可以过滤掉。我们只搜索两种类型</p><ol><li>类，例如<code>@&quot;UIWebViewInternal&quot;</code></li><li>代理，例如<code>@&quot;&lt;UIViewControllerTransitioningDelegate&gt;&quot;</code></li></ol><h2 id="优化及存在问题"><a href="#优化及存在问题" class="headerlink" title="优化及存在问题"></a>优化及存在问题</h2><ol><li>可以用一个<code>NSMutableSet</code>存储已经搜索过的类，每次搜索前判断一下是否已经搜索过</li><li>记录搜索次数，可以限制搜索次数。</li><li>对于定义为id类型、集合类的成员变量没有做处理，可以继续深入遍历</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文Demo(&lt;a href=&quot;https://github.com/crmo/BFSSearchClass)地址&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/crmo/BFSSearchC
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS横竖屏总结</title>
    <link href="https://crmo.github.io/2018/07/23/iOS%E6%A8%AA%E7%AB%96%E5%B1%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://crmo.github.io/2018/07/23/iOS横竖屏总结/</id>
    <published>2018-07-22T16:00:00.000Z</published>
    <updated>2018-10-07T08:13:37.843Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>Auto Layout</code>来进行布局就不用自己去监听横竖屏事件了，只需要绘制多套布局即可。但是项目有很多页面是自己手动计算的，于是只有想办法再旋转屏幕时重新布局。</p><h2 id="相关枚举"><a href="#相关枚举" class="headerlink" title="相关枚举"></a>相关枚举</h2><p>屏幕方向有3个相关枚举，界面方向<code>UIInterfaceOrientation</code>，设备方向<code>UIDeviceOrientation</code>，支持旋转方向<code>UIInterfaceOrientationMask</code>。</p><blockquote><p>注意UIInterfaceOrientation与UIDeviceOrientation左右方向是相反的</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIInterfaceOrientation</span>) &#123;</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationUnknown</span>            = <span class="built_in">UIDeviceOrientationUnknown</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationPortrait</span>           = <span class="built_in">UIDeviceOrientationPortrait</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationPortraitUpsideDown</span> = <span class="built_in">UIDeviceOrientationPortraitUpsideDown</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationLandscapeLeft</span>      = <span class="built_in">UIDeviceOrientationLandscapeRight</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationLandscapeRight</span>     = <span class="built_in">UIDeviceOrientationLandscapeLeft</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIInterfaceOrientationMask</span>) &#123;</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskPortrait</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationPortrait</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationLandscapeLeft</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationLandscapeRight</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskPortraitUpsideDown</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationPortraitUpsideDown</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscape</span> = (<span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskAll</span> = (<span class="built_in">UIInterfaceOrientationMaskPortrait</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span> | <span class="built_in">UIInterfaceOrientationMaskPortraitUpsideDown</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskAllButUpsideDown</span> = (<span class="built_in">UIInterfaceOrientationMaskPortrait</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="横竖屏控制"><a href="#横竖屏控制" class="headerlink" title="横竖屏控制"></a>横竖屏控制</h2><p>控制界面横竖屏切换有3个重要的点，最终结果以这三个地方的值取交集。</p><p><strong>1.info.plist全局控制</strong></p><p>可以在<code>General-&gt;Deplyment Info</code>界面上勾选</p><p><img src="/images/15320065885480.jpg" alt="15320065885480"></p><p> info.plist文件中配置也是一样的，两边会同步变更</p><p><img src="/images/15320512384395.jpg" alt="15320512384395"></p><p><strong>2.AppDelegate中根据不同Window控制</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppDelegate</span></span><br><span class="line">- (<span class="built_in">UIInterfaceOrientationMask</span>)application:(<span class="built_in">UIApplication</span> *)application supportedInterfaceOrientationsForWindow:(<span class="built_in">UIWindow</span> *)window &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskPortrait</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.在ViewController中控制当前页面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// UIViewController</span><br><span class="line">- (BOOL)shouldAutorotate &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</span><br><span class="line">    return UIInterfaceOrientationMaskLandscapeLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，交集不能为空，否则会导致crash</p></blockquote><p>*** Terminating app due to uncaught exception ‘UIApplicationInvalidInterfaceOrientation’, reason: ‘Supported orientations has no common orientation with the application, and [ViewController<br>shouldAutorotate] is returning YES’</p><p><img src="/images/15320548897266-1.jpg" alt="15320548897266"></p><h2 id="旋转事件监听"><a href="#旋转事件监听" class="headerlink" title="旋转事件监听"></a>旋转事件监听</h2><h3 id="旋转事件传递过程"><a href="#旋转事件传递过程" class="headerlink" title="旋转事件传递过程"></a>旋转事件传递过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">op0=&gt;operation: __CFRunLoopDoSources0</span><br><span class="line">op1=&gt;operation: UIDevice</span><br><span class="line">op2=&gt;operation: UIWindow</span><br><span class="line">op3=&gt;operation: UIViewController</span><br><span class="line">op4=&gt;operation: UIView</span><br><span class="line"></span><br><span class="line">op1-&gt;op2-&gt;op3-&gt;op4</span><br></pre></td></tr></table></figure><h3 id="屏幕旋转相关事件"><a href="#屏幕旋转相关事件" class="headerlink" title="屏幕旋转相关事件"></a>屏幕旋转相关事件</h3><p>viewWillTransitionToSize:withTransitionCoordinator:</p><ul><li>ViewController被父容器变更size时调用（例如window旋转时调用root view controller的该方法）</li><li>如果重载该方法，需要调用super传递事件给子ViewController</li><li>这个方法是最关键的，可以在该方法中对界面进行重新布局</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator</span><br><span class="line">&#123;</span><br><span class="line">    // coordinator用来处理转换动画</span><br><span class="line">    [coordinator animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context)</span><br><span class="line">     &#123;</span><br><span class="line">         // 开始旋转</span><br><span class="line">     &#125; completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context)</span><br><span class="line">     &#123;</span><br><span class="line">         // 旋转结束</span><br><span class="line">     &#125;];</span><br><span class="line">     // 记得调用super</span><br><span class="line">    [super viewWillTransitionToSize:size withTransitionCoordinator:coordinator];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UIApplicationWillChangeStatusBarOrientationNotification </p><ul><li>状态栏将要旋转，这个时候取view的frame还是旋转之前的</li><li>NSNotification中用key <code>UIApplicationStatusBarOrientationUserInfoKey</code>可以取到将要旋转到的方向。</li></ul><p>UIApplicationDidChangeStatusBarOrientationNotification </p><ul><li>状态栏已经旋转，这个时候取view的frame是旋转之后的</li><li>NSNotification中用key <code>UIApplicationStatusBarOrientationUserInfoKey</code>可以取到旋转之前的方向。</li></ul><p>UIDeviceOrientationDidChangeNotification </p><ul><li>设备方向变更，在收到通知时取view的frame是旋转之后的。</li><li>在手机上将旋转屏幕锁定之后，设备方向变更之后收不到该通知</li><li>在代码里面限制设备旋转方向，设备方向变更后依然能收到该通知</li></ul><p>调用顺序如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 旋转屏幕</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op1=&gt;operation: viewWillTransitionToSize:withTransitionCoordinator:</span><br><span class="line">op2=&gt;operation: UIApplicationWillChangeStatusBarOrientationNotification</span><br><span class="line">op3=&gt;operation: UIApplicationDidChangeStatusBarOrientationNotification</span><br><span class="line">op4=&gt;operation: viewWillLayoutSubviews</span><br><span class="line">op5=&gt;operation: viewDidLayoutSubviews</span><br><span class="line">op6=&gt;operation: UIDeviceOrientationDidChangeNotification</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;e</span><br></pre></td></tr></table></figure><h2 id="自定义Window的旋转事件"><a href="#自定义Window的旋转事件" class="headerlink" title="自定义Window的旋转事件"></a>自定义Window的旋转事件</h2><p>如果想要在自定义Window的子View收到屏幕旋转通知，要设置UIWindow的rootViewController，然后把所有子view都加到rootViewController，系统会处理横竖屏事件。这里我还遇到一个坑<a href="https://crmo.github.io/2018/07/19/记一个实现UIWindow子类的小坑/">记一个实现UIWindow子类的小坑</a>。</p><hr><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://satanwoo.github.io/2016/09/17/uiwindow-iOS/" target="_blank" rel="noopener">https://satanwoo.github.io/2016/09/17/uiwindow-iOS/</a><br><a href="https://tbd.ink/2017/07/05/iOS/17070501.iOS屏幕旋转知识点以及实现/index/" target="_blank" rel="noopener">iOS屏幕旋转知识点以及实现</a><br><a href="https://imtangqi.com/2017/03/08/handle-orientation-changes-one/" target="_blank" rel="noopener">iOS 屏幕旋转的那些事（一）</a><br><a href="https://satanwoo.github.io/2016/09/17/uiwindow-iOS/" target="_blank" rel="noopener">浅谈iOS的多Window处理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用&lt;code&gt;Auto Layout&lt;/code&gt;来进行布局就不用自己去监听横竖屏事件了，只需要绘制多套布局即可。但是项目有很多页面是自己手动计算的，于是只有想办法再旋转屏幕时重新布局。&lt;/p&gt;
&lt;h2 id=&quot;相关枚举&quot;&gt;&lt;a href=&quot;#相关枚举&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="iOS知识小结" scheme="https://crmo.github.io/tags/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
</feed>
